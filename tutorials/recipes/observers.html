




  

  

  

  
    
    
    

<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="author" content="">

<link rel="apple-touch-icon" sizes="180x180" href="/mc_rtc/assets/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/mc_rtc/assets/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/mc_rtc/assets/favicons/favicon-16x16.png">
<link rel="manifest" href="/mc_rtc/assets/favicons/site.webmanifest">
<link rel="mask-icon" href="/mc_rtc/assets/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">


<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">

<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js"></script>





<link href="/mc_rtc/css/mc_rtc.css" rel="stylesheet">

    <title>Tutorials - State Observation Pipelines - mc_rtc</title>
  </head>

  <body>
    <header class="navbar navbar-expand-lg navbar-light bg-light sticky-top" role="navigation">
  <a class="navbar-brand" href="/mc_rtc/index.html"><img src="/mc_rtc/assets/logo.png" alt="logo" width="30" height="30"/> mc_rtc</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText" aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarText">
    <div class="navbar-nav mr-auto">
      
        
        
        <a class="nav-item nav-link " href="/mc_rtc/interfaces.html">Interfaces</a>
      
        
        
        <a class="nav-item nav-link " href="/mc_rtc/robots.html">Robots</a>
      
        
        
        <a class="nav-item nav-link active" href="/mc_rtc/tutorials.html">Tutorials</a>
      
        
        
        <a class="nav-item nav-link " href="/mc_rtc/doxygen.html">API documentation</a>
      
        
        
        <a class="nav-item nav-link " href="/mc_rtc/json.html">JSON/YAML documentation</a>
      
      <a class="nav-item nav-link" href="https://mc-rtc-demo.netlify.app/" target="blank_">Online demonstration</a>
    </div>
    
      
      
      
      EN
      
      
        &nbsp;|&nbsp;
      
    
      
      
      
        <a href="/mc_rtc/jp/tutorials/recipes/observers.html">
      
      JP
      
        </a>
      
      
        &nbsp;&nbsp;&nbsp;
      
    
    <a href="https://github.com/jrl-umi3218/mc_rtc" target="blank_"><svg height="25" width="25" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a>
  </div>
</header>


    <div class="container-fluid">
      <div class="row">
      <div class="col col-lg-3">
        <div class="sticky-top sticky-toc">
          <div class="accordion" id="accordionTutorials">
            <div class="card">
              <div class="card-header" id="headingOtherTutorials">
                <button class="btn btn-link btn-block text-left" type="button" data-toggle="collapse" data-target="#collapseOtherTutorials" aria-expanded="true" aria-controls="collapseOtherTutorials">
                  Other tutorials
                </button>
              </div>
              <div id="collapseOtherTutorials" class="collapse" arial-labelledby="headingOtherTutorials" data-parent="#accordionTutorials">
                <div class="card-body">
                  <ul>
                    
                    <li>Introduction</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/tutorials/introduction/installation-guide.html">Installation guide</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/introduction/configuration.html">Configuring mc_rtc</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/introduction/running-a-controller.html">Running a controller</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/introduction/first-controller.html">Your first controller with mc_rtc</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/introduction/com-controller.html">Controlling the CoM</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/introduction/ef-controller.html">Controlling an end-effector (and loading)</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/introduction/multi-robot-controller.html">Multi-robot controller</a></li>
                        
                      
                    </ul>
                    
                    <li>Framework usage</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/tutorials/usage/mc_rtc_configuration.html"><code>mc_rtc::Configuration</code> general purpose configuration</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/usage/logging.html">Logging data</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/usage/console-logging.html">Printing information to the screen</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/usage/gui.html">Graphical User Interface (GUI)</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/usage/live-plotting.html">Display plots live from the controller</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/usage/ros.html">ROS integration</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/usage/global-plugins.html">Using global plugins</a></li>
                        
                      
                    </ul>
                    
                    <li>Framework tools</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/tutorials/tools/mc_log_utils.html">Log manipulation</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/tools/mc_log_ui.html">Log plotting</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/tools/mc_log_visualization.html">Replay visualization</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/tools/mc_surfaces_visualization.html">Visualizing surfaces</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/tools/mc_convex_visualization.html">Visualizing convexes</a></li>
                        
                      
                    </ul>
                    
                    <li>Control recipes</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/fsm.html">Using the FSM facilities</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/fsm-main-states.html">Main FSM states</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/fsm-example.html">FSM controller in practice</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/derived-fsm.html">Deriving the FSM controller</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/datastore.html">DataStore: Sharing Objects</a></li>
                        
                      
                        
                        <li><strong>State Observation Pipelines</strong></li>
                          
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/lipm-stabilizer.html">Using the LIPM Stabilizer</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/speed-constraint.html">Constraint the speed of a body</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/moving-a-contact.html">Moving a contact</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/contact-dof.html">Change the DoF constraints on a contact</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/joint-select.html">Select specific joints for a task</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/dim-weight.html">Affect different weight to different axis in the task space</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/joint-stiffness.html">Joints Stiffness</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/recipes/com-constraint.html">Constraining the accessible region of the CoM</a></li>
                        
                      
                    </ul>
                    
                    <li>Samples</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/tutorials/samples/list-of-samples.html">Available sample controllers</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/samples/sample-admittance.html">Admittance sample controller</a></li>
                        
                      
                    </ul>
                    
                    <li>Advanced topics</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/tutorials/advanced/new-plugin.html">Implement a new plugin for mc_rtc</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/advanced/new-interface.html">Implement a new mc_rtc interface</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/advanced/new-environment.html">Environment creation for mc_rtc</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/advanced/new-robot.html">Integrate a new robot in mc_rtc</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/advanced/support-mc-rtc-build-static.html">Supporting MC_RTC_BUILD_STATIC in your code</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/tutorials/advanced/debug-lssol-output-6.html">Debugging LSSOL output 6</a></li>
                        
                      
                    </ul>
                    
                  </ul>
                </div>
              </div>
              
                <ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#configuring-the-observer-pipelines">Configuring the observer pipelines</a></li>
<li class="toc-entry toc-h1"><a href="#default-observers">Default observers</a>
<ul>
<li class="toc-entry toc-h2"><a href="#encoder-observer">Encoder observer</a></li>
<li class="toc-entry toc-h2"><a href="#bodysensor-observer">BodySensor observer</a></li>
<li class="toc-entry toc-h2"><a href="#kinematicinertial-observer">KinematicInertial observer</a></li>
<li class="toc-entry toc-h2"><a href="#visualizing-the-estimated-robot">Visualizing the estimated robot</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#interacting-with-observer-pipelines-from-code">Interacting with observer pipelines from code</a>
<ul>
<li class="toc-entry toc-h2"><a href="#querying-the-status-of-observer-pipelines">Querying the status of observer pipelines</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#creating-your-own-observer">Creating your own Observer</a></li>
</ul>
              
            </div>
          </div>
        </div>
      </div>
      <div class="col-9" id="tutorial-content">
        
        <h1>State Observation Pipelines</h1>
        

        <p>One commonly needs to know the real state of the robots being controlled. Unfortunately, their state can rarely be fully known, as the robots’ embedded sensors rarely provide sufficient information. Instead, the systems’ state relevant to the controller need to be inferred from various sensor measurements (joint encoders, force-torque sensors, IMU, cameras, etc), along with additional knowledge about the controller’s intent (contacts, etc). For instance, a floating-base robot typically doesn’t have any sensor capable of providing the full state of its floating base (position, orientation, velocity, etc), and one must make use of the available information to estimate it. This may for instance a combination of IMU, kalman filters and known information about the robot kinematics. Or one might choose to use visual odometry instead, obtain ground truth measurements from a motion capture system, or any combination of those. This process is refered to as state observation.</p>

<p>Each controller has its own requirements on what the state of the observed robots should be. A humanoid robot’s walking controller will be particularly interesting in robustly estimating the state of the robot’s center of mass, and thus needs to know the full kinematic state of the robot (position and velocity of each of its bodies, including the floating base), but a manipulator arm might only care about joint position and velocity. One may also be interested in comparing various methods to obtain that state (ground truth information vs estimated, different sensors or algorithms, etc).</p>

<p>The framework provides a mechanism, refered to as <strong>State Observation Pipelines</strong>, to simplify and generalize the observation of a robot, or multiple robots states. The concept is to view state observation as a pipelines, where each pipeline is composed of multiple observers executed sequentially. Each observer is a component responsible for estimating part of the robot state. When combined together, all observers in a pipeline contribute to provide a full estimation of the desired robot state. Multiple pipelines can be defined and executed allowing to estimate the state of multiple robots, or to perform comparisons between multiple estimation methods. The observers themselves are, as is the case for controller, tasks, plugins, loaded from libraries with a simple interface, allowing to conveniently define your own. The framework currently provides the following observers by default:</p>

<ul>
  <li><strong>Encoder Observer</strong>: estimates a robot’s joint state (position and velocity) and computes forward kinematics and velocities to obtain body positions and velocities. Various inputs may be used: encoder position, encoder velocity (obtained from a velocity sensor or by finite differences of position), another robot’s joint values, etc.</li>
  <li><strong>BodySensor Observer</strong>: sets a robot’s floating base state from measurements provided by a sensor attached to a robot body and the kinematics between the sensor and the floating base. This is typically be used to exploit ground truth measurement from a simulator, or exploit the results of an external component providing information about the floating base (MOCAP, embedded estimator on the robot plateform, etc).</li>
  <li><strong>KinematicInertial Observer</strong>: estimates a robot’s floating base pose (position + orientation) and velocity (low-pass filtered finite differences of position) from a <a href="/mc_rtc/doxygen.html#structmc__rbdyn_1_1BodySensor" target="blank_"><code>mc_rbdyn::BodySensor</code></a> (IMU orientation) and a kinematic anchor frame.</li>
</ul>

<p>To represent the robots, the framework provides two sets of robot instances (<a href="/mc_rtc/doxygen.html#structmc__rbdyn_1_1Robots" target="blank_"><code>mc_rbdyn::Robots</code></a>):</p>
<ul>
  <li><a href="/mc_rtc/doxygen.html#structmc__control_1_1MCController#ae45b98b34b9c614d9eb3aaa86371f53d" target="blank_"><code>mc_control::MCController::robots()</code></a> represents the control state (desired) of the robots.</li>
  <li><a href="/mc_rtc/doxygen.html#structmc__control_1_1MCController#a0300e29b876797fe06dd7c16c971905d" target="blank_"><code>mc_control::MCController::realRobots()</code></a> represents the state of the real robots. It’s the role of the observer pipeline to define how these robot states are estimated.</li>
</ul>

<h1 id="configuring-the-observer-pipelines">Configuring the observer pipelines</h1>

<p>State observation pipelines can be configured in your controller configuration (each pipeline configuration superseeds the previous one):</p>

<ul>
  <li>Global configuration: <code class="highlight language-bash" data-lang="bash"><span class="nv">$INSTALL_PREFIX</span>/etc/mc_rtc.yaml</code></li>
  <li>User configuration: <code class="highlight language-bash" data-lang="bash"><span class="nv">$HOME</span>/.config/mc_rtc/mc_rtc.yaml</code></li>
  <li>Controller-specific configuration: <code class="highlight language-bash" data-lang="bash"><span class="nv">$HOME</span>/.config/mc_rtc/mc_controllers/YourController.yaml</code></li>
  <li>The FSM configuration of your controller: <code class="highlight language-bash" data-lang="bash">YouController.yaml</code> (recommended)</li>
</ul>

<p>The configuration format is fully documented in the <a href="../../json.html#Observers/ObserverPipelines">Observers JSON schema</a>.</p>

<p>Let’s look first at a simple representative example to estimate the state of a floating-base robot from encoder position measurements and a sensor providing roll and pitch orientation of the floating base.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">ObserverPipelines</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">MainPipeline</span>                     <span class="c1"># - Create a new pipeline</span>
  <span class="na">gui</span><span class="pi">:</span> <span class="no">true</span>                              <span class="c1">#   diplay the pipeline in the GUI (default = false)</span>
  <span class="na">log</span><span class="pi">:</span> <span class="no">true</span>                              <span class="c1">#   log observers (default)</span>

  <span class="na">observers</span><span class="pi">:</span>                             <span class="c1">#   declare which observers to use</span>
  <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">Encoder</span>                        <span class="c1"># - Use an EncoderObserver</span>
    <span class="na">config</span><span class="pi">:</span>                              <span class="c1">#</span>
      <span class="na">position</span><span class="pi">:</span> <span class="s">encoderValues</span>            <span class="c1">#    - Sets joint position from encoder sensor values (default)</span>
      <span class="na">velocity</span><span class="pi">:</span> <span class="s">encoderFiniteDifferences</span> <span class="c1">#    - Computes joint velocities by finite differences  (default)</span>
                                         <span class="c1"># We now have the estimation of each joint position and velocity and the corresponding</span>
                                         <span class="c1"># body positions and velocities, but we are still missing the floating base</span>

  <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">BodySensor</span>                     <span class="c1"># - Use a BodySensor observer</span>
    <span class="na">update</span><span class="pi">:</span> <span class="no">false</span>                        <span class="c1">#   Do not update the real robot state</span>
    <span class="na">gui</span><span class="pi">:</span> <span class="no">false</span>                           <span class="c1">#   Do not display in the gui</span>
    <span class="na">config</span><span class="pi">:</span>                              <span class="c1">#</span>
      <span class="na">bodySensor</span><span class="pi">:</span> <span class="s">FloatingBase</span>           <span class="c1">#   In simulation, the interface will fill this sensor with ground truth values</span>
                                         <span class="c1">#   The observer computes the position and velocity of the floating base</span>
                                         <span class="c1">#   by transforming the sensor measurements to the floating base frame</span>

  <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">KinematicInertial</span>              <span class="c1"># - Estimates the floating base state using the KinematicInertial observer</span>
    <span class="na">update</span><span class="pi">:</span> <span class="no">true</span>                         <span class="c1">#   update the real robot instance from its results</span>
    <span class="na">gui</span><span class="pi">:</span> <span class="no">true</span>                            <span class="c1">#   Displays the estimated velocity as an arrow (default)</span>
    <span class="na">config</span><span class="pi">:</span>
      <span class="na">imuBodySensor</span><span class="pi">:</span> <span class="s">Accelerometer</span>       <span class="c1"># This observer only uses roll and pitch rotation information from this sensor</span>
                                         <span class="c1"># along with a kinematic anchor point and the robot kinematics between the anchor</span>
                                         <span class="c1"># frame and the floating base frame. The anchor frame is expected to be provided</span>
                                         <span class="c1"># through a datastore callback (see below for details)</span>
</code></pre></div></div>

<p>Please refer to the corresponding JSON schemas for a full list of available options:</p>
<ul>
  <li><a href="../../json.html#Observers/ObserverPipelines">ObserverPipelines</a>: array of multiple state observation pipelines</li>
  <li><a href="../../json.html#Observers/ObserverPipeline">ObserverPipeline</a>: definition of an observer pipeline, containing observers</li>
  <li><a href="../../json.html#Observers/Encoder">EncoderObserver</a>: options for the encoder observer</li>
  <li><a href="../../json.html#Observers/BodySensor">BodySensorObserver</a>: options for the BodySensor observer</li>
  <li><a href="../../json.html#Observers/KinematicInertial">KinematicInertial</a>: options for the KinematicInertial observer</li>
</ul>

<p>When creating a controller with the above pipeline, the framework will display a short summary as</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ObserverPipelines:
- ExamplePipeline: Encoder (position=encoderValues,velocity=encoderFiniteDifferences) -&gt; [BodySensor (sensor=FloatingBase,update=sensor)] -&gt;  KinematicInertial (sensor=Accelerometer,cutoff=0.010000)
</code></pre></div></div>

<p>This displays information about the running pipelines, and their sequence of observers. Observers displayed between <code class="language-plaintext highlighter-rouge">[..]</code> brackets are run but do not affect the state of the <code class="language-plaintext highlighter-rouge">realRobots</code> instance. After running the pipelines, the <code class="language-plaintext highlighter-rouge">realRobots</code> instances now contain the estimated robot states, and can be used in the controller.</p>

<p>For instance, with the above pipeline you can:</p>
<ul>
  <li>Get joint position <code class="language-plaintext highlighter-rouge">readRobot().mbc().q()</code> and velocity <code class="language-plaintext highlighter-rouge">realRobot().mbc().alpha()</code></li>
  <li>Get the floating base pose <code class="language-plaintext highlighter-rouge">realRobot().posW()</code></li>
  <li>Get the floating base velocity <code class="language-plaintext highlighter-rouge">realRobot().velW()</code></li>
  <li>Get the pose of a body: <code class="language-plaintext highlighter-rouge">realRobot().bodyPosW("bodyName");</code></li>
  <li>Get the velocity of a body: <code class="language-plaintext highlighter-rouge">realRobot().bodyVelW("bodyName");</code></li>
  <li>Compute the CoM position and velocity <code class="language-plaintext highlighter-rouge">realRobot().com() / realRobot().comVelocity()</code></li>
  <li>…</li>
</ul>

<p>The end-result for this example pipeline looks like this <em>(left: choreonoid simulation, right: control state [transparent], observed state [solid])</em></p>

<div class="embed-responsive embed-responsive-16by9">
  <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/ssoNkV940yc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</div>

<h1 id="default-observers">Default observers</h1>

<p>This section provides a brief description of the default observers provided with the framework. Please refer to each observer’s API documentation and JSON Schema for further details.</p>

<h2 id="encoder-observer">Encoder observer</h2>

<ul>
  <li>API: <a href="/mc_rtc/doxygen.html#structmc__observers_1_1EncoderObserver" target="blank_"><code>mc_observers::EncoderObserver</code></a></li>
  <li><a href="../../json.html#Observers/Encoder">JSON Schema</a></li>
</ul>

<p>The encoder observer may be used to obtain the position and velocity of all actuated joints.</p>

<ul>
  <li>Joint values can be obtained from sensor as provided by <a href="/mc_rtc/doxygen.html#structmc__rbdyn_1_1Robot#a1da8134deea10a32f7d35fc381649606" target="blank_"><code>mc_rbdyn::Robot::encoderValues()</code></a> or using the joint state of another robot <a href="/mc_rtc/doxygen.html#structmc__rbdyn_1_1Robot#a485eb8aa4ceb0a0a5010844d16e47f95" target="blank_"><code>mc_rbdyn::Robot::q()</code></a>.</li>
  <li>Joint velocities can be obtained from a joint velocity sensor <a href="/mc_rtc/doxygen.html#structmc__rbdyn_1_1Robot#a8a2e3e0b4b0e226712007e9fe905f9e9" target="blank_"><code>mc_rbdyn::Robot::encoderVelocities()</code></a>, estimated by finite differences of the (estimated) position, or using the joint velocities of another robot <a href="/mc_rtc/doxygen.html#structmc__rbdyn_1_1Robot#a5773f91f2a9d0eb5cb4b6a0943551a1b" target="blank_"><code>mc_rbdyn::Robot::alpha()</code></a></li>
  <li>The observer will compute forward kinematics <a href="/mc_rtc/doxygen.html#structmc__rbdyn_1_1Robot#ae46b693d4431e61db9f1d4a05f66dd5e" target="blank_"><code>mc_rbdyn::Robot::forwardKinematics()</code></a> and forward velocity <a href="/mc_rtc/doxygen.html#structmc__rbdyn_1_1Robot#afd93342dd86da6803288346a3798d374" target="blank_"><code>mc_rbdyn::Robot::forwardVelocity()</code></a> to update the corresponding body positions and velocities (which may be required by subsequent observers).</li>
</ul>

<h2 id="bodysensor-observer">BodySensor observer</h2>

<ul>
  <li>API: <a href="/mc_rtc/doxygen.html#structmc__observers_1_1BodySensorObserver" target="blank_"><code>mc_observers::BodySensorObserver</code></a></li>
  <li><a href="../../json.html#Observers/BodySensor">JSON Schema</a></li>
</ul>

<p>The BodySensor observer allows to estimate the state of the floating base from information provided by a <a href="/mc_rtc/doxygen.html#structmc__rbdyn_1_1BodySensor" target="blank_"><code>mc_rbdyn::BodySensor</code></a>. BodySensors are sensors attached to a robot body representing measurements of its state. A <code class="language-plaintext highlighter-rouge">BodySensor</code> may contain:</p>

<ul>
  <li>Transformation between the sensor and the body to which it is attached [required]</li>
  <li>Position and orientation of the body</li>
  <li>Linear and angular velocity</li>
  <li>Linear and angular acceleration</li>
</ul>

<p>Depending on the available sensors on the robot, only some of these measurements may be available while others will default to zero. The BodySensor observer requires at least the position, orientation, linear and angular velocity measurements. Futhermore, if the sensor is not directly attached to the floating base, it requires the kinematic transformation between the sensor and the floating-base to be up-to-date (you may for instance use the <code class="language-plaintext highlighter-rouge">EncoderObserver</code>).</p>

<p>This observer is commonly used to let simulation interfaces provide ground truth measurements of the floating base state through a <code class="language-plaintext highlighter-rouge">FloatingBase</code> body sensor.</p>

<h2 id="kinematicinertial-observer">KinematicInertial observer</h2>

<ul>
  <li>API: <a href="/mc_rtc/doxygen.html#structmc__observers_1_1KinematicInertialObserver" target="blank_"><code>mc_observers::KinematicInertialObserver</code></a></li>
  <li><a href="../../json.html#Observers/KinematicInertial">JSON Schema</a></li>
  <li><a href="https://scaron.info/teaching/floating-base-estimation.html">Detailed explanation of the method by Stéphane Caron</a></li>
</ul>

<p>Floating base robots rarely have sensors capable of providing the full state of the floating base. The KinematicInertial observer provides a simple method to estimate the floating base position, orientation, linear and angular velocity based on measurement based on orientation estimation obtained from an IMU sensor. Please refer to <a href="https://scaron.info/teaching/floating-base-estimation.html">Stéphane Caron’s website</a> for a full explanation of the method implemented here. Note that this observer has been extensively used in practice in the <a href="https://github.com/jrl-umi3218/lipm_walking_controller">LIPM Walking Controller</a> for walking, including stair climbing (<a href="https://www.youtube.com/embed/vFCFKAunsYM">video</a>).</p>

<p>The method expects the roll and pitch rotation angle w.r.t gravity to be provided by a sensor. The rotation along the gravity vector (yaw) is assumed to be unobservable by sensor (as is the case for IMU), and is instead replaced by the desired rotation of the control robot to provide a complete estimation of the sensor’s frame.</p>

<p>The estimation of position relies on the assumption that the contact position is known and only concerns itself with estimating the position that best matches the observed orientation. This is achieved by providing a anchor point in-between the assumed contact positions. When static a suitable choice of anchor frame is a point center in-between all contacts. When performing motions such as walking, the anchor frame is expected to be smoothly interpolated in-between the contacts such that there is no discontinuity when contact transition occurs. This frame is expected to be provided through a datastore callback <a href="/mc_rtc/tutorials/recipes/datastore.html">datastore</a>.</p>

<p>For example, in the pipeline described in the previous section, the anchor frame is provided as a frame center between the two expected feet contact.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">leftFootRatio</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">ctl</span><span class="p">.</span><span class="n">datastore</span><span class="p">().</span><span class="n">make_call</span><span class="p">(</span><span class="s">"KinematicAnchorFrame::"</span> <span class="o">+</span> <span class="n">robot</span><span class="p">().</span><span class="n">name</span><span class="p">(),</span>
                          <span class="p">[</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leftFootRatio</span><span class="p">](</span><span class="k">const</span> <span class="n">mc_rbdyn</span><span class="o">::</span><span class="n">Robot</span> <span class="o">&amp;</span> <span class="n">robot</span><span class="p">)</span>
                          <span class="p">{</span>
                            <span class="k">return</span> <span class="n">sva</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">robot</span><span class="p">().</span><span class="n">surfacePose</span><span class="p">(</span><span class="s">"LeftFoot"</span><span class="p">),</span>
                                                    <span class="n">robot</span><span class="p">().</span><span class="n">surfacePose</span><span class="p">(</span><span class="s">"RightFoot"</span><span class="p">),</span>
                                                    <span class="n">leftFootRatio</span><span class="p">)</span>
                          <span class="p">});</span>
</code></pre></div></div>

<p>Note that this function will be called twice: once for the control robot instance, once for the real robot instance (only the relative pose between the anchor frame and the sensor frame is used by the observer).</p>

<p>If one wanted to walk, starting with a right contact and left swing foot motion, the anchor frame would need to be moved smoothly towards the right contact first until contact transition occurs, then be moved smoothly between the two planned contacts such that it ends up at the newly established left foot contact once the step is completed. Discontinuities in the anchor frame may result in jumps of the estimated floating base position (orientation is not affected).</p>

<p>This observer then computes the floating base linear and angular velocity by finite differences of the estimated position and orientation. This velocity is low-pass filtered.</p>

<p>You can find examples of this observer in use in the <a href="/mc_rtc/tutorials/samples/sample-admittance.html">Admittance sample controller tutorial</a>, the <a href="/mc_rtc/doxygen.html#structmc__control_1_1fsm_1_1StabilizerStandingState" target="blank_"><code>mc_control::fsm::StabilizerStandingState</code></a>, and a more complex use in the <a href="https://github.com/jrl-umi3218/lipm_walking_controller">LIPMWalking controller</a>.</p>

<h2 id="visualizing-the-estimated-robot">Visualizing the estimated robot</h2>

<p>You may visualize the estimated robots in rviz. By default the main robot instance is shown as the <code class="language-plaintext highlighter-rouge">RealRobot</code> element with the following properties.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">Robot Description path</span><span class="pi">:</span> <span class="s">/real/robot_description</span>
<span class="na">TF Prefix</span><span class="pi">:</span> <span class="s">/real</span>
</code></pre></div></div>

<p>Additional robots are published as:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># robots published as env_1, env_2, etc</span>
<span class="na">Robot Description path</span><span class="pi">:</span> <span class="s">/real/env_*/robot_description</span>
<span class="na">TF Prefix</span><span class="pi">:</span> <span class="s">/real/env_*</span>
</code></pre></div></div>

<h1 id="interacting-with-observer-pipelines-from-code">Interacting with observer pipelines from code</h1>

<p>In some cases, it might be useful to interact with observer pipelines in your code. You might for instance want to:</p>
<ul>
  <li>check whether a specific observation pipeline is running</li>
  <li>check whether some specific observers are present</li>
  <li>know the status of specific observers from code</li>
  <li>only perfom actions if some observers are present</li>
  <li>etc…</li>
</ul>

<h2 id="querying-the-status-of-observer-pipelines">Querying the status of observer pipelines</h2>

<p>Here is a short snippet of code to showcase how one can query the status of observer pipelines and take actions accordingly:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">checkObserverPipeline</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">observerPipelineName</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">hasObserverPipeline</span><span class="p">(</span><span class="n">observerPipelineName</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">mc_rtc</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">error</span><span class="p">(</span><span class="s">"This controller does not have a pipeline named {}"</span><span class="p">,</span> <span class="n">observerPipelineName</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">observerp</span> <span class="o">=</span> <span class="n">observerPipeline</span><span class="p">(</span><span class="n">observerPipelineName</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">observerp</span><span class="p">.</span><span class="n">success</span><span class="p">())</span> <span class="c1">// Check if the pipeline failed</span>
  <span class="p">{</span>
    <span class="n">mc_rtc</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">error</span><span class="p">(</span><span class="s">"Required pipeline </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s"> for real robot observation failed to run!"</span><span class="p">,</span> <span class="n">observerPipelineName</span><span class="p">);</span>
    <span class="c1">// Check which observer failed</span>
    <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">observer</span> <span class="o">:</span> <span class="n">observerp</span><span class="p">.</span><span class="n">observers</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">observer</span><span class="p">.</span><span class="n">success</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="c1">// Display failure error</span>
        <span class="n">mc_rtc</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">error</span><span class="p">(</span><span class="s">"Observer </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s"> failed with error </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span> <span class="n">observer</span><span class="p">.</span><span class="n">observer</span><span class="p">().</span><span class="n">name</span><span class="p">(),</span> <span class="n">observer</span><span class="p">.</span><span class="n">observer</span><span class="p">().</span><span class="n">error</span><span class="p">());</span>
        <span class="k">if</span><span class="p">(</span><span class="n">observer</span><span class="p">.</span><span class="n">observer</span><span class="p">().</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="s">"MyObserver"</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="c1">// do something specific if this observer failed</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now calling <code class="language-plaintext highlighter-rouge">checkObserverPipeline("RequiredObserverPipeline");</code> will inform you if this pipeline does not exist, show exactly which observer is failing and why, and do something specific with <code class="language-plaintext highlighter-rouge">MyObserver</code> if it is in the pipeline.
For further available functionnalities, please refer to <a href="/mc_rtc/doxygen.html#structmc__observers_1_1ObserverPipeline" target="blank_"><code>mc_observers::ObserverPipeline</code></a> documentation.</p>

<h1 id="creating-your-own-observer">Creating your own Observer</h1>

<p>The framework loads observers from libraries. For this to work, your observer must inherit from <a href="/mc_rtc/doxygen.html#structmc__observers_1_1Observer" target="blank_"><code>mc_observers::Observer</code></a> and implement the following <code class="language-plaintext highlighter-rouge">virtual</code> functions:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// YourObserver.h</span>
<span class="kt">void</span> <span class="n">configure</span><span class="p">(</span><span class="k">const</span> <span class="n">mc_control</span><span class="o">::</span><span class="n">MCController</span> <span class="o">&amp;</span> <span class="cm">/*ctl*/</span><span class="p">,</span> <span class="k">const</span> <span class="n">mc_rtc</span><span class="o">::</span><span class="n">Configuration</span> <span class="o">&amp;</span> <span class="cm">/*config*/</span><span class="p">)</span> <span class="k">override</span>
<span class="kt">void</span> <span class="n">reset</span> <span class="p">(</span><span class="k">const</span> <span class="n">mc_control</span><span class="o">::</span><span class="n">MCController</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">)</span> <span class="k">override</span>
<span class="kt">bool</span> <span class="n">run</span> <span class="p">(</span><span class="k">const</span> <span class="n">mc_control</span><span class="o">::</span><span class="n">MCController</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">)</span> <span class="k">override</span>
<span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">mc_control</span><span class="o">::</span><span class="n">MCController</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">)</span> <span class="k">override</span>
</code></pre></div></div>

<p>Furthermore, in order for <code class="language-plaintext highlighter-rouge">mc_rtc</code> to find your observer, you must define the loading symbols that <code class="language-plaintext highlighter-rouge">mc_rtc</code>’s observer loader will look for in your library. This can be done through the following macro defined in <code class="language-plaintext highlighter-rouge">mc_observers/ObserverMacros.h</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// YourObserver.cpp</span>
<span class="cp">#include &lt;mc_observers/ObserverMacros.h&gt;
</span><span class="c1">// Observer implementation (configure, reset, run and update functions)</span>
<span class="n">EXPORT_OBSERVER_MODULE</span><span class="p">(</span><span class="s">"YourObserver"</span><span class="p">,</span> <span class="n">your_namespace</span><span class="o">::</span><span class="n">YourObserverClassName</span><span class="p">)</span>
</code></pre></div></div>

<p>To compile your own observer, you can use the provided macro, which takes care of linking your observer with <code class="language-plaintext highlighter-rouge">mc_observers</code>, and installing it in the default observers path.</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">add_observer</span><span class="p">(</span>YourObserverName YourObserver.cpp YourObserver.h<span class="p">)</span>
</code></pre></div></div>

<p>Note: If you wish to inherit from one of the default observers provided along with the framework, you will need to link against it. For example, if you inherit from <a href="/mc_rtc/doxygen.html#structmc__observers_1_1BodySensorObserver" target="blank_"><code>mc_observers::BodySensorObserver</code></a> you need to link against the corresponding <code class="language-plaintext highlighter-rouge">mc_observers::BodySensorObserver</code> target:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">target_link_libraries</span><span class="p">(</span>YourObserverName PUBLIC mc_observers::BodySensorObserver<span class="p">)</span>
</code></pre></div></div>

<p>For a practical example, please refer to this <a href="https://github.com/arntanguy/mc_observer_example">sample project</a>.</p>



        <hr/>
        
        <div class="text-right">
          <a href="/mc_rtc/tutorials/recipes/lipm-stabilizer.html">Next tutorial: Using the LIPM Stabilizer</a>
        </div>
        
      </div>
      </div>
    </div>

    <div class="container-fluid">
  <footer>
    <hr>
    <div class="row">
      <div class="col-8 offset-lg-2 col-lg-6">
        Copyright &copy; CNRS-AIST JRL, CNRS LIRMM 2015-2020
      </div>
      <div class="col-4 col-lg-2 text-right">
        <a href="/mc_rtc/credits.html">Credits</a>
      </div>
    </div>
  </footer>
</div>

  </body>

  <script type="text/javascript">
$(document).ready(function()
{
  new ClipboardJS('.copy-button');
});
</script>


</html>
