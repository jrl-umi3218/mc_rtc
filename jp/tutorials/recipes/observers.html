




  

  

  

  
    
    
    

<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="author" content="">

<link rel="apple-touch-icon" sizes="180x180" href="/mc_rtc/assets/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/mc_rtc/assets/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/mc_rtc/assets/favicons/favicon-16x16.png">
<link rel="manifest" href="/mc_rtc/assets/favicons/site.webmanifest">
<link rel="mask-icon" href="/mc_rtc/assets/favicons/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">


<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">

<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js"></script>





<link href="/mc_rtc/css/mc_rtc.css" rel="stylesheet">

    <title>チュートリアル - ステートオブザベーションパイプライン - mc_rtc</title>
  </head>

  <body>
    <header class="navbar navbar-expand-lg navbar-light bg-light sticky-top" role="navigation">
  <a class="navbar-brand" href="/mc_rtc/jp/index.html"><img src="/mc_rtc/assets/logo.png" alt="logo" width="30" height="30"/> mc_rtc</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText" aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarText">
    <div class="navbar-nav mr-auto">
      
        
        
        <a class="nav-item nav-link " href="/mc_rtc/jp/interfaces.html">インタフェース</a>
      
        
        
        <a class="nav-item nav-link " href="/mc_rtc/jp/robots.html">ロボット</a>
      
        
        
        <a class="nav-item nav-link active" href="/mc_rtc/jp/tutorials.html">チュートリアル</a>
      
        
        
        <a class="nav-item nav-link " href="/mc_rtc/jp/doxygen.html">API ドキュメンテーション</a>
      
        
        
        <a class="nav-item nav-link " href="/mc_rtc/jp/json.html">JSON/YAML ドキュメンテーション</a>
      
      <a class="nav-item nav-link" href="https://mc-rtc-demo.netlify.app/" target="blank_">オンラインデモ</a>
    </div>
    
      
      
      
        <a href="/mc_rtc/tutorials/recipes/observers.html">
      
      EN
      
        </a>
      
      
        &nbsp;|&nbsp;
      
    
      
      
      
      JP
      
      
        &nbsp;&nbsp;&nbsp;
      
    
    <a href="https://github.com/jrl-umi3218/mc_rtc" target="blank_"><svg height="25" width="25" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a>
  </div>
</header>


    <div class="container-fluid">
      <div class="row">
      <div class="col col-lg-3">
        <div class="sticky-top sticky-toc">
          <div class="accordion" id="accordionTutorials">
            <div class="card">
              <div class="card-header" id="headingOtherTutorials">
                <button class="btn btn-link btn-block text-left" type="button" data-toggle="collapse" data-target="#collapseOtherTutorials" aria-expanded="true" aria-controls="collapseOtherTutorials">
                  Other tutorials
                </button>
              </div>
              <div id="collapseOtherTutorials" class="collapse" arial-labelledby="headingOtherTutorials" data-parent="#accordionTutorials">
                <div class="card-body">
                  <ul>
                    
                    <li>イントロダクション</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/introduction/installation-guide.html">インストールガイド</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/introduction/configuration.html">設定</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/introduction/running-a-controller.html">コントローラの実行</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/introduction/first-controller.html">mc_rtcを用いた最初のコントローラ</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/introduction/com-controller.html">重心の制御</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/introduction/ef-controller.html">エンドエフェクタの制御方法 (及びロードの方法)</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/introduction/multi-robot-controller.html">マルチロボットコントローラ</a></li>
                        
                      
                    </ul>
                    
                    <li>フレームワークの利用法</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/usage/mc_rtc_configuration.html"><code>mc_rtc::Configuration</code> 設定</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/usage/logging.html">データのロギング</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/usage/console-logging.html">画面への情報の表示</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/usage/gui.html">グラフィカルユーザインタフェース (GUI)</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/usage/live-plotting.html">コントローラからの情報のオンライン表示</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/usage/ros.html">ROS統合</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/usage/global-plugins.html">グローバルプラグインの利用</a></li>
                        
                      
                    </ul>
                    
                    <li>ツール</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/tools/mc_log_utils.html">ログの操作</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/tools/mc_log_ui.html">ログの可視化</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/tools/mc_log_visualization.html">ログの再生</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/tools/mc_surfaces_visualization.html">サーフェスの可視化</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/tools/mc_convex_visualization.html">凸形状の可視化</a></li>
                        
                      
                    </ul>
                    
                    <li>コントローラ実装の方法</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/fsm.html">FSM機能の利用</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/fsm-main-states.html">主なFSMの状態</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/fsm-example.html">FSMコントローラの例</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/derived-fsm.html">FSMコントローラの継承</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/datastore.html">データ共有機能"DataStore"</a></li>
                        
                      
                        
                        <li><strong>ステートオブザベーションパイプライン</strong></li>
                          
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/lipm-stabilizer.html">LIPMスタビライザの利用</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/speed-constraint.html">物体速度の拘束</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/moving-a-contact.html">接触の移動</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/contact-dof.html">接触の拘束自由度の変更</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/joint-select.html">タスクで特定の関節を利用する方法</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/dim-weight.html">作業空間の座標軸方向に異なる重み付けを行う方法</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/joint-stiffness.html">関節の重み付け</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/recipes/com-constraint.html">重心位置の存在可能な領域の拘束</a></li>
                        
                      
                    </ul>
                    
                    <li>サンプル</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/samples/list-of-samples.html">コントローラのリスト</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/samples/sample-admittance.html">アドミッタンスコントローラ</a></li>
                        
                      
                    </ul>
                    
                    <li>上級者向けのトピック</li>
                    <ul>
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/advanced/new-plugin.html">mc_rtc用の新しいプラグインの実装方法</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/advanced/new-interface.html">新しいmc_rtcインタフェースの実装方法</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/advanced/new-environment.html">mc_rtcにおける環境データの作成</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/advanced/new-robot.html">新たなロボットをmc_rtcでサポートする方法</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/advanced/support-mc-rtc-build-static.html">MC_RTC_BUILD_STATICをプログラムでサポートする方法</a></li>
                        
                      
                        
                        <li><a href="/mc_rtc/jp/tutorials/advanced/debug-lssol-output-6.html">Debugging LSSOL output 6</a></li>
                        
                      
                    </ul>
                    
                  </ul>
                </div>
              </div>
              
                <ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#観測器パイプラインを設定する">観測器パイプラインを設定する</a>
<ul>
<li class="toc-entry toc-h2"><a href="#デフォルト観測器">デフォルト観測器</a></li>
<li class="toc-entry toc-h2"><a href="#エンコーダー観測器">エンコーダー観測器</a></li>
<li class="toc-entry toc-h2"><a href="#ボディセンサー観測器">ボディセンサー観測器</a></li>
<li class="toc-entry toc-h2"><a href="#キネマティクス慣性観測器">キネマティクス慣性観測器</a></li>
<li class="toc-entry toc-h2"><a href="#推定されたロボットを可視化する">推定されたロボットを可視化する</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#コードを使用して観測器パイプラインを操作する">コードを使用して観測器パイプラインを操作する</a>
<ul>
<li class="toc-entry toc-h2"><a href="#観測器パイプラインの状態を照会する">観測器パイプラインの状態を照会する</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#独自の観測器を作成する">独自の観測器を作成する</a></li>
</ul>
              
            </div>
          </div>
        </div>
      </div>
      <div class="col-9" id="tutorial-content">
        
        <h1>ステートオブザベーションパイプライン</h1>
        

        
<p>一般に、制御されているロボットの実際の状態を知る必要があります。しかし、ロボットに組み込まれているセンサーから十分な情報を得られることはまれであるため、残念ながら、実際の状態を完全に把握できることはめったにありません。その代わり、各種センサー（関節エンコーダー、フォーストルクセンサー、IMU（慣性計測装置、カメラなど）の測定値と、コントローラーの制御対象（接触面など）に関する追加の情報から、コントローラーに関するシステムの状態を推測する必要があります。例えば、浮遊ベースロボットの場合、通常、浮遊ベースの状態（位置、向き、速度など）を完全に把握できるセンサーは搭載されていないため、入手できる情報を活用してその状態を推定する必要があります。これを実現する方法として、例えば、IMUやカルマンフィルターの情報を、ロボットのキネマティクスに関する既知の情報と組み合わせるというやり方があります。また、ビジュアルオドメトリを使用する方法や、モーションキャプチャーシステムからグラウンドトゥルース測定値を取得する方法のほか、これらを組み合わせる方法もあります。このようなプロセスは状態観測と呼ばれます。</p>

<p>ロボットに関してどのような状態を観測すべきか、その要件はコントローラーによって異なります。ヒューマノイドロボットの歩行コントローラーでは、ロボットの質量中心の状態を確実に推定することが重要であるため、ロボットのキネマティクス状態（浮遊ベースを含むボディ各部の位置と速度）を完全に把握する必要があります。一方、マニピュレーターアームでは、関節の位置と速度の情報しか必要としません。また、どのような方法で状態を取得するかも重要です（グラウンドトゥルース情報と推定値のどちらを使用するのか、どのようなセンサーやアルゴリズムを使用するのかなど）。</p>

<p>このフレームワークでは、1台または複数のロボットの状態観測を簡素化・一般化するため、<strong>状態観測パイプライン</strong>と呼ばれる仕組みを提供します。これは、状態観測をパイプラインとみなすというコンセプトに基づいています。各パイプラインは、シーケンシャルに実行される複数の観測器で構成されます。また、各観測器は、ロボットの状態を推定する役割を担います。そして、これらがすべて組み合わされ、パイプライン内のすべての観測器によってロボットの目標状態が完全に推定されます。複数のパイプラインを定義して実行することで、複数のロボットの状態の推定や、複数の推定手法の比較が行えます。観測器自体は、コントローラーやタスク、プラグインと同様に、シンプルなインターフェイスを用いてライブラリから読み込むことができるため、独自の観測器を簡単に定義できます。このフレームワークでは、現在、デフォルトで以下の観測器が用意されています。</p>
<ul>
  <li><strong>エンコーダー観測器</strong>: ロボットの関節の状態（位置と速度）を推定し、フォワードキネマティクスとフォワード速度の計算を行い、ボディの位置と速度を取得します。エンコーダーの位置、エンコーダーの速度（速度センサーや、位置の有限差分から取得）、ロボットの他の関節の値など、さまざまな入力を使用できます。</li>
  <li><strong>ボディセンサー観測器</strong>: ロボットのボディに取り付けられたセンサーから得られた測定値と、センサーと浮遊ベースとの間のキネマティクスに基づいて、ロボットの浮遊ベースの状態を設定します。これは通常、シミュレーターで得られたグラウンドトゥルース測定値を利用する場合や、浮遊ベースに関する情報を提供する外部のコンポーネント（モーションキャプチャー、ロボットのプラットフォームに組み込まれた推定器など）の結果を利用する場合に使用されます。</li>
  <li><strong>キネマティクス慣性観測器</strong>: <a href="/mc_rtc/jp/doxygen.html#structmc__rbdyn_1_1BodySensor" target="blank_"><code>mc_rbdyn::BodySensor</code></a>（IMUの向き）とキネマティクスアンカーフレームから、ロボットの浮遊ベースの姿勢（位置と向き）と速度（ローパスフィルター後の位置の有限差分）を推定します。</li>
</ul>

<p>このフレームワークでは、ロボットを表現するための2つのロボットインスタンスのセットが用意されています。</p>
<ul>
  <li><a href="/mc_rtc/jp/doxygen.html#structmc__control_1_1MCController#adc557ecb7d64eb2d8be551f7cf6678cd" target="blank_"><code>mc_control::MCController::robots()</code></a>は、ロボットの制御状態（目標状態）を表します。</li>
  <li><a href="/mc_rtc/jp/doxygen.html#structmc__control_1_1MCController#a1443aed08b26c319294465b1caa1e221" target="blank_"><code>mc_control::MCController::realRobots()</code></a>は、ロボットの実際の状態を表します。これらのロボットの状態をどのように推定するかは、観測器パイプラインで定義する必要があります。</li>
</ul>

<h1 id="観測器パイプラインを設定する">観測器パイプラインを設定する</h1>

<p>状態観測パイプラインの設定は、コントローラーの設定で行えます（各パイプラインの設定は、その前にあるパイプラインの設定よりも優先されます）。</p>

<ul>
  <li>全般的な設定: <code class="highlight language-bash" data-lang="bash"><span class="nv">$INSTALL_PREFIX</span>/etc/mc_rtc.yaml</code></li>
  <li>ユーザーによる設定: <code class="highlight language-bash" data-lang="bash"><span class="nv">$HOME</span>/.config/mc_rtc/mc_rtc.yaml</code></li>
  <li>コントローラー固有の設定: <code class="highlight language-bash" data-lang="bash"><span class="nv">$HOME</span>/.config/mc_rtc/mc_controllers/YourController.yaml</code></li>
  <li>コントローラーの有限オートマトンの設定: <code class="highlight language-bash" data-lang="bash">YouController.yaml</code> （推奨）</li>
</ul>

<p>設定形式については、<a href="../../json.html#Observers/ObserverPipelines">観測器のJSONスキーマ</a>に詳しく記述されています。</p>

<p>はじめに、エンコーダーの位置測定値と浮遊ベースのロールとピッチを測定するセンサーの出力に基づいて浮遊ベースロボットの状態を推定する簡単な例を見てみましょう。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">ObserverPipelines</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">MainPipeline</span>                     <span class="c1"># - Create a new pipeline</span>
  <span class="na">gui</span><span class="pi">:</span> <span class="no">true</span>                              <span class="c1">#   diplay the pipeline in the GUI (default = false)</span>
  <span class="na">log</span><span class="pi">:</span> <span class="no">true</span>                              <span class="c1">#   log observers (default)</span>

  <span class="na">observers</span><span class="pi">:</span>                             <span class="c1">#   declare which observers to use</span>
  <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">Encoder</span>                        <span class="c1"># - Use an EncoderObserver</span>
    <span class="na">config</span><span class="pi">:</span>                              <span class="c1">#</span>
      <span class="na">position</span><span class="pi">:</span> <span class="s">encoderValues</span>            <span class="c1">#    - Sets joint position from encoder sensor values (default)</span>
      <span class="na">velocity</span><span class="pi">:</span> <span class="s">encoderFiniteDifferences</span> <span class="c1">#    - Computes joint velocities by finite differences  (default)</span>
                                         <span class="c1"># We now have the estimation of each joint position and velocity and the corresponding</span>
                                         <span class="c1"># body positions and velocities, but we are still missing the floating base</span>

  <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">BodySensor</span>                     <span class="c1"># - Use a BodySensor observer</span>
    <span class="na">update</span><span class="pi">:</span> <span class="no">false</span>                        <span class="c1">#   Do not update the real robot state</span>
    <span class="na">gui</span><span class="pi">:</span> <span class="no">false</span>                           <span class="c1">#   Do not display in the gui</span>
    <span class="na">config</span><span class="pi">:</span>                              <span class="c1">#</span>
      <span class="na">bodySensor</span><span class="pi">:</span> <span class="s">FloatingBase</span>           <span class="c1">#   In simulation, the interface will fill this sensor with ground truth values</span>
                                         <span class="c1">#   The observer computes the position and velocity of the floating base</span>
                                         <span class="c1">#   by transforming the sensor measurements to the floating base frame</span>

  <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">KinematicInertial</span>              <span class="c1"># - Estimates the floating base state using the KinematicInertial observer</span>
    <span class="na">update</span><span class="pi">:</span> <span class="no">true</span>                         <span class="c1">#   update the real robot instance from its results</span>
    <span class="na">gui</span><span class="pi">:</span> <span class="no">true</span>                            <span class="c1">#   Displays the estimated velocity as an arrow (default)</span>
    <span class="na">config</span><span class="pi">:</span>
      <span class="na">imuBodySensor</span><span class="pi">:</span> <span class="s">Accelerometer</span>       <span class="c1"># This observer only uses roll and pitch rotation information from this sensor</span>
                                         <span class="c1"># along with a kinematic anchor point and the robot kinematics between the anchor</span>
                                         <span class="c1"># frame and the floating base frame. The anchor frame is expected to be provided</span>
                                         <span class="c1"># through a datastore callback (see below for details)</span>
</code></pre></div></div>

<p>使用できるオプションの詳細については、該当するJSONスキーマを参照してください。</p>
<ul>
  <li><a href="../../json.html#Observers/ObserverPipelines">ObserverPipelines</a>: 複数の状態観測パイプラインから成る配列</li>
  <li><a href="../../json.html#Observers/ObserverPipeline">ObserverPipeline</a>: 観測器を持つ観測パイプラインの定義</li>
  <li><a href="../../json.html#Observers/Encoder">EncoderObserver</a>: エンコーダー観測器のオプションr</li>
  <li><a href="../../json.html#Observers/BodySensor">BodySensorObserver</a>: ボディセンサー観測器のオプション</li>
  <li><a href="../../json.html#Observers/KinematicInertial">KinematicInertial</a>: キネマティクス慣性観測器のオプション</li>
</ul>

<p>上記パイプラインの作成時、以下のような簡単な説明がフレームワークに表示されます。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ObserverPipelines:
- ExamplePipeline: Encoder (position=encoderValues,velocity=encoderFiniteDifferences) -&gt; [BodySensor (sensor=FloatingBase,update=sensor)] -&gt;  KinematicInertial (sensor=Accelerometer,cutoff=0.010000)
</code></pre></div></div>

<p>この説明には、パイプラインの実行に関する情報と、観測器のシーケンスに関する情報が表示されます。<code class="language-plaintext highlighter-rouge">[..]</code>括弧に囲まれた観測器は、実行されますが<code class="language-plaintext highlighter-rouge">realRobots</code>インスタンスの状態には影響を与えませんパイプラインを実行すると、推定されたロボットの状態が<code class="language-plaintext highlighter-rouge">realRobots</code>インスタンスに格納され、この情報をコントローラーで使用することができます。</p>

<p>例えば、上記のパイプラインでは以下のことが可能です。</p>

<ul>
  <li>関節の位置<code class="language-plaintext highlighter-rouge">readRobot().mbc().q()</code>と速度<code class="language-plaintext highlighter-rouge">realRobot().mbc().alpha()</code>を取得する</li>
  <li>浮遊ベースの姿勢<code class="language-plaintext highlighter-rouge">realRobot().posW()</code>を取得する</li>
  <li>浮遊ベースの速度<code class="language-plaintext highlighter-rouge">realRobot().velW()</code>を取得する:</li>
  <li>ボディの姿勢を取得する: <code class="language-plaintext highlighter-rouge">realRobot().bodyPosW("bodyName");</code></li>
  <li>ボディの速度を取得する: <code class="language-plaintext highlighter-rouge">realRobot().bodyVelW("bodyName");</code></li>
  <li>質量中心の位置と速度<code class="language-plaintext highlighter-rouge">realRobot().com() / realRobot().comVelocity()</code>を取得する</li>
  <li>…</li>
</ul>

<p>このサンプルパイプラインの最終結果は以下のようになります<em>（左: Choreonoidによるシミュレーション、右: 制御状態（半透明の表示）と観測された状態（実体表示））</em></p>

<div class="embed-responsive embed-responsive-16by9">
  <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/ssoNkV940yc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</div>

<h2 id="デフォルト観測器">デフォルト観測器</h2>

<p>このセクションでは、このフレームワークで用意されているデフォルト観測器について簡単に説明します。詳細については、各観測器のAPIドキュメントとJSONスキーマを参照してください。</p>

<h2 id="エンコーダー観測器">エンコーダー観測器</h2>

<ul>
  <li>API: <a href="/mc_rtc/jp/doxygen.html#structmc__observers_1_1EncoderObserver" target="blank_"><code>mc_observers::EncoderObserver</code></a></li>
  <li><a href="../../json.html#Observers/Encoder">JSONスキーマ</a></li>
</ul>

<p>エンコーダー観測器を使用すると、駆動されているすべての関節の位置と速度を取得できます。</p>

<ul>
  <li>関節の値は、センサーの値<a href="/mc_rtc/jp/doxygen.html#structmc__rbdyn_1_1Robot#a1191c63affb21cb0e15698a48ee83355" target="blank_"><code>mc_rbdyn::Robot::encoderValues()</code></a>として取得するか、ロボットの他の関節状態<a href="/mc_rtc/jp/doxygen.html#structmc__rbdyn_1_1Robot#a485eb8aa4ceb0a0a5010844d16e47f95" target="blank_"><code>mc_rbdyn::Robot::q()</code></a>を使用して取得できます。</li>
  <li>関節の速度は、関節速度センサーの値<a href="/mc_rtc/jp/doxygen.html#structmc__rbdyn_1_1Robot#a1191c63affb21cb0e15698a48ee83355" target="blank_"><code>mc_rbdyn::Robot::encoderValues()</code></a>として取得するか、（推定された）位置の有限差分による推定値として取得するか、ロボットの他の関節速度<a href="/mc_rtc/jp/doxygen.html#structmc__rbdyn_1_1Robot#a5773f91f2a9d0eb5cb4b6a0943551a1b" target="blank_"><code>mc_rbdyn::Robot::alpha()</code></a>を使用して取得できます。</li>
  <li>この観測器では、フォワードキネマティクス<a href="/mc_rtc/jp/doxygen.html#structmc__rbdyn_1_1Robot#ae46b693d4431e61db9f1d4a05f66dd5e" target="blank_"><code>mc_rbdyn::Robot::forwardKinematics()</code></a>とフォワード速度<a href="/mc_rtc/jp/doxygen.html#structmc__rbdyn_1_1Robot#afd93342dd86da6803288346a3798d374" target="blank_"><code>mc_rbdyn::Robot::forwardVelocity()</code></a>が計算され、該当するボディの位置と速度が更新されます（この位置と速度は、後続の観測器で使用されます）。</li>
</ul>

<h2 id="ボディセンサー観測器">ボディセンサー観測器</h2>

<ul>
  <li>API: <a href="/mc_rtc/jp/doxygen.html#structmc__observers_1_1BodySensorObserver" target="blank_"><code>mc_observers::BodySensorObserver</code></a></li>
  <li><a href="../../json.html#Observers/BodySensor">JSONスキーマ</a></li>
</ul>

<p>ボディセンサー観測器では、<a href="/mc_rtc/jp/doxygen.html#structmc__rbdyn_1_1BodySensor" target="blank_"><code>mc_rbdyn::BodySensor</code></a>によって与えられた情報に基づいて、浮遊ベースの状態を推定できます。ボディセンサーは、ロボットのボディに取り付けられたセンサーで、ボディの状態を測定した結果が出力されます。<code class="language-plaintext highlighter-rouge">BodySensor</code>には以下の情報が格納されます。</p>

<ul>
  <li>センサーが取り付けられているボディとセンサーとの間の運動学的変換（必要に応じて）</li>
  <li>ボディの位置と姿勢</li>
  <li>直線速度と角速度</li>
  <li>直線加速度と角加速度</li>
</ul>

<p>ロボットに取り付けられているセンサーの測定値のみを使用することができ、他の測定値はデフォルトで0になります。ボディセンサー観測器は、少なくとも、位置、姿勢、線形速度、角速度の測定値を必要とします。さらに、センサーが浮遊ベースに直接取り付けられていない場合は、センサーと浮遊ベースとの間の運動学的変換が必要となります（これは<code class="language-plaintext highlighter-rouge">EncoderObserver</code>などを使用して取得できます）。</p>

<p>この観測器は、一般に、<code class="language-plaintext highlighter-rouge">FloatingBase</code>ボディセンサーで得られた浮遊ベースの状態に関するグラウンドトゥルース測定値をシミュレーターインターフェイスから出力するのに使用されます。</p>

<h2 id="キネマティクス慣性観測器">キネマティクス慣性観測器</h2>

<ul>
  <li>API: <a href="/mc_rtc/jp/doxygen.html#structmc__observers_1_1KinematicInertialObserver" target="blank_"><code>mc_observers::KinematicInertialObserver</code></a></li>
  <li><a href="../../json.html#Observers/KinematicInertial">JSONスキーマ</a></li>
  <li><a href="https://scaron.info/teaching/floating-base-estimation.html">この手法に関するStéphane Caronによる詳しい説明</a></li>
</ul>

<p>浮遊ベースロボットでは、センサーを使用して浮遊ベースの状態を完全に把握できることはめったにありません。キネマティクス慣性観測器を使用すると、IMUセンサーから得られた向きの推定値に基づいて、浮遊ベースの位置、向き、直線速度、角速度を簡単に推定できます。ここで実装されている手法に関する詳しい説明については、<a href="https://scaron.info/teaching/floating-base-estimation.html">Stéphane CaronのWebサイト</a>を参照してください。なお、この観測器は、階段を上るロボット（<a href="https://www.youtube.com/embed/vFCFKAunsYM">動画</a>）で見られるように、<a href="https://github.com/jrl-umi3218/lipm_walking_controller">LIPM（線形倒立振子モード）歩行コントローラー</a>による歩行制御で実際に広く使用されています。</p>

<p>この手法では、重力を基準としたロール回転角とピッチ回転角をセンサーから取得する必要があります。重力ベクトル周りの回転（ヨー）は、IMUと同様、一般にセンサーでは観測できないため、制御目標ロボットの目標回転角を代用することで、センサーフレームを完全に推定することができます。</p>

<p>位置の推定では、接触面の位置が既知であると仮定して、観測された向きと最もよく一致する位置のみが推定されます。これは、仮定された接触面間のアンカーポイントを与えることで実現されます。静止している場合は、すべての接触面の間にある中心点をアンカーフレームとして選択するのが最適です。歩行などの動作を実行する場合は、接触面の遷移が発生したときにぎくしゃくした動きにならないように、接触面の間でアンカーフレームをスムーズに補間する必要があります。このフレームは、データストアのコールバック関数<a href="/mc_rtc/jp/tutorials/recipes/datastore.html">datastore</a>によって与えられます。</p>

<p>例えば、先のセクションで説明したパイプラインの場合、アンカーフレームは、想定される2つの足の接触面間のフレーム中心として与えられます。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">leftFootRatio</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">ctl</span><span class="p">.</span><span class="n">datastore</span><span class="p">().</span><span class="n">make_call</span><span class="p">(</span><span class="s">"KinematicAnchorFrame::"</span> <span class="o">+</span> <span class="n">robot</span><span class="p">().</span><span class="n">name</span><span class="p">(),</span>
                          <span class="p">[</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leftFootRatio</span><span class="p">](</span><span class="k">const</span> <span class="n">mc_rbdyn</span><span class="o">::</span><span class="n">Robot</span> <span class="o">&amp;</span> <span class="n">robot</span><span class="p">)</span>
                          <span class="p">{</span>
                            <span class="k">return</span> <span class="n">sva</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">robot</span><span class="p">().</span><span class="n">surfacePose</span><span class="p">(</span><span class="s">"LeftFoot"</span><span class="p">),</span>
                                                    <span class="n">robot</span><span class="p">().</span><span class="n">surfacePose</span><span class="p">(</span><span class="s">"RightFoot"</span><span class="p">),</span>
                                                    <span class="n">leftFootRatio</span><span class="p">)</span>
                          <span class="p">});</span>
</code></pre></div></div>

<p>なお、この関数は2回呼び出されます。制御目標ロボットインスタンス用に1回、実ロボットインスタンス用に1回呼び出されます（アンカーフレームとセンサーフレームとの間の相対的な姿勢のみが観測器で使用されます）。</p>

<p>右足は地面につけたまま左足をスイングさせて歩行を開始したい場合、まず、接触面の遷移が発生するまで右足の接触面に向けてアンカーフレームをスムーズに動かしてから、ステップ完了時に左足が新たな場所に着地するように、2つの目標接触面の間にアンカーフレームをスムーズに動かす必要があります。アンカーフレームの動きがスムーズでない場合、推定された浮遊ベースの位置が途中でジャンプする可能性があります（向きは影響を受けません）。</p>

<p>その後、この観測器では、推定された位置と向きの有限差分に基づいて、浮遊ベースの直線速度と角速度が計算されます。さらに、この速度がローパスフィルターによって処理されます。</p>

<p>この観測器の使用例については、<a href="/mc_rtc/jp/tutorials/samples/sample-admittance.html">アドミッタンス制御の例を使用したコントローラーのチュートリアル</a>、<a href="/mc_rtc/jp/doxygen.html#structmc__control_1_1fsm_1_1StabilizerStandingState" target="blank_"><code>mc_control::fsm::StabilizerStandingState</code></a>を参照してください。また、より複雑な使用例については、<a href="https://github.com/jrl-umi3218/lipm_walking_controller">LIPM歩行コントローラー</a>を参照してください。</p>

<h2 id="推定されたロボットを可視化する">推定されたロボットを可視化する</h2>

<p>推定されたロボットをRVizで可視化できます。デフォルトでは、メインのロボットインスタンスは以下のプロパティを持つ<code class="language-plaintext highlighter-rouge">RealRobot</code>要素として表示されます。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">Robot Description path</span><span class="pi">:</span> <span class="s">/real/robot_description</span>
<span class="na">TF Prefix</span><span class="pi">:</span> <span class="s">/real</span>
</code></pre></div></div>

<p>追加のロボットをパブリッシュするには以下のようにします。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># robots published as env_1, env_2, etc</span>
<span class="na">Robot Description path</span><span class="pi">:</span> <span class="s">/real/env_*/robot_description</span>
<span class="na">TF Prefix</span><span class="pi">:</span> <span class="s">/real/env_*</span>
</code></pre></div></div>

<h1 id="コードを使用して観測器パイプラインを操作する">コードを使用して観測器パイプラインを操作する</h1>

<p>コードを使用して観測器パイプラインを操作すると便利な場合があります。例えば以下の場合に役に立ちます。</p>
<ul>
  <li>特定の観測パイプラインが動作しているかどうかをチェックする</li>
  <li>特定の観測器が存在するかどうかをチェックする</li>
  <li>特定の観測器の状態をコードを使用して調べる</li>
  <li>観測器が存在する場合にのみアクションを実行する</li>
  <li>…</li>
</ul>

<h2 id="観測器パイプラインの状態を照会する">観測器パイプラインの状態を照会する</h2>

<p>以下に、観測器パイプラインの状態を照会し、その状態に応じてアクションを実行する方法を示す簡単なコードスニペットを示します。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">checkObserverPipeline</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">observerPipelineName</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">hasObserverPipeline</span><span class="p">(</span><span class="n">observerPipelineName</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">mc_rtc</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">error</span><span class="p">(</span><span class="s">"This controller does not have a pipeline named {}"</span><span class="p">,</span> <span class="n">observerPipelineName</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">observerp</span> <span class="o">=</span> <span class="n">observerPipeline</span><span class="p">(</span><span class="n">observerPipelineName</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">observerp</span><span class="p">.</span><span class="n">success</span><span class="p">())</span> <span class="c1">// Check if the pipeline failed</span>
  <span class="p">{</span>
    <span class="n">mc_rtc</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">error</span><span class="p">(</span><span class="s">"Required pipeline </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s"> for real robot observation failed to run!"</span><span class="p">,</span> <span class="n">observerPipelineName</span><span class="p">);</span>
    <span class="c1">// Check which observer failed</span>
    <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">observer</span> <span class="o">:</span> <span class="n">observerp</span><span class="p">.</span><span class="n">observers</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">observer</span><span class="p">.</span><span class="n">success</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="c1">// Display failure error</span>
        <span class="n">mc_rtc</span><span class="o">::</span><span class="n">log</span><span class="o">::</span><span class="n">error</span><span class="p">(</span><span class="s">"Observer </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s"> failed with error </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span> <span class="n">observer</span><span class="p">.</span><span class="n">observer</span><span class="p">().</span><span class="n">name</span><span class="p">(),</span> <span class="n">observer</span><span class="p">.</span><span class="n">observer</span><span class="p">().</span><span class="n">error</span><span class="p">());</span>
        <span class="k">if</span><span class="p">(</span><span class="n">observer</span><span class="p">.</span><span class="n">observer</span><span class="p">().</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="s">"MyObserver"</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="c1">// do something specific if this observer failed</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">checkObserverPipeline("RequiredObserverPipeline");</code>を呼び出すと、このパイプラインが存在するかどうかの情報と、問題が発生している観測器とその原因が通知され、パイプライン内に観測器<code class="language-plaintext highlighter-rouge">MyObserver</code>が存在する場合はその観測器に固有のアクションが実行されます。その他の利用可能な機能については、<a href="/mc_rtc/jp/doxygen.html#structmc__observers_1_1ObserverPipeline" target="blank_"><code>mc_observers::ObserverPipeline</code></a>のドキュメントを参照してください。</p>

<h1 id="独自の観測器を作成する">独自の観測器を作成する</h1>

<p>このフレームワークは、ライブラリから観測器を読み込みます。これを正しく機能させるには、観測器を<a href="/mc_rtc/jp/doxygen.html#structmc__observers_1_1Observer" target="blank_"><code>mc_observers::Observer</code></a>から継承し、以下のを実装する必要があります。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// YourObserver.h</span>
<span class="kt">void</span> <span class="n">configure</span><span class="p">(</span><span class="k">const</span> <span class="n">mc_control</span><span class="o">::</span><span class="n">MCController</span> <span class="o">&amp;</span> <span class="cm">/*ctl*/</span><span class="p">,</span> <span class="k">const</span> <span class="n">mc_rtc</span><span class="o">::</span><span class="n">Configuration</span> <span class="o">&amp;</span> <span class="cm">/*config*/</span><span class="p">)</span> <span class="k">override</span>
<span class="kt">void</span> <span class="n">reset</span> <span class="p">(</span><span class="k">const</span> <span class="n">mc_control</span><span class="o">::</span><span class="n">MCController</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">)</span> <span class="k">override</span>
<span class="kt">bool</span> <span class="n">run</span> <span class="p">(</span><span class="k">const</span> <span class="n">mc_control</span><span class="o">::</span><span class="n">MCController</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">)</span> <span class="k">override</span>
<span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">mc_control</span><span class="o">::</span><span class="n">MCController</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">)</span> <span class="k">override</span>
</code></pre></div></div>

<p>さらに、<code class="language-plaintext highlighter-rouge">mc_rtc</code>が観測器を見つけられるように、<code class="language-plaintext highlighter-rouge">mc_rtc</code>の観測器ローダーにライブラリを検索させるための読み込みシンボルを定義する必要があります。これを行うには、<code class="language-plaintext highlighter-rouge">mc_observers/ObserverMacros.h</code>で定義された以下のマクロを使用します。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// YourObserver.cpp</span>
<span class="cp">#include &lt;mc_observers/ObserverMacros.h&gt;
</span><span class="c1">// Observer implementation (configure, reset, run and update functions)</span>
<span class="n">EXPORT_OBSERVER_MODULE</span><span class="p">(</span><span class="s">"YourObserver"</span><span class="p">,</span> <span class="n">your_namespace</span><span class="o">::</span><span class="n">YourObserverClassName</span><span class="p">)</span>
</code></pre></div></div>

<p>独自の観測器をコンパイルするには、提供されたマクロを使用します。このマクロによって、独自に作成した観測器が<code class="language-plaintext highlighter-rouge">mc_observers</code>とリンクされ、デフォルトの観測器パスにその観測器がインストールされます。</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">add_observer</span><span class="p">(</span>YourObserverName YourObserver.cpp YourObserver.h<span class="p">)</span>
</code></pre></div></div>

<p>注: フレームワークで提供されたデフォルトの観測器のいずれかから継承したい場合は、その観測器をリンクする必要があります。例えば、<a href="/mc_rtc/jp/doxygen.html#structmc__observers_1_1BodySensorObserver" target="blank_"><code>mc_observers::BodySensorObserver</code></a>から継承したい場合、これに対応する<code class="language-plaintext highlighter-rouge">mc_observers::BodySensorObserver</code>ターゲットをリンクする必要があります。</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">target_link_libraries</span><span class="p">(</span>YourObserverName PUBLIC mc_observers::BodySensorObserver<span class="p">)</span>
</code></pre></div></div>

<p>実際の例については、こちらの<a href="https://github.com/arntanguy/mc_observer_example">サンプルプロジェクト</a>を参照してください。</p>



        <hr/>
        
        <div class="text-right">
          <a href="/mc_rtc/jp/tutorials/recipes/lipm-stabilizer.html">次のチュートリアル: LIPMスタビライザの利用</a>
        </div>
        
      </div>
      </div>
    </div>

    <div class="container-fluid">
  <footer>
    <hr>
    <div class="row">
      <div class="col-8 offset-lg-2 col-lg-6">
        Copyright &copy; CNRS-AIST JRL, CNRS LIRMM 2015-2020
      </div>
      <div class="col-4 col-lg-2 text-right">
        <a href="/mc_rtc/jp/credits.html">クレジット</a>
      </div>
    </div>
  </footer>
</div>

  </body>

  <script type="text/javascript">
$(document).ready(function()
{
  new ClipboardJS('.copy-button');
});
</script>


</html>
