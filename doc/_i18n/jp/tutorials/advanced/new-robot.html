<p>mc_rtcには、以下の3つの方法でロボットを組み込むことができます。</p>

<ol>
  <li><code>env</code>/<code>object</code>ローダーを使用する</li>
  <li>JSON/YAMLファイルと<code>json</code>ローダーを使用する</li>
  <li>C++で<code>RobotModule</code>の実装を記述する</li>
</ol>

<h2>ローダーの概要</h2>

<ul>
  <li>
    <strong><code>env</code>/<code>object</code>ローダー:</strong><br>
    センサーなどが付いていない、シンプルなロボットや静的オブジェクト・環境向け。<br>
    <strong>URDFに定義されたメッシュから自動的に凸包を生成することが可能</strong>です。
  </li>
  <li>
    <strong><code>json</code>ローダー:</strong><br>
    関節、センサー、グリッパーなどの構造化されたメタデータを追加できます。<br>
    自動凸包生成をサポートします。
  </li>
  <li>
    <strong>C++ <code>RobotModule</code>:</strong><br>
    最も柔軟で、構成やロジックを細かく制御可能。<br>
    凸包の自動生成およびキャッシュ機能を完全にサポートします。
  </li>
</ul>

{% include h2.html title="<code>env</code>/<code>object</code>ローダーを使用する" %}

<p>ロボットを読み込むには、以下のように呼び出しを行います。</p>

{% include show_sources.html sources=page.env_object_example copy=false id="env_object_example" %}

{% include h3.html title="ロボット記述パッケージを整理する" %}

<p>ロボット記述フォルダーが<code>LOCATION</code>にあり、ロボットの名前が<code>NAME</code>であるとき、mc_rtcは、データが以下のように整理されているはずです。</p>

<ul>
  <li>URDFが <code>$LOCATION/urdf/$NAME.urdf</code> にある</li>
  <li>RSDFファイルが <code>$LOCATION/rsdf/$NAME/</code> フォルダーにある（任意）</li>
  <li>凸包ファイルが <code>$LOCATION/convex/$NAME/</code> フォルダーにある（任意）</li>
</ul>

<p>たとえば、ボディ名が <code>BODY</code> の場合、対応する凸包ファイル名は:</p>
<code>BODY-ch.txt</code>

<h4>補足事項:</h4>
<ul>
  <li>RSDFフォルダーは空であってもよい、または存在しなくてもよい</li>
  <li>すべてのボディに凸包ファイルを用意する必要はない</li>
  <li>対応するボディが見つからない凸包ファイルは無視される</li>
  <li><strong>凸包ファイルが存在しない場合でも、自動生成がすべてのローダータイプで可能</strong>です</li>
</ul>

<h3>凸包の自動生成について</h3>

<p>
  mc_rtcでは、<strong>すべてのローダー方式（env、JSON、C++）において</strong>、URDFまたはSRDF内に定義されたメッシュから
  <strong>衝突用凸包を自動生成</strong>できます。
</p>

<h4>動作概要</h4>
<ul>
  <li>ロボットのURDF/SRDFに含まれるメッシュをサンプリングして凸包を構築</li>
  <li>生成された凸包は<strong>ローカルキャッシュ</strong>され、再利用されます</li>
  <li>キャッシュが存在しない場合や、明示的に再生成する場合は再計算されます</li>
</ul>

<h4>キャッシュ保存場所</h4>

<p>生成された凸包は、ユーザー環境ごとのローカル共有ディレクトリに保存されます。<br>
このパスは <code>local_share_directory()</code> 関数により構築され、プラットフォームによって異なります。</p>

<ul>
  <li><strong>Windows:</strong> <code>%APPDATA%/mc_rtc/&lt;robot_name&gt;/</code></li>
  <li><strong>Linux/macOS:</strong> <code>$HOME/.local/share/mc_rtc/&lt;robot_name&gt;/</code></li>
</ul>

<h4>ファイル命名規則</h4>

<ul>
  <li>ボディにメッシュが1つだけある場合: <code>BODY-ch.txt</code></li>
  <li>複数メッシュがある場合: <code>BODY_0-ch.txt</code>, <code>BODY_1-ch.txt</code> のように番号付きで生成</li>
</ul>

{% include h2.html title="<code>json</code>ローダーを使用する" %}

<p>ロボットを読み込むには、以下のように呼び出しを行います。</p>

{% include show_sources.html sources=page.json_example copy=false id="json_example" %}

{% include h3.html title="JSON/YAMLファイルで必要とされるデータ" %}

<p><code>json</code>モジュールは、<code>env</code>モジュールと同じようにデータが整理されていることを想定しています。ただし、ユーザーがデータを与えることで、それらの要件のいくつかは無視できます。また、力覚センサー、ボディセンサー、最小限の自己衝突メッシュセットなどのデータをモジュールに与えることができます。</p>

<p><code>json</code>ローダーで必要とされるデータの詳細については、<a href="{{site.baseurl}}/json.html#mc_rbdyn/RobotModule" target="blank_">JSON/YAMLのドキュメント</a>を参照してください。</p>

{% include h2.html title="独自の<code>RobotModule</code>を実装する" %}

<p>この方法では、ロボットの<code>RobotModule</code>を定義するためのC++クラスを記述し、ユーザーが指定したいデータメンバーをそのクラスのデータメンバーに置き換えます。最小限のサンプルを以下に示します。</p>

{% include show_sources.html sources=page.robot_module_example copy=false id="robot_module_example" %}

<p>指定可能なメンバーについては、{% doxygen mc_rbdyn::RobotModule %}のドキュメントを参照してください。</p>

{% include h2.html title="さあ始めましょう" %}

<p><a href="https://github.com/mc-rtc/new-robot-module/">mc-rtc/new-robot-module</a>テンプレートプロジェクトを使用すると、すぐに始められます。このテンプレートには、C++またはYAMLの<code>RobotModule</code>用の必要最小限の構造が記述されています。 </p>
