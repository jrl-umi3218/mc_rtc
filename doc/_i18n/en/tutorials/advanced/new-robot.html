<p>There are three ways to integrate your robot into <code>mc_rtc</code>:</p>

<ol>
  <li>Using the <code>env</code>/<code>object</code> loader</li>
  <li>Using a JSON/YAML file and the <code>json</code> loader</li>
  <li>Writing a C++ <code>RobotModule</code> implementation</li>
</ol>

<h2>Loader Overview</h2>

<ul>
  <li>
    <strong><code>env</code>/<code>object</code> loader:</strong>
    Best suited for simple robots or static objects and environments.
    Convex hulls <strong>can still be generated automatically</strong> for collision meshes.
  </li>
  <li>
    <strong><code>json</code> loader:</strong>
    Adds structured metadata to the robot (e.g., joints, sensors, grippers).
    Supports <strong>automatic convex hull generation</strong> from URDF meshes.
  </li>
  <li>
    <strong>C++ <code>RobotModule</code>:</strong>
    Provides full control over loading, configuration, and logic.
    Fully supports <strong>automatic convex generation and caching</strong>.
  </li>
</ul>

<h2>Using the <code>env</code>/<code>object</code> Loader</h2>

<p>To load your robot using this loader, use the following invocation:</p>

{% include show_sources.html sources=page.env_object_example copy=false id="env_object_example" %}

<h3>Organization of Your Robot Description Package</h3>

<p>Given a robot description directory located at <code>LOCATION</code> and a robot named <code>NAME</code>, mc_rtc expects your data to be structured as follows:</p>

<ul>
  <li>URDF file: <code>$LOCATION/urdf/$NAME.urdf</code></li>
  <li>RSDF files (optional): <code>$LOCATION/rsdf/$NAME/</code></li>
  <li>Convex hull files (optional): <code>$LOCATION/convex/$NAME/</code></li>
</ul>

<p>For a body named <code>BODY</code>, the corresponding convex file should be named:</p>
<code>BODY-ch.txt</code>

<h4>Additional Notes:</h4>
<ul>
  <li>The RSDF directory can be empty or not exist at all.</li>
  <li>Not every body requires a convex file.</li>
  <li>Convex files that can't be matched to any body are ignored.</li>
  <li>If convexes are missing, they can be generated automatically for any loader type.</li>
</ul>

<h3>Automatic Convex Hull Generation</h3>

<p>Regardless of how your robot is loaded (C++, JSON, or env/object), <strong>mc_rtc can generate convex hulls automatically</strong> from mesh-type collision geometries in the URDF or SRDF.</p>

<h4>How It Works</h4>

<ul>
  <li>Meshes in the robot description are sampled to build convex approximations.</li>
  <li>These convex hulls are <strong>cached</strong> to avoid regeneration unless explicitly requested.</li>
  <li>Convex generation can be triggered automatically or manually depending on loader and setup.</li>
</ul>

<h4>Convex Cache Storage</h4>

<p>Generated convexes are stored in a user-specific local share directory. The base directory is platform-specific :</p>

<ul>
  <li><strong>Windows:</strong> <code>%APPDATA%/mc_rtc/&lt;robot_name&gt;/</code></li>
  <li><strong>Linux/macOS:</strong> <code>$HOME/.local/share/mc_rtc/&lt;robot_name&gt;/</code></li>
</ul>

<h4>Convex File Naming</h4>

<ul>
  <li>For bodies with a single mesh: <code>BODY-ch.txt</code></li>
  <li>For bodies with multiple meshes: <code>BODY_0-ch.txt</code>, <code>BODY_1-ch.txt</code>, etc.</li>
</ul>

{% include h2.html title="Using the <code>json</code> loader" %}

<p>When loading the robot, use the following invokation:</p>

{% include show_sources.html sources=page.json_example copy=false id="json_example" %}

{% include h3.html title="Data expected in the JSON/YAML file" %}

<p>The <code>json</code> module expects your data to be organized as the <code>env</code> module. However, you can override some expectations by providing the data yourself. Furthermore, you can provide data for force sensors, body sensors, minimal self-collisions set and so-on.</p>

<p>See the <a href="{{site.baseurl}}/json.html#mc_rbdyn/RobotModule" target="blank_">JSON/YAML documentation</a> for details on the data expected by the <code>json</code> loader.</p>

{% include h2.html title="Implementing your own <code>RobotModule</code>" %}

<p>In this approach, we will write a C++ class to provide a <code>RobotModule</code> for our robot and overwrite the data members that we wish to provide. As in the minimal example below:</p>

{% include show_sources.html sources=page.robot_module_example copy=false id="robot_module_example" %}

<p>See {% doxygen mc_rbdyn::RobotModule %} documentation for all members that can be provided.</p>

{% include h2.html title="Get started" %}

<p>Use the <a href="https://github.com/mc-rtc/new-robot-module/">mc-rtc/new-robot-module</a> template project to get started quickly. This template provides the barebone structure for a C++ <code>RobotModule</code> or a YAML <code>RobotModule</code></p>
