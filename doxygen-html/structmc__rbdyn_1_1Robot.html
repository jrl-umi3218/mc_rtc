<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>mc_rbdyn::Robot Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script>
<script src="MathJax/MathJax.js"></script>
<!-- To use the latest MathJax version instead, you can use: -->
<!--<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structmc__rbdyn_1_1Robot.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structmc__rbdyn_1_1Robot-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mc_rbdyn::Robot Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mc__rbdyn_2Robot_8h_source.html">mc_rbdyn/Robot.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot_1_1NewRobotToken.html">NewRobotToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeaf56b7bf79a4e2be37e3c8615d156ad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a> = std::pair&lt; std::string, <a class="el" href="namespacemc__rbdyn.html#ac3517607389b845ee6ffdee65cbc8a63">S_ObjectPtr</a> &gt;</td></tr>
<tr class="separator:aeaf56b7bf79a4e2be37e3c8615d156ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a132b55076c2d2b1045d0d71ff08b5065"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a132b55076c2d2b1045d0d71ff08b5065">Robot</a> (<a class="el" href="structmc__rbdyn_1_1Robot.html">Robot</a> &amp;&amp;)</td></tr>
<tr class="separator:a132b55076c2d2b1045d0d71ff08b5065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410eefe8c059340207a45a1d79be6221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmc__rbdyn_1_1Robot.html">Robot</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a410eefe8c059340207a45a1d79be6221">operator=</a> (<a class="el" href="structmc__rbdyn_1_1Robot.html">Robot</a> &amp;&amp;)</td></tr>
<tr class="separator:a410eefe8c059340207a45a1d79be6221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84da94b87e530bead44b2c852755601d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a84da94b87e530bead44b2c852755601d">~Robot</a> ()</td></tr>
<tr class="separator:a84da94b87e530bead44b2c852755601d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0c4c44861063b684d43d4ad78a995e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a> () const</td></tr>
<tr class="separator:a9f0c4c44861063b684d43d4ad78a995e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e734d771ca6cf96801de8765cee637d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1RobotModule.html">RobotModule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a3e734d771ca6cf96801de8765cee637d">module</a> () const</td></tr>
<tr class="separator:a3e734d771ca6cf96801de8765cee637d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e27a5f9fb46fdf980254c4ac5761f94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a8e27a5f9fb46fdf980254c4ac5761f94">jointHasJointSensor</a> (const std::string &amp;joint) const noexcept</td></tr>
<tr class="separator:a8e27a5f9fb46fdf980254c4ac5761f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6354b734b171f226d1fadc9a12aeef31"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1JointSensor.html">JointSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a6354b734b171f226d1fadc9a12aeef31">jointJointSensor</a> (const std::string &amp;joint) const</td></tr>
<tr class="separator:a6354b734b171f226d1fadc9a12aeef31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bea736214045982c99b3c70e660ae1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structmc__rbdyn_1_1JointSensor.html">JointSensor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a06bea736214045982c99b3c70e660ae1">jointSensors</a> () const noexcept</td></tr>
<tr class="separator:a06bea736214045982c99b3c70e660ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb78a38ec8b2037519f030140a95976"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aafb78a38ec8b2037519f030140a95976">hasJoint</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:aafb78a38ec8b2037519f030140a95976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8353aa6a66630a85c9249298ed960c6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a8353aa6a66630a85c9249298ed960c6a">hasBody</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a8353aa6a66630a85c9249298ed960c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dce036249f32a7cd0f0257956be990e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a4dce036249f32a7cd0f0257956be990e">hasFrame</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const noexcept</td></tr>
<tr class="separator:a4dce036249f32a7cd0f0257956be990e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68ae766d6de9d5f8740001ac10a62db"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1RobotFrame.html">RobotFrame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac68ae766d6de9d5f8740001ac10a62db">frame</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:ac68ae766d6de9d5f8740001ac10a62db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d92cb0d6c4ba8c42ee9a35a7d56bab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmc__rbdyn_1_1RobotFrame.html">RobotFrame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ad3d92cb0d6c4ba8c42ee9a35a7d56bab">frame</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="separator:ad3d92cb0d6c4ba8c42ee9a35a7d56bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6c471776005048105c48791df73ea5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a8c6c471776005048105c48791df73ea5">frames</a> () const</td></tr>
<tr class="separator:a8c6c471776005048105c48791df73ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4db0746e4af259c63c288695f72beac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmc__rbdyn_1_1RobotFrame.html">RobotFrame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ad4db0746e4af259c63c288695f72beac">makeFrame</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>, <a class="el" href="structmc__rbdyn_1_1RobotFrame.html">RobotFrame</a> &amp;parent, sva::PTransformd X_p_f, bool baked=false)</td></tr>
<tr class="separator:ad4db0746e4af259c63c288695f72beac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59b1b6223978e23cb2ea636ddee0ceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemc__rbdyn.html#a5a52a2394099019321a0411da30ea5f4">RobotFramePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aa59b1b6223978e23cb2ea636ddee0ceb">makeTemporaryFrame</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>, const <a class="el" href="structmc__rbdyn_1_1RobotFrame.html">RobotFrame</a> &amp;parent, sva::PTransformd X_p_f, bool baked=false) const</td></tr>
<tr class="separator:aa59b1b6223978e23cb2ea636ddee0ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70f3348aeda8560aa5740227eba3e1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ab70f3348aeda8560aa5740227eba3e1f">makeFrames</a> (std::vector&lt; <a class="el" href="structmc__rbdyn_1_1RobotModule_1_1FrameDescription.html">mc_rbdyn::RobotModule::FrameDescription</a> &gt; <a class="el" href="structmc__rbdyn_1_1Robot.html#a8c6c471776005048105c48791df73ea5">frames</a>)</td></tr>
<tr class="separator:ab70f3348aeda8560aa5740227eba3e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47874ad9d5abdcd85701b02e2c85cefb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a47874ad9d5abdcd85701b02e2c85cefb">hasSurface</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#aa4b724e51881215dd4293f9578656755">surface</a>) const</td></tr>
<tr class="separator:a47874ad9d5abdcd85701b02e2c85cefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b724e51881215dd4293f9578656755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmc__rbdyn_1_1Surface.html">mc_rbdyn::Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aa4b724e51881215dd4293f9578656755">surface</a> (const std::string &amp;sName)</td></tr>
<tr class="separator:aa4b724e51881215dd4293f9578656755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032e4252cb8c2c1d2ab82bd353b1cfb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1Surface.html">mc_rbdyn::Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a032e4252cb8c2c1d2ab82bd353b1cfb2">surface</a> (const std::string &amp;sName) const</td></tr>
<tr class="separator:a032e4252cb8c2c1d2ab82bd353b1cfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c21632fb2dc076e87cc4f4b6f840ddb"><td class="memItemLeft" align="right" valign="top">sva::PTransformd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a0c21632fb2dc076e87cc4f4b6f840ddb">surfacePose</a> (const std::string &amp;sName) const</td></tr>
<tr class="separator:a0c21632fb2dc076e87cc4f4b6f840ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eac94be22b1481eaae48d110d97c49e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmc__rbdyn_1_1Surface.html">mc_rbdyn::Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a9eac94be22b1481eaae48d110d97c49e">copySurface</a> (const std::string &amp;sName, const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="separator:a9eac94be22b1481eaae48d110d97c49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02691447f1d554276f01339ba6c3aad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a02691447f1d554276f01339ba6c3aad7">addSurface</a> (<a class="el" href="namespacemc__rbdyn.html#a848cf0b2e8f6ca6f18ceba1769d9a426">mc_rbdyn::SurfacePtr</a> <a class="el" href="structmc__rbdyn_1_1Robot.html#aa4b724e51881215dd4293f9578656755">surface</a>, bool doNotReplace=true)</td></tr>
<tr class="separator:a02691447f1d554276f01339ba6c3aad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee61e66a131e6f3e24982d4c68ffe958"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="namespacemc__rbdyn.html#a848cf0b2e8f6ca6f18ceba1769d9a426">mc_rbdyn::SurfacePtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aee61e66a131e6f3e24982d4c68ffe958">surfaces</a> () const</td></tr>
<tr class="separator:aee61e66a131e6f3e24982d4c68ffe958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0e0346563b3ba8d3fda355e27367a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aac0e0346563b3ba8d3fda355e27367a8">availableSurfaces</a> () const</td></tr>
<tr class="separator:aac0e0346563b3ba8d3fda355e27367a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa71c0145f03a620619e8fe8b96107"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a75aa71c0145f03a620619e8fe8b96107">hasConvex</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a75aa71c0145f03a620619e8fe8b96107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa487585e4b6d447c69ba78d9eca203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmc__rbdyn_1_1Robot.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a7fa487585e4b6d447c69ba78d9eca203">convex</a> (const std::string &amp;cName)</td></tr>
<tr class="separator:a7fa487585e4b6d447c69ba78d9eca203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2dc756cfb84c337de115384febab34"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1Robot.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a2b2dc756cfb84c337de115384febab34">convex</a> (const std::string &amp;cName) const</td></tr>
<tr class="separator:a2b2dc756cfb84c337de115384febab34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa176323f1dd1dc8f29ad40ccd4b23c9d"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="structmc__rbdyn_1_1Robot.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aa176323f1dd1dc8f29ad40ccd4b23c9d">convexes</a> () const</td></tr>
<tr class="separator:aa176323f1dd1dc8f29ad40ccd4b23c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30c16125ec220e6525f86339d894a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ae30c16125ec220e6525f86339d894a3c">addConvex</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>, const std::string &amp;body, <a class="el" href="namespacemc__rbdyn.html#ac3517607389b845ee6ffdee65cbc8a63">S_ObjectPtr</a> <a class="el" href="structmc__rbdyn_1_1Robot.html#a7fa487585e4b6d447c69ba78d9eca203">convex</a>, const sva::PTransformd &amp;X_b_c=sva::PTransformd::Identity())</td></tr>
<tr class="separator:ae30c16125ec220e6525f86339d894a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3296b923f06db47d80641b7acf46e5bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a3296b923f06db47d80641b7acf46e5bf">removeConvex</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="separator:a3296b923f06db47d80641b7acf46e5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd5ae09effe07a9a766050bcfee859"><td class="memItemLeft" align="right" valign="top">const sva::PTransformd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a91bd5ae09effe07a9a766050bcfee859">bodyTransform</a> (const std::string &amp;bName) const</td></tr>
<tr class="separator:a91bd5ae09effe07a9a766050bcfee859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022bd9c9318d298da53c823ca93b5f1c"><td class="memItemLeft" align="right" valign="top">const sva::PTransformd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a022bd9c9318d298da53c823ca93b5f1c">bodyTransform</a> (int bodyIndex) const</td></tr>
<tr class="separator:a022bd9c9318d298da53c823ca93b5f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135b6be808af82a5b0d21ffda5a8fe17"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sva::PTransformd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a135b6be808af82a5b0d21ffda5a8fe17">bodyTransforms</a> () const</td></tr>
<tr class="separator:a135b6be808af82a5b0d21ffda5a8fe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af239b709cd1907f1aa264dfa2cb9fd15"><td class="memItemLeft" align="right" valign="top">const sva::PTransformd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#af239b709cd1907f1aa264dfa2cb9fd15">collisionTransform</a> (const std::string &amp;cName) const</td></tr>
<tr class="separator:af239b709cd1907f1aa264dfa2cb9fd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1554209253be449c1fb4cdd7e3d2478d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a1554209253be449c1fb4cdd7e3d2478d">loadRSDFFromDir</a> (const std::string &amp;surfaceDir)</td></tr>
<tr class="separator:a1554209253be449c1fb4cdd7e3d2478d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b932fc4c4956b16490006dd8591d0e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac4b932fc4c4956b16490006dd8591d0e">stance</a> () const</td></tr>
<tr class="separator:ac4b932fc4c4956b16490006dd8591d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2161c1f89c0b9e3a812ca390ff7666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmc__rbdyn_1_1Robots.html">mc_rbdyn::Robots</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a4a2161c1f89c0b9e3a812ca390ff7666">robots</a> () noexcept</td></tr>
<tr class="separator:a4a2161c1f89c0b9e3a812ca390ff7666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c413ebff3be3f588eff569106ba4426"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1Robots.html">mc_rbdyn::Robots</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a6c413ebff3be3f588eff569106ba4426">robots</a> () const noexcept</td></tr>
<tr class="separator:a6c413ebff3be3f588eff569106ba4426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af110c909887516af9f6758118978b643"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#af110c909887516af9f6758118978b643">robotIndex</a> () const</td></tr>
<tr class="separator:af110c909887516af9f6758118978b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46b693d4431e61db9f1d4a05f66dd5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ae46b693d4431e61db9f1d4a05f66dd5e">forwardKinematics</a> ()</td></tr>
<tr class="separator:ae46b693d4431e61db9f1d4a05f66dd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9520af131693e9b873ce4c37513cfa1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a9520af131693e9b873ce4c37513cfa1d">forwardKinematics</a> (rbd::MultiBodyConfig &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a0051e9ce612a34601d6934f7d5caaeb4">mbc</a>) const</td></tr>
<tr class="separator:a9520af131693e9b873ce4c37513cfa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd93342dd86da6803288346a3798d374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#afd93342dd86da6803288346a3798d374">forwardVelocity</a> ()</td></tr>
<tr class="separator:afd93342dd86da6803288346a3798d374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73998aca81be7062371f39ce5d60756a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a73998aca81be7062371f39ce5d60756a">forwardVelocity</a> (rbd::MultiBodyConfig &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a0051e9ce612a34601d6934f7d5caaeb4">mbc</a>) const</td></tr>
<tr class="separator:a73998aca81be7062371f39ce5d60756a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c546ec0809807016d316229d1d29c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ab7c546ec0809807016d316229d1d29c0">forwardAcceleration</a> (const sva::MotionVecd &amp;A_0=sva::MotionVecd(Eigen::Vector6d::Zero()))</td></tr>
<tr class="separator:ab7c546ec0809807016d316229d1d29c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5564b8d60b3dd8fa3e88e31f8f93a02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ad5564b8d60b3dd8fa3e88e31f8f93a02">forwardAcceleration</a> (rbd::MultiBodyConfig &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a0051e9ce612a34601d6934f7d5caaeb4">mbc</a>, const sva::MotionVecd &amp;A_0=sva::MotionVecd(Eigen::Vector6d::Zero())) const</td></tr>
<tr class="separator:ad5564b8d60b3dd8fa3e88e31f8f93a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1794c11cac282d7c042216d431ebb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#acd1794c11cac282d7c042216d431ebb7">eulerIntegration</a> (double step)</td></tr>
<tr class="separator:acd1794c11cac282d7c042216d431ebb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d130fc22dda8e9bfbecad28acc26a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ae8d130fc22dda8e9bfbecad28acc26a5">eulerIntegration</a> (rbd::MultiBodyConfig &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a0051e9ce612a34601d6934f7d5caaeb4">mbc</a>, double step) const</td></tr>
<tr class="separator:ae8d130fc22dda8e9bfbecad28acc26a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48843047df8893808f80971fa3f9257f"><td class="memItemLeft" align="right" valign="top">const sva::PTransformd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a48843047df8893808f80971fa3f9257f">posW</a> () const</td></tr>
<tr class="separator:a48843047df8893808f80971fa3f9257f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fe0da3fe099906b79cb20de8076659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a54fe0da3fe099906b79cb20de8076659">posW</a> (const sva::PTransformd &amp;pt)</td></tr>
<tr class="separator:a54fe0da3fe099906b79cb20de8076659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f3f6250f68bac91a2594e9e6383b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a50f3f6250f68bac91a2594e9e6383b2f">velW</a> (const sva::MotionVecd &amp;vel)</td></tr>
<tr class="separator:a50f3f6250f68bac91a2594e9e6383b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38618f0ff197fccef53069f51e9fcafc"><td class="memItemLeft" align="right" valign="top">const sva::MotionVecd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a38618f0ff197fccef53069f51e9fcafc">velW</a> () const</td></tr>
<tr class="separator:a38618f0ff197fccef53069f51e9fcafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7a59334340cf8b44a10c6c9cb64d76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a8c7a59334340cf8b44a10c6c9cb64d76">accW</a> (const sva::MotionVecd &amp;acc)</td></tr>
<tr class="separator:a8c7a59334340cf8b44a10c6c9cb64d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b21b6e828397cebd4f015cf9e87f44"><td class="memItemLeft" align="right" valign="top">const sva::MotionVecd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a30b21b6e828397cebd4f015cf9e87f44">accW</a> () const</td></tr>
<tr class="separator:a30b21b6e828397cebd4f015cf9e87f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b970df4059237f37021b47d5aaf2494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmc__control_1_1Gripper.html">mc_control::Gripper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a8b970df4059237f37021b47d5aaf2494">gripper</a> (const std::string &amp;gripper)</td></tr>
<tr class="separator:a8b970df4059237f37021b47d5aaf2494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c37bc25e3eb43bd7f040c252647e64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__control_1_1Gripper.html">mc_control::Gripper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac1c37bc25e3eb43bd7f040c252647e64">gripper</a> (const std::string &amp;gripper) const</td></tr>
<tr class="separator:ac1c37bc25e3eb43bd7f040c252647e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15e501f93c406e3ad5d19ab6904bd4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ae15e501f93c406e3ad5d19ab6904bd4e">hasGripper</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a8b970df4059237f37021b47d5aaf2494">gripper</a>) const</td></tr>
<tr class="separator:ae15e501f93c406e3ad5d19ab6904bd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae446ae5052274ecd2b2c8d8a641d02c2"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; std::string, <a class="el" href="namespacemc__control.html#a67d3b51822d3e7d0c56d9af675f9eaa1">mc_control::GripperPtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ae446ae5052274ecd2b2c8d8a641d02c2">grippersByName</a> () const noexcept</td></tr>
<tr class="separator:ae446ae5052274ecd2b2c8d8a641d02c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461d76c25d7b7d24be8f73afa1471e03"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacemc__control.html#a39b3dee4f4017bab0f389d9bfd7877dc">mc_control::GripperRef</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a461d76c25d7b7d24be8f73afa1471e03">grippers</a> () const noexcept</td></tr>
<tr class="separator:a461d76c25d7b7d24be8f73afa1471e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35e2fdc9ec56540b48e9bd5247c7b2b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacemc__rbdyn.html#a33ca728cc2ff802237e8135754f359a8">RobotDataPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#af35e2fdc9ec56540b48e9bd5247c7b2b">data</a> () const noexcept</td></tr>
<tr class="separator:af35e2fdc9ec56540b48e9bd5247c7b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ceee5e97be39dced4c2fc1e1d32a7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmc__tvm_1_1Robot.html">mc_tvm::Robot</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ae8ceee5e97be39dced4c2fc1e1d32a7d">tvmRobot</a> () const</td></tr>
<tr class="separator:ae8ceee5e97be39dced4c2fc1e1d32a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f10151a30f06aafd99ecb2ed7b2738e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmc__tvm_1_1Convex.html">mc_tvm::Convex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a1f10151a30f06aafd99ecb2ed7b2738e">tvmConvex</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a1f10151a30f06aafd99ecb2ed7b2738e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af401606c1f14455ae3fb2e642c2b5ade"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#af401606c1f14455ae3fb2e642c2b5ade">Robot</a> (<a class="el" href="structmc__rbdyn_1_1Robot_1_1NewRobotToken.html">NewRobotToken</a>, const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>, <a class="el" href="structmc__rbdyn_1_1Robots.html">Robots</a> &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a4a2161c1f89c0b9e3a812ca390ff7666">robots</a>, unsigned int robots_idx, bool loadFiles, const <a class="el" href="structmc__rbdyn_1_1LoadRobotParameters.html">LoadRobotParameters</a> &amp;params={})</td></tr>
<tr class="separator:af401606c1f14455ae3fb2e642c2b5ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Body sensors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are related to force sensors </p>
</div></td></tr>
<tr class="memitem:a41b7c80447b0d61661bfc2a0242eaa8f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1BodySensor.html">BodySensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a41b7c80447b0d61661bfc2a0242eaa8f">bodySensor</a> () const noexcept</td></tr>
<tr class="separator:a41b7c80447b0d61661bfc2a0242eaa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d953d97ba1f0fbeed5e208e78e3d97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a52d953d97ba1f0fbeed5e208e78e3d97">hasBodySensor</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const noexcept</td></tr>
<tr class="separator:a52d953d97ba1f0fbeed5e208e78e3d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5526be81e352a5fa7ce4038ba39052"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aaf5526be81e352a5fa7ce4038ba39052">bodyHasBodySensor</a> (const std::string &amp;body) const noexcept</td></tr>
<tr class="separator:aaf5526be81e352a5fa7ce4038ba39052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e04286463ae6f91105c0b83ef370da8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1BodySensor.html">BodySensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a6e04286463ae6f91105c0b83ef370da8">bodySensor</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a6e04286463ae6f91105c0b83ef370da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4faa529e12f2d401c2d7a805f07ae75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1BodySensor.html">BodySensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac4faa529e12f2d401c2d7a805f07ae75">bodyBodySensor</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:ac4faa529e12f2d401c2d7a805f07ae75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc810f916462cb34c4126220f4f8a3e9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacemc__rbdyn.html#a728d731db2806e7673f67b958970e558">BodySensorVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#afc810f916462cb34c4126220f4f8a3e9">bodySensors</a> () const noexcept</td></tr>
<tr class="separator:afc810f916462cb34c4126220f4f8a3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Returns the joint index of joint named</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the joint does not exist within the robot. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:a7ad6afc9dd0267860a325771e7f87ea1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a7ad6afc9dd0267860a325771e7f87ea1">jointIndexByName</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a7ad6afc9dd0267860a325771e7f87ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3662367cdf4edb974bdad793b1189b20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a3662367cdf4edb974bdad793b1189b20">jointIndexInMBC</a> (size_t jointIndex) const</td></tr>
<tr class="separator:a3662367cdf4edb974bdad793b1189b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Returns the body index of joint named</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the body does not exist within the robot. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:a5309b5ef9bb5b91bf0f1adb59813bde4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a5309b5ef9bb5b91bf0f1adb59813bde4">bodyIndexByName</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a5309b5ef9bb5b91bf0f1adb59813bde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bdab3efcd9ada4d2b3aefa53374af1"><td class="memItemLeft" align="right" valign="top">rbd::MultiBody &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a79bdab3efcd9ada4d2b3aefa53374af1">mb</a> ()</td></tr>
<tr class="separator:a79bdab3efcd9ada4d2b3aefa53374af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09b1765903debcc06dce65ce830cfc0"><td class="memItemLeft" align="right" valign="top">const rbd::MultiBody &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ab09b1765903debcc06dce65ce830cfc0">mb</a> () const</td></tr>
<tr class="separator:ab09b1765903debcc06dce65ce830cfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0051e9ce612a34601d6934f7d5caaeb4"><td class="memItemLeft" align="right" valign="top">rbd::MultiBodyConfig &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a0051e9ce612a34601d6934f7d5caaeb4">mbc</a> ()</td></tr>
<tr class="separator:a0051e9ce612a34601d6934f7d5caaeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece5a00f65317b116f70ed2937239421"><td class="memItemLeft" align="right" valign="top">const rbd::MultiBodyConfig &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aece5a00f65317b116f70ed2937239421">mbc</a> () const</td></tr>
<tr class="separator:aece5a00f65317b116f70ed2937239421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900ba960e115fa967889ebdb842f6a3e"><td class="memItemLeft" align="right" valign="top">rbd::MultiBodyGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a900ba960e115fa967889ebdb842f6a3e">mbg</a> ()</td></tr>
<tr class="separator:a900ba960e115fa967889ebdb842f6a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78336b8d90c933da75cd138227072321"><td class="memItemLeft" align="right" valign="top">const rbd::MultiBodyGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a78336b8d90c933da75cd138227072321">mbg</a> () const</td></tr>
<tr class="separator:a78336b8d90c933da75cd138227072321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485eb8aa4ceb0a0a5010844d16e47f95"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a485eb8aa4ceb0a0a5010844d16e47f95">q</a> () const</td></tr>
<tr class="separator:a485eb8aa4ceb0a0a5010844d16e47f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5773f91f2a9d0eb5cb4b6a0943551a1b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a5773f91f2a9d0eb5cb4b6a0943551a1b">alpha</a> () const</td></tr>
<tr class="separator:a5773f91f2a9d0eb5cb4b6a0943551a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca1f147be470012cb1203f95d5c5abe"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aeca1f147be470012cb1203f95d5c5abe">alphaD</a> () const</td></tr>
<tr class="separator:aeca1f147be470012cb1203f95d5c5abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95798f9588d0656c61558ab20ad935b4"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a95798f9588d0656c61558ab20ad935b4">jointTorque</a> () const</td></tr>
<tr class="separator:a95798f9588d0656c61558ab20ad935b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855db41e44bee30fa7f6ecabc87eba55"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a855db41e44bee30fa7f6ecabc87eba55">controlTorque</a> () const noexcept</td></tr>
<tr class="separator:a855db41e44bee30fa7f6ecabc87eba55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9415aa6bf2421a5e76bd85b04359b1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sva::PTransformd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a7e9415aa6bf2421a5e76bd85b04359b1">bodyPosW</a> () const</td></tr>
<tr class="separator:a7e9415aa6bf2421a5e76bd85b04359b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1bcd2edaa8eeb17033ae3fafe1bde8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aad1bcd2edaa8eeb17033ae3fafe1bde8">bodyVelW</a> () const</td></tr>
<tr class="separator:aad1bcd2edaa8eeb17033ae3fafe1bde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ce1f653158bc3b79dd903ee1c05d9c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac4ce1f653158bc3b79dd903ee1c05d9c">bodyVelB</a> () const</td></tr>
<tr class="separator:ac4ce1f653158bc3b79dd903ee1c05d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4739f4a8c3d2ac6a20797e7287b959"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a1e4739f4a8c3d2ac6a20797e7287b959">bodyAccB</a> () const</td></tr>
<tr class="separator:a1e4739f4a8c3d2ac6a20797e7287b959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad8d3434a21adb16f8c41a5444ea067"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a8ad8d3434a21adb16f8c41a5444ea067">q</a> ()</td></tr>
<tr class="separator:a8ad8d3434a21adb16f8c41a5444ea067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36db2265563e037f7b98f2a3b8ac826"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ad36db2265563e037f7b98f2a3b8ac826">alpha</a> ()</td></tr>
<tr class="separator:ad36db2265563e037f7b98f2a3b8ac826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611ff3ed6802a623056076abba7283ac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a611ff3ed6802a623056076abba7283ac">alphaD</a> ()</td></tr>
<tr class="separator:a611ff3ed6802a623056076abba7283ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af946d00c2f9e36ed5c0899f237f35c32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#af946d00c2f9e36ed5c0899f237f35c32">jointTorque</a> ()</td></tr>
<tr class="separator:af946d00c2f9e36ed5c0899f237f35c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6da2c5953ec1e782c4ae965c463d7d3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac6da2c5953ec1e782c4ae965c463d7d3">controlTorque</a> () noexcept</td></tr>
<tr class="separator:ac6da2c5953ec1e782c4ae965c463d7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0aad75ddf11178d780abe0a64d7021"><td class="memItemLeft" align="right" valign="top">std::vector&lt; sva::PTransformd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#adf0aad75ddf11178d780abe0a64d7021">bodyPosW</a> ()</td></tr>
<tr class="separator:adf0aad75ddf11178d780abe0a64d7021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252c64f915ca619afcdcf27e9dd63dd2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a252c64f915ca619afcdcf27e9dd63dd2">bodyVelW</a> ()</td></tr>
<tr class="separator:a252c64f915ca619afcdcf27e9dd63dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b38b6bbe93a7b6cc48d9091e9ee8b5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a54b38b6bbe93a7b6cc48d9091e9ee8b5">bodyVelB</a> ()</td></tr>
<tr class="separator:a54b38b6bbe93a7b6cc48d9091e9ee8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfdb088e19e290eea18767e249ca79e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#accfdb088e19e290eea18767e249ca79e">bodyAccB</a> ()</td></tr>
<tr class="separator:accfdb088e19e290eea18767e249ca79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7764d03bd41fedfa98443d4a0b262e9"><td class="memItemLeft" align="right" valign="top">const sva::PTransformd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#af7764d03bd41fedfa98443d4a0b262e9">bodyPosW</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:af7764d03bd41fedfa98443d4a0b262e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76547cf0aab26354dad897265d6060ee"><td class="memItemLeft" align="right" valign="top">sva::PTransformd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a76547cf0aab26354dad897265d6060ee">X_b1_b2</a> (const std::string &amp;b1, const std::string &amp;b2) const</td></tr>
<tr class="separator:a76547cf0aab26354dad897265d6060ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4808b0299894e9343b6c27b1cc6e14"><td class="memItemLeft" align="right" valign="top">const sva::MotionVecd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#abc4808b0299894e9343b6c27b1cc6e14">bodyVelW</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:abc4808b0299894e9343b6c27b1cc6e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86619b4049ec59d383a445bafe43830e"><td class="memItemLeft" align="right" valign="top">const sva::MotionVecd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a86619b4049ec59d383a445bafe43830e">bodyVelB</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a86619b4049ec59d383a445bafe43830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e766814295ca73b3bf6da8e90f4421"><td class="memItemLeft" align="right" valign="top">const sva::MotionVecd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a81e766814295ca73b3bf6da8e90f4421">bodyAccB</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a81e766814295ca73b3bf6da8e90f4421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e858c693b7e94ded9704e13463e1ae5"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a4e858c693b7e94ded9704e13463e1ae5">com</a> () const</td></tr>
<tr class="separator:a4e858c693b7e94ded9704e13463e1ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17c3d6b4bff8b9bcbedad822a86fdbc"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aa17c3d6b4bff8b9bcbedad822a86fdbc">comVelocity</a> () const</td></tr>
<tr class="separator:aa17c3d6b4bff8b9bcbedad822a86fdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f1932b13b8a4589f66dd792522e1ae"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a68f1932b13b8a4589f66dd792522e1ae">comAcceleration</a> () const</td></tr>
<tr class="separator:a68f1932b13b8a4589f66dd792522e1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928b9370f7643511d1ec80892245fb88"><td class="memItemLeft" align="right" valign="top">sva::ForceVecd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a928b9370f7643511d1ec80892245fb88">surfaceWrench</a> (const std::string &amp;surfaceName) const</td></tr>
<tr class="separator:a928b9370f7643511d1ec80892245fb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207f3ea22bce722a3d68ac37aed8ca03"><td class="memItemLeft" align="right" valign="top">sva::ForceVecd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a207f3ea22bce722a3d68ac37aed8ca03">bodyWrench</a> (const std::string &amp;bodyName) const</td></tr>
<tr class="separator:a207f3ea22bce722a3d68ac37aed8ca03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4679daa562a23a753a3f5f77daa9861"><td class="memItemLeft" align="right" valign="top">Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aa4679daa562a23a753a3f5f77daa9861">cop</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#ac68ae766d6de9d5f8740001ac10a62db">frame</a>, double min_pressure=0.5) const</td></tr>
<tr class="separator:aa4679daa562a23a753a3f5f77daa9861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7aa66da24521f280bbc2d9c16cdda7"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a2b7aa66da24521f280bbc2d9c16cdda7">copW</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#ac68ae766d6de9d5f8740001ac10a62db">frame</a>, double min_pressure=0.5) const</td></tr>
<tr class="separator:a2b7aa66da24521f280bbc2d9c16cdda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117494f13e48578a752a102e322189b0"><td class="memItemLeft" align="right" valign="top">sva::ForceVecd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a117494f13e48578a752a102e322189b0">netWrench</a> (const std::vector&lt; std::string &gt; &amp;sensorNames) const</td></tr>
<tr class="memdesc:a117494f13e48578a752a102e322189b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes net total wrench from a list of sensors.  <a href="#a117494f13e48578a752a102e322189b0">More...</a><br /></td></tr>
<tr class="separator:a117494f13e48578a752a102e322189b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4">zmp</a> (const sva::ForceVecd &amp;netTotalWrench, const Eigen::Vector3d &amp;plane_p, const Eigen::Vector3d &amp;plane_n, double minimalNetNormalForce=1.) const</td></tr>
<tr class="memdesc:a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual ZMP computation from net total wrench and the ZMP plane.  <a href="#a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4">More...</a><br /></td></tr>
<tr class="separator:a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcb02ade95368eba497ffab50bab0d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#acfcb02ade95368eba497ffab50bab0d2">zmp</a> (Eigen::Vector3d &amp;zmpOut, const sva::ForceVecd &amp;netTotalWrench, const Eigen::Vector3d &amp;plane_p, const Eigen::Vector3d &amp;plane_n, double minimalNetNormalForce=1.) const noexcept</td></tr>
<tr class="memdesc:acfcb02ade95368eba497ffab50bab0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual ZMP computation from net total wrench and the ZMP plane.  <a href="#acfcb02ade95368eba497ffab50bab0d2">More...</a><br /></td></tr>
<tr class="separator:acfcb02ade95368eba497ffab50bab0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca98040d3ecdb597c65f3615a06d588d"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aca98040d3ecdb597c65f3615a06d588d">zmp</a> (const sva::ForceVecd &amp;netTotalWrench, const sva::PTransformd &amp;zmpFrame, double minimalNetNormalForce=1.) const</td></tr>
<tr class="memdesc:aca98040d3ecdb597c65f3615a06d588d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZMP computation from net total wrench and a frame.  <a href="#aca98040d3ecdb597c65f3615a06d588d">More...</a><br /></td></tr>
<tr class="separator:aca98040d3ecdb597c65f3615a06d588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2224fc6a6299e9ed0ec8fdd8f3b3d4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aa2224fc6a6299e9ed0ec8fdd8f3b3d4c">zmp</a> (Eigen::Vector3d &amp;zmpOut, const sva::ForceVecd &amp;netTotalWrench, const sva::PTransformd &amp;zmpFrame, double minimalNetNormalForce=1.) const noexcept</td></tr>
<tr class="memdesc:aa2224fc6a6299e9ed0ec8fdd8f3b3d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZMP computation from net total wrench and a frame.  <a href="#aa2224fc6a6299e9ed0ec8fdd8f3b3d4c">More...</a><br /></td></tr>
<tr class="separator:aa2224fc6a6299e9ed0ec8fdd8f3b3d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472551d6b434e3e5a2239b35cffc639b"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a472551d6b434e3e5a2239b35cffc639b">zmp</a> (const std::vector&lt; std::string &gt; &amp;sensorNames, const Eigen::Vector3d &amp;plane_p, const Eigen::Vector3d &amp;plane_n, double minimalNetNormalForce=1.) const</td></tr>
<tr class="separator:a472551d6b434e3e5a2239b35cffc639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4348f47e45430a9ed99a00c2940e2f00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a4348f47e45430a9ed99a00c2940e2f00">zmp</a> (Eigen::Vector3d &amp;zmpOut, const std::vector&lt; std::string &gt; &amp;sensorNames, const Eigen::Vector3d &amp;plane_p, const Eigen::Vector3d &amp;plane_n, double minimalNetNormalForce=1.) const noexcept</td></tr>
<tr class="separator:a4348f47e45430a9ed99a00c2940e2f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b62d2a94e3c81f2c436828bc9ed5186"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a4b62d2a94e3c81f2c436828bc9ed5186">zmp</a> (const std::vector&lt; std::string &gt; &amp;sensorNames, const sva::PTransformd &amp;zmpFrame, double minimalNetNormalForce=1.) const</td></tr>
<tr class="memdesc:a4b62d2a94e3c81f2c436828bc9ed5186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the ZMP from sensor names and a frame.  <a href="#a4b62d2a94e3c81f2c436828bc9ed5186">More...</a><br /></td></tr>
<tr class="separator:a4b62d2a94e3c81f2c436828bc9ed5186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c0589359353a2d34b5f4331fa32793"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ab8c0589359353a2d34b5f4331fa32793">zmp</a> (Eigen::Vector3d &amp;zmpOut, const std::vector&lt; std::string &gt; &amp;sensorNames, const sva::PTransformd &amp;zmpFrame, double minimalNetNormalForce=1.) const noexcept</td></tr>
<tr class="memdesc:ab8c0589359353a2d34b5f4331fa32793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the ZMP from sensor names and a frame.  <a href="#ab8c0589359353a2d34b5f4331fa32793">More...</a><br /></td></tr>
<tr class="separator:ab8c0589359353a2d34b5f4331fa32793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18cb6ecabada0aac1f823b7e9170308"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac18cb6ecabada0aac1f823b7e9170308">ql</a> () const</td></tr>
<tr class="separator:ac18cb6ecabada0aac1f823b7e9170308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42c2ce3eea4e1100b4fc77b95821021"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac42c2ce3eea4e1100b4fc77b95821021">qu</a> () const</td></tr>
<tr class="separator:ac42c2ce3eea4e1100b4fc77b95821021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63444fe66136d722426aca78449d62a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ab63444fe66136d722426aca78449d62a">vl</a> () const</td></tr>
<tr class="separator:ab63444fe66136d722426aca78449d62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b8ab43b004940508945dcb1234e60"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac77b8ab43b004940508945dcb1234e60">vu</a> () const</td></tr>
<tr class="separator:ac77b8ab43b004940508945dcb1234e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353666f3eb88becdbde844f6e6915807"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a353666f3eb88becdbde844f6e6915807">al</a> () const</td></tr>
<tr class="separator:a353666f3eb88becdbde844f6e6915807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b3183f0c2579662c80c1c94aca9410"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ab0b3183f0c2579662c80c1c94aca9410">au</a> () const</td></tr>
<tr class="separator:ab0b3183f0c2579662c80c1c94aca9410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890c6fcf28ad497b922aaff1b536968a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a890c6fcf28ad497b922aaff1b536968a">jl</a> () const</td></tr>
<tr class="separator:a890c6fcf28ad497b922aaff1b536968a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112f8dbb672b9911d63f479d57525241"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a112f8dbb672b9911d63f479d57525241">ju</a> () const</td></tr>
<tr class="separator:a112f8dbb672b9911d63f479d57525241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4cbabd88c9ee4565a2555dcc0208ae"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#afd4cbabd88c9ee4565a2555dcc0208ae">tl</a> () const</td></tr>
<tr class="separator:afd4cbabd88c9ee4565a2555dcc0208ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f8c3970a3aff460fc5abad5b493eb6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a74f8c3970a3aff460fc5abad5b493eb6">tu</a> () const</td></tr>
<tr class="separator:a74f8c3970a3aff460fc5abad5b493eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa7e717817cab5e190f17d0397ff934"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a9fa7e717817cab5e190f17d0397ff934">tdl</a> () const</td></tr>
<tr class="separator:a9fa7e717817cab5e190f17d0397ff934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2607ecfbe200094f4bba59ac7c5c390d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a2607ecfbe200094f4bba59ac7c5c390d">tdu</a> () const</td></tr>
<tr class="separator:a2607ecfbe200094f4bba59ac7c5c390d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc061e1b33c4f633a04015ab3fb20f94"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#afc061e1b33c4f633a04015ab3fb20f94">ql</a> ()</td></tr>
<tr class="separator:afc061e1b33c4f633a04015ab3fb20f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6915de62543382030defd22b9f8011c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac6915de62543382030defd22b9f8011c">qu</a> ()</td></tr>
<tr class="separator:ac6915de62543382030defd22b9f8011c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8dbaec40be4ad0be51f4df67502d39"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a8a8dbaec40be4ad0be51f4df67502d39">vl</a> ()</td></tr>
<tr class="separator:a8a8dbaec40be4ad0be51f4df67502d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c3ad6f7d81353b09689ea6e41eec34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ae6c3ad6f7d81353b09689ea6e41eec34">vu</a> ()</td></tr>
<tr class="separator:ae6c3ad6f7d81353b09689ea6e41eec34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64263a01616ad04b3f5212fd5742fd2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ab64263a01616ad04b3f5212fd5742fd2">al</a> ()</td></tr>
<tr class="separator:ab64263a01616ad04b3f5212fd5742fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b41cfc1ed67b789573ca788b6e79cf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ab0b41cfc1ed67b789573ca788b6e79cf">au</a> ()</td></tr>
<tr class="separator:ab0b41cfc1ed67b789573ca788b6e79cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f86bf8a4708ee63e116eb6bdd0f5bdf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a8f86bf8a4708ee63e116eb6bdd0f5bdf">jl</a> ()</td></tr>
<tr class="separator:a8f86bf8a4708ee63e116eb6bdd0f5bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c3d7ef8c743eebe234bf8f4fd418e8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a28c3d7ef8c743eebe234bf8f4fd418e8">ju</a> ()</td></tr>
<tr class="separator:a28c3d7ef8c743eebe234bf8f4fd418e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6dfded6aa9e9c6ca6ff6d8e386b66d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#adf6dfded6aa9e9c6ca6ff6d8e386b66d">tl</a> ()</td></tr>
<tr class="separator:adf6dfded6aa9e9c6ca6ff6d8e386b66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe854537bd0f1fb8ab64ce91f5f6105d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#afe854537bd0f1fb8ab64ce91f5f6105d">tu</a> ()</td></tr>
<tr class="separator:afe854537bd0f1fb8ab64ce91f5f6105d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a5fe0d5e143aae2d95ba39e56ab0a9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a39a5fe0d5e143aae2d95ba39e56ab0a9">tdl</a> ()</td></tr>
<tr class="separator:a39a5fe0d5e143aae2d95ba39e56ab0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a7831e452c28f863abba6992990ac8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a77a7831e452c28f863abba6992990ac8">tdu</a> ()</td></tr>
<tr class="separator:a77a7831e452c28f863abba6992990ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adada908603cd6527095ccb940d6405bb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structmc__rbdyn_1_1Flexibility.html">Flexibility</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#adada908603cd6527095ccb940d6405bb">flexibility</a> () const</td></tr>
<tr class="separator:adada908603cd6527095ccb940d6405bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b9f6334096f8f9534d4dfab3a89495"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmc__rbdyn_1_1Flexibility.html">Flexibility</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a52b9f6334096f8f9534d4dfab3a89495">flexibility</a> ()</td></tr>
<tr class="separator:a52b9f6334096f8f9534d4dfab3a89495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70ad9c81c418baf93ecccd6a75ff12f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ad70ad9c81c418baf93ecccd6a75ff12f">zmpTarget</a> (const Eigen::Vector3d &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4">zmp</a>)</td></tr>
<tr class="separator:ad70ad9c81c418baf93ecccd6a75ff12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa1d2571113230a15a6726fb06b91fa"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3d &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a8fa1d2571113230a15a6726fb06b91fa">zmpTarget</a> () const</td></tr>
<tr class="separator:a8fa1d2571113230a15a6726fb06b91fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa368e46d6f3d90f8f4eca437358148f8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#aa368e46d6f3d90f8f4eca437358148f8">mass</a> () const noexcept</td></tr>
<tr class="separator:aa368e46d6f3d90f8f4eca437358148f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Joint sensors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions give information about joints' status </p>
</div></td></tr>
<tr class="memitem:a1da8134deea10a32f7d35fc381649606"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a1da8134deea10a32f7d35fc381649606">encoderValues</a> () const noexcept</td></tr>
<tr class="separator:a1da8134deea10a32f7d35fc381649606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2e3e0b4b0e226712007e9fe905f9e9"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a8a2e3e0b4b0e226712007e9fe905f9e9">encoderVelocities</a> () const noexcept</td></tr>
<tr class="separator:a8a2e3e0b4b0e226712007e9fe905f9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65b1b51c93d319952e2ae3965e204c8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#af65b1b51c93d319952e2ae3965e204c8">jointTorques</a> () const noexcept</td></tr>
<tr class="separator:af65b1b51c93d319952e2ae3965e204c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00856f04c24c914b9197fe11f2d573eb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a00856f04c24c914b9197fe11f2d573eb">refJointOrder</a> () const</td></tr>
<tr class="separator:a00856f04c24c914b9197fe11f2d573eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Force sensors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are related to force sensors </p>
</div></td></tr>
<tr class="memitem:a42615f6ac857b53acb4ae0376c3986c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a42615f6ac857b53acb4ae0376c3986c7">hasForceSensor</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const noexcept</td></tr>
<tr class="separator:a42615f6ac857b53acb4ae0376c3986c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf845c2c3a0f18430986e4a752f08fe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#acf845c2c3a0f18430986e4a752f08fe7">bodyHasForceSensor</a> (const std::string &amp;body) const noexcept</td></tr>
<tr class="separator:acf845c2c3a0f18430986e4a752f08fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb66cf0e07c2f24d9329cce0f6e5d3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a7fb66cf0e07c2f24d9329cce0f6e5d3b">surfaceHasForceSensor</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#aa4b724e51881215dd4293f9578656755">surface</a>) const</td></tr>
<tr class="memdesc:a7fb66cf0e07c2f24d9329cce0f6e5d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the surface has a force sensor directly attached to it.  <a href="#a7fb66cf0e07c2f24d9329cce0f6e5d3b">More...</a><br /></td></tr>
<tr class="separator:a7fb66cf0e07c2f24d9329cce0f6e5d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f6539a36fe9c2e4dc05b1ef3765963"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#af0f6539a36fe9c2e4dc05b1ef3765963">bodyHasIndirectForceSensor</a> (const std::string &amp;body) const</td></tr>
<tr class="separator:af0f6539a36fe9c2e4dc05b1ef3765963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05708ca15a7afb1c1b24315f4468356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ae05708ca15a7afb1c1b24315f4468356">surfaceHasIndirectForceSensor</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#aa4b724e51881215dd4293f9578656755">surface</a>) const</td></tr>
<tr class="separator:ae05708ca15a7afb1c1b24315f4468356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d807280f230919ff00adf3d43a5caa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a40d807280f230919ff00adf3d43a5caa">forceSensor</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a40d807280f230919ff00adf3d43a5caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8ac9af47c038fda22f721e9c1d3a89"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a7d8ac9af47c038fda22f721e9c1d3a89">bodyForceSensor</a> (const std::string &amp;body) const</td></tr>
<tr class="separator:a7d8ac9af47c038fda22f721e9c1d3a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affafbe491eaf05a4cc9aba0a371beac1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#affafbe491eaf05a4cc9aba0a371beac1">findBodyForceSensor</a> (const std::string &amp;body) const</td></tr>
<tr class="separator:affafbe491eaf05a4cc9aba0a371beac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace64ab0161e9b00e262b408733d19629"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ace64ab0161e9b00e262b408733d19629">surfaceForceSensor</a> (const std::string &amp;surfaceName) const</td></tr>
<tr class="separator:ace64ab0161e9b00e262b408733d19629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2ceb538921611b7b50a50634859e5f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a0c2ceb538921611b7b50a50634859e5f">indirectBodyForceSensor</a> (const std::string &amp;body) const</td></tr>
<tr class="memdesc:a0c2ceb538921611b7b50a50634859e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a force sensor directly or indirectly attached to a body.  <a href="#a0c2ceb538921611b7b50a50634859e5f">More...</a><br /></td></tr>
<tr class="separator:a0c2ceb538921611b7b50a50634859e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d7387d7242da1e7c42420583dce311"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a77d7387d7242da1e7c42420583dce311">indirectSurfaceForceSensor</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#aa4b724e51881215dd4293f9578656755">surface</a>) const</td></tr>
<tr class="memdesc:a77d7387d7242da1e7c42420583dce311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a force sensor directly or indirectly attached to a surface.  <a href="#a77d7387d7242da1e7c42420583dce311">More...</a><br /></td></tr>
<tr class="separator:a77d7387d7242da1e7c42420583dce311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d3115ea3d21076f556ce974f299f0e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac3d3115ea3d21076f556ce974f299f0e">forceSensors</a> () const noexcept</td></tr>
<tr class="separator:ac3d3115ea3d21076f556ce974f299f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Devices</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are related to generic devices handling </p>
</div></td></tr>
<tr class="memitem:a607854d4b0275f088553d91bbcdc9905"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a607854d4b0275f088553d91bbcdc9905"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a607854d4b0275f088553d91bbcdc9905">hasDevice</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const noexcept</td></tr>
<tr class="separator:a607854d4b0275f088553d91bbcdc9905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d3c6669d54957b2bfd0125aaf83dca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59d3c6669d54957b2bfd0125aaf83dca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a59d3c6669d54957b2bfd0125aaf83dca">hasSensor</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const noexcept</td></tr>
<tr class="separator:a59d3c6669d54957b2bfd0125aaf83dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3272e412d22bf6d382117300c9ee42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e3272e412d22bf6d382117300c9ee42"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a4e3272e412d22bf6d382117300c9ee42">device</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a4e3272e412d22bf6d382117300c9ee42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cff71ca3ef36a1f5b5a945d6e70b64b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cff71ca3ef36a1f5b5a945d6e70b64b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a6cff71ca3ef36a1f5b5a945d6e70b64b">device</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="separator:a6cff71ca3ef36a1f5b5a945d6e70b64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac554847320d3540e5e7ac9d58baafca0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmc__rbdyn_1_1DevicePtrVector.html">DevicePtrVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac554847320d3540e5e7ac9d58baafca0">devices</a> () const noexcept</td></tr>
<tr class="separator:ac554847320d3540e5e7ac9d58baafca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac945ba1c44d9dfb2f2312d13c8ed24b4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac945ba1c44d9dfb2f2312d13c8ed24b4"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ac945ba1c44d9dfb2f2312d13c8ed24b4">sensor</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:ac945ba1c44d9dfb2f2312d13c8ed24b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a8bd2c7daead0016449a6056fd2035"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72a8bd2c7daead0016449a6056fd2035"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a72a8bd2c7daead0016449a6056fd2035">sensor</a> (const std::string &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="separator:a72a8bd2c7daead0016449a6056fd2035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1736b85ddedafef83111d6c67ff6f129"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a1736b85ddedafef83111d6c67ff6f129">addDevice</a> (<a class="el" href="namespacemc__rbdyn.html#a356f67585abd89ae94368d4644d6e865">DevicePtr</a> <a class="el" href="structmc__rbdyn_1_1Robot.html#a4e3272e412d22bf6d382117300c9ee42">device</a>)</td></tr>
<tr class="separator:a1736b85ddedafef83111d6c67ff6f129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc302e460bc53880eb062681e9e50a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#abc302e460bc53880eb062681e9e50a54">addSensor</a> (<a class="el" href="namespacemc__rbdyn.html#aa1e86054c466a23bfdcb3470f71c8aad">SensorPtr</a> <a class="el" href="structmc__rbdyn_1_1Robot.html#ac945ba1c44d9dfb2f2312d13c8ed24b4">sensor</a>)</td></tr>
<tr class="separator:abc302e460bc53880eb062681e9e50a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae2c28ca834c5d81e66f581425c2d7f16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#ae2c28ca834c5d81e66f581425c2d7f16">copyLoadedData</a> (<a class="el" href="structmc__rbdyn_1_1Robot.html">Robot</a> &amp;destination) const</td></tr>
<tr class="separator:ae2c28ca834c5d81e66f581425c2d7f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218dfb7dbc50f94466e30871869b967d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a218dfb7dbc50f94466e30871869b967d">fixSurfaces</a> ()</td></tr>
<tr class="separator:a218dfb7dbc50f94466e30871869b967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3381189f816f8871e540555a533e64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a3d3381189f816f8871e540555a533e64">fixSurface</a> (<a class="el" href="structmc__rbdyn_1_1Surface.html">Surface</a> &amp;<a class="el" href="structmc__rbdyn_1_1Robot.html#aa4b724e51881215dd4293f9578656755">surface</a>)</td></tr>
<tr class="separator:a3d3381189f816f8871e540555a533e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005d9859a7272ac6dbcab9c31aef8092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a005d9859a7272ac6dbcab9c31aef8092">fixCollisionTransforms</a> ()</td></tr>
<tr class="separator:a005d9859a7272ac6dbcab9c31aef8092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec9236c7e0a6848e0fb76704ea64372"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#adec9236c7e0a6848e0fb76704ea64372">findIndirectForceSensorBodyName</a> (const std::string &amp;bodyName) const</td></tr>
<tr class="memdesc:adec9236c7e0a6848e0fb76704ea64372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the name of the body to which a force sensor is attached, starting from the provided body and going up the kinematic tree.  <a href="#adec9236c7e0a6848e0fb76704ea64372">More...</a><br /></td></tr>
<tr class="separator:adec9236c7e0a6848e0fb76704ea64372"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7ea6242bb22401bac23542e1db3a74ed"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc__rbdyn_1_1Robot.html#a7ea6242bb22401bac23542e1db3a74ed">Robots</a></td></tr>
<tr class="separator:a7ea6242bb22401bac23542e1db3a74ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aeaf56b7bf79a4e2be37e3c8615d156ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf56b7bf79a4e2be37e3c8615d156ad">&#9670;&nbsp;</a></span>convex_pair_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structmc__rbdyn_1_1Robot.html#aeaf56b7bf79a4e2be37e3c8615d156ad">mc_rbdyn::Robot::convex_pair_t</a> =  std::pair&lt;std::string, <a class="el" href="namespacemc__rbdyn.html#ac3517607389b845ee6ffdee65cbc8a63">S_ObjectPtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a132b55076c2d2b1045d0d71ff08b5065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132b55076c2d2b1045d0d71ff08b5065">&#9670;&nbsp;</a></span>Robot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mc_rbdyn::Robot::Robot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmc__rbdyn_1_1Robot.html">Robot</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84da94b87e530bead44b2c852755601d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84da94b87e530bead44b2c852755601d">&#9670;&nbsp;</a></span>~Robot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mc_rbdyn::Robot::~Robot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af401606c1f14455ae3fb2e642c2b5ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af401606c1f14455ae3fb2e642c2b5ade">&#9670;&nbsp;</a></span>Robot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mc_rbdyn::Robot::Robot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmc__rbdyn_1_1Robot_1_1NewRobotToken.html">NewRobotToken</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmc__rbdyn_1_1Robots.html">Robots</a> &amp;&#160;</td>
          <td class="paramname"><em>robots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>robots_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loadFiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmc__rbdyn_1_1LoadRobotParameters.html">LoadRobotParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invoked by <a class="el" href="structmc__rbdyn_1_1Robots.html">Robots</a> parent instance after mb/mbc/mbg/RobotModule are stored</p>
<p>When loadFiles is set to false, the convex and surfaces files are not loaded. This is used when copying one robot into another. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8c7a59334340cf8b44a10c6c9cb64d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7a59334340cf8b44a10c6c9cb64d76">&#9670;&nbsp;</a></span>accW() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::accW </td>
          <td>(</td>
          <td class="paramtype">const sva::MotionVecd &amp;&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the robot's floating base acceleration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vel</td><td>New floating base acceleration in the inertial frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function takes care of calling rbd::forwardAcceleration </dd></dl>

</div>
</div>
<a id="a30b21b6e828397cebd4f015cf9e87f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b21b6e828397cebd4f015cf9e87f44">&#9670;&nbsp;</a></span>accW() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::MotionVecd mc_rbdyn::Robot::accW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the robot's floating base acceleration expressed in the inertial frame </p>

</div>
</div>
<a id="ae30c16125ec220e6525f86339d894a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30c16125ec220e6525f86339d894a3c">&#9670;&nbsp;</a></span>addConvex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::addConvex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemc__rbdyn.html#ac3517607389b845ee6ffdee65cbc8a63">S_ObjectPtr</a>&#160;</td>
          <td class="paramname"><em>convex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::PTransformd &amp;&#160;</td>
          <td class="paramname"><em>X_b_c</em> = <code>sva::PTransformd::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a convex online</p>
<p>This has no effect if <code>name</code> is already a convex of the robot</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the convex</td></tr>
    <tr><td class="paramname">body</td><td>Name of the convex's parent body</td></tr>
    <tr><td class="paramname">convex</td><td>sch::Object object representing the convex</td></tr>
    <tr><td class="paramname">X_b_c</td><td>Transformation fro the convex's parent body to the convex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1736b85ddedafef83111d6c67ff6f129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1736b85ddedafef83111d6c67ff6f129">&#9670;&nbsp;</a></span>addDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::addDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemc__rbdyn.html#a356f67585abd89ae94368d4644d6e865">DevicePtr</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a generic device to the robot </p>

</div>
</div>
<a id="abc302e460bc53880eb062681e9e50a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc302e460bc53880eb062681e9e50a54">&#9670;&nbsp;</a></span>addSensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::addSensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemc__rbdyn.html#aa1e86054c466a23bfdcb3470f71c8aad">SensorPtr</a>&#160;</td>
          <td class="paramname"><em>sensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structmc__rbdyn_1_1Robot.html#a1736b85ddedafef83111d6c67ff6f129">addDevice</a> </dd></dl>

</div>
</div>
<a id="a02691447f1d554276f01339ba6c3aad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02691447f1d554276f01339ba6c3aad7">&#9670;&nbsp;</a></span>addSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::addSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemc__rbdyn.html#a848cf0b2e8f6ca6f18ceba1769d9a426">mc_rbdyn::SurfacePtr</a>&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doNotReplace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a surface with a new name </p>

</div>
</div>
<a id="a353666f3eb88becdbde844f6e6915807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353666f3eb88becdbde844f6e6915807">&#9670;&nbsp;</a></span>al() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::al </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower acceleration limits (const) </p>

</div>
</div>
<a id="ab64263a01616ad04b3f5212fd5742fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64263a01616ad04b3f5212fd5742fd2">&#9670;&nbsp;</a></span>al() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::al </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower acceleration limits </p>

</div>
</div>
<a id="a5773f91f2a9d0eb5cb4b6a0943551a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5773f91f2a9d0eb5cb4b6a0943551a1b">&#9670;&nbsp;</a></span>alpha() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::alpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().alpha (const) </p>

</div>
</div>
<a id="ad36db2265563e037f7b98f2a3b8ac826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36db2265563e037f7b98f2a3b8ac826">&#9670;&nbsp;</a></span>alpha() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::alpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().alpha </p>

</div>
</div>
<a id="aeca1f147be470012cb1203f95d5c5abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca1f147be470012cb1203f95d5c5abe">&#9670;&nbsp;</a></span>alphaD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::alphaD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().alphaD (const) </p>

</div>
</div>
<a id="a611ff3ed6802a623056076abba7283ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611ff3ed6802a623056076abba7283ac">&#9670;&nbsp;</a></span>alphaD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::alphaD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().alphaD </p>

</div>
</div>
<a id="ab0b3183f0c2579662c80c1c94aca9410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b3183f0c2579662c80c1c94aca9410">&#9670;&nbsp;</a></span>au() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::au </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper acceleration limits (const) </p>

</div>
</div>
<a id="ab0b41cfc1ed67b789573ca788b6e79cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b41cfc1ed67b789573ca788b6e79cf">&#9670;&nbsp;</a></span>au() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::au </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper acceleration limits </p>

</div>
</div>
<a id="aac0e0346563b3ba8d3fda355e27367a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0e0346563b3ba8d3fda355e27367a8">&#9670;&nbsp;</a></span>availableSurfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; mc_rbdyn::Robot::availableSurfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of available surfaces </p>

</div>
</div>
<a id="a1e4739f4a8c3d2ac6a20797e7287b959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4739f4a8c3d2ac6a20797e7287b959">&#9670;&nbsp;</a></span>bodyAccB() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyAccB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().bodyAccB (const) </p>

</div>
</div>
<a id="accfdb088e19e290eea18767e249ca79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfdb088e19e290eea18767e249ca79e">&#9670;&nbsp;</a></span>bodyAccB() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyAccB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().bodyAccB </p>

</div>
</div>
<a id="a81e766814295ca73b3bf6da8e90f4421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e766814295ca73b3bf6da8e90f4421">&#9670;&nbsp;</a></span>bodyAccB() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::MotionVecd&amp; mc_rbdyn::Robot::bodyAccB </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the acceleration of body <code>name</code> in body coordinates</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the body doest not exist within the robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4faa529e12f2d401c2d7a805f07ae75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4faa529e12f2d401c2d7a805f07ae75">&#9670;&nbsp;</a></span>bodyBodySensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1BodySensor.html">BodySensor</a>&amp; mc_rbdyn::Robot::bodyBodySensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a specific <a class="el" href="structmc__rbdyn_1_1BodySensor.html">BodySensor</a> by body name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the body</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>there is no sensor attached to the body </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d8ac9af47c038fda22f721e9c1d3a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8ac9af47c038fda22f721e9c1d3a89">&#9670;&nbsp;</a></span>bodyForceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a>&amp; mc_rbdyn::Robot::bodyForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a force sensor attached to the provided body</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>Name of the body to which the sensor is attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attached sensor</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is directly attached to this body</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a> &amp; indirectBodyForceSensor(const std::string &amp; body); To get a <a class="el" href="structmc__rbdyn_1_1Robot.html#ac945ba1c44d9dfb2f2312d13c8ed24b4">sensor</a> directly or indirectly attached to the body. </dd></dl>

</div>
</div>
<a id="aaf5526be81e352a5fa7ce4038ba39052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5526be81e352a5fa7ce4038ba39052">&#9670;&nbsp;</a></span>bodyHasBodySensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::bodyHasBodySensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the specified body has a body sensor attached to it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>Body to query </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf845c2c3a0f18430986e4a752f08fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf845c2c3a0f18430986e4a752f08fe7">&#9670;&nbsp;</a></span>bodyHasForceSensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::bodyHasForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the body has a force sensor directly attached to it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>Name of the body to which the sensor is directly attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>bodyHasIndirectForceSensor(const std::string &amp;) if you wish to check whether a <a class="el" href="structmc__rbdyn_1_1Robot.html#ac945ba1c44d9dfb2f2312d13c8ed24b4">sensor</a> is indirectly attached to a body</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the body has a force sensor attached to it, false otherwise </dd></dl>

</div>
</div>
<a id="af0f6539a36fe9c2e4dc05b1ef3765963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f6539a36fe9c2e4dc05b1ef3765963">&#9670;&nbsp;</a></span>bodyHasIndirectForceSensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::bodyHasIndirectForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the body has a force sensor attached to it (directly or indirectly)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>Name of the body to which the sensor is (directly or indirectly) attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the body has a force sensor attached to it, false otherwise </dd></dl>

</div>
</div>
<a id="a5309b5ef9bb5b91bf0f1adb59813bde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5309b5ef9bb5b91bf0f1adb59813bde4">&#9670;&nbsp;</a></span>bodyIndexByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mc_rbdyn::Robot::bodyIndexByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access MultiBody representation of the robot </p>

</div>
</div>
<a id="a7e9415aa6bf2421a5e76bd85b04359b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9415aa6bf2421a5e76bd85b04359b1">&#9670;&nbsp;</a></span>bodyPosW() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sva::PTransformd&gt;&amp; mc_rbdyn::Robot::bodyPosW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().bodyPosW (const) </p>

</div>
</div>
<a id="adf0aad75ddf11178d780abe0a64d7021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0aad75ddf11178d780abe0a64d7021">&#9670;&nbsp;</a></span>bodyPosW() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;sva::PTransformd&gt;&amp; mc_rbdyn::Robot::bodyPosW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().bodyPosW </p>

</div>
</div>
<a id="af7764d03bd41fedfa98443d4a0b262e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7764d03bd41fedfa98443d4a0b262e9">&#9670;&nbsp;</a></span>bodyPosW() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::PTransformd&amp; mc_rbdyn::Robot::bodyPosW </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the position of body <code>name</code> in world coordinates</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the body does not exist within the robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41b7c80447b0d61661bfc2a0242eaa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b7c80447b0d61661bfc2a0242eaa8f">&#9670;&nbsp;</a></span>bodySensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1BodySensor.html">BodySensor</a>&amp; mc_rbdyn::Robot::bodySensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the first <a class="el" href="structmc__rbdyn_1_1BodySensor.html">BodySensor</a> in the robot (const) </p>

</div>
</div>
<a id="a6e04286463ae6f91105c0b83ef370da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e04286463ae6f91105c0b83ef370da8">&#9670;&nbsp;</a></span>bodySensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1BodySensor.html">BodySensor</a>&amp; mc_rbdyn::Robot::bodySensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a specific BobySensor by name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the sensor does not exist </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc810f916462cb34c4126220f4f8a3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc810f916462cb34c4126220f4f8a3e9">&#9670;&nbsp;</a></span>bodySensors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacemc__rbdyn.html#a728d731db2806e7673f67b958970e558">BodySensorVector</a>&amp; mc_rbdyn::Robot::bodySensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return all body sensors (const) </p>

</div>
</div>
<a id="a91bd5ae09effe07a9a766050bcfee859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bd5ae09effe07a9a766050bcfee859">&#9670;&nbsp;</a></span>bodyTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::PTransformd&amp; mc_rbdyn::Robot::bodyTransform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access transformation from body <code>bName</code> to original base.</p>
<p>This can be used to correct transformations that were stored with the original base. Usually the robot's base is the original base so these transforms are identity. </p>

</div>
</div>
<a id="a022bd9c9318d298da53c823ca93b5f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022bd9c9318d298da53c823ca93b5f1c">&#9670;&nbsp;</a></span>bodyTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::PTransformd&amp; mc_rbdyn::Robot::bodyTransform </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bodyIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access body transform by index </p>

</div>
</div>
<a id="a135b6be808af82a5b0d21ffda5a8fe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135b6be808af82a5b0d21ffda5a8fe17">&#9670;&nbsp;</a></span>bodyTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sva::PTransformd&gt;&amp; mc_rbdyn::Robot::bodyTransforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access body transform vector </p>

</div>
</div>
<a id="ac4ce1f653158bc3b79dd903ee1c05d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ce1f653158bc3b79dd903ee1c05d9c">&#9670;&nbsp;</a></span>bodyVelB() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyVelB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().bodyVelB (const) </p>

</div>
</div>
<a id="a54b38b6bbe93a7b6cc48d9091e9ee8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b38b6bbe93a7b6cc48d9091e9ee8b5">&#9670;&nbsp;</a></span>bodyVelB() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyVelB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().bodyVelB </p>

</div>
</div>
<a id="a86619b4049ec59d383a445bafe43830e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86619b4049ec59d383a445bafe43830e">&#9670;&nbsp;</a></span>bodyVelB() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::MotionVecd&amp; mc_rbdyn::Robot::bodyVelB </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the velocity of body <code>name</code> in body coordinates</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the body doest not exist within the robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad1bcd2edaa8eeb17033ae3fafe1bde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1bcd2edaa8eeb17033ae3fafe1bde8">&#9670;&nbsp;</a></span>bodyVelW() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyVelW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().bodyVelW (const) </p>

</div>
</div>
<a id="a252c64f915ca619afcdcf27e9dd63dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252c64f915ca619afcdcf27e9dd63dd2">&#9670;&nbsp;</a></span>bodyVelW() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyVelW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().bodyVelW </p>

</div>
</div>
<a id="abc4808b0299894e9343b6c27b1cc6e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4808b0299894e9343b6c27b1cc6e14">&#9670;&nbsp;</a></span>bodyVelW() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::MotionVecd&amp; mc_rbdyn::Robot::bodyVelW </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the velocity of body <code>name</code> in world coordinates</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the body doest not exist within the robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a207f3ea22bce722a3d68ac37aed8ca03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207f3ea22bce722a3d68ac37aed8ca03">&#9670;&nbsp;</a></span>bodyWrench()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sva::ForceVecd mc_rbdyn::Robot::bodyWrench </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bodyName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the gravity-free wrench in body frame</p>
<dl class="section note"><dt>Note</dt><dd>If the body is indirectly attached to the sensor (i.e there are joints in-between), then the kinematic transformation will be taken into account but the effect of bodies in-between is not accounted for in the returned wrench.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bodyName</td><td>A body attached to a force sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Measured wrench in body frame</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is attached to this surface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af239b709cd1907f1aa264dfa2cb9fd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af239b709cd1907f1aa264dfa2cb9fd15">&#9670;&nbsp;</a></span>collisionTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::PTransformd&amp; mc_rbdyn::Robot::collisionTransform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access transformation between the collision mesh and the body </p>

</div>
</div>
<a id="a4e858c693b7e94ded9704e13463e1ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e858c693b7e94ded9704e13463e1ae5">&#9670;&nbsp;</a></span>com()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::com </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute and returns the current robot's CoM </p>

</div>
</div>
<a id="a68f1932b13b8a4589f66dd792522e1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f1932b13b8a4589f66dd792522e1ae">&#9670;&nbsp;</a></span>comAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::comAcceleration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute and returns the current robot's CoM acceleration </p>

</div>
</div>
<a id="aa17c3d6b4bff8b9bcbedad822a86fdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17c3d6b4bff8b9bcbedad822a86fdbc">&#9670;&nbsp;</a></span>comVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::comVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute and returns the current robot's CoM velocity </p>

</div>
</div>
<a id="a855db41e44bee30fa7f6ecabc87eba55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855db41e44bee30fa7f6ecabc87eba55">&#9670;&nbsp;</a></span>controlTorque() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::controlTorque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the desired control torque </p>

</div>
</div>
<a id="ac6da2c5953ec1e782c4ae965c463d7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6da2c5953ec1e782c4ae965c463d7d3">&#9670;&nbsp;</a></span>controlTorque() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::controlTorque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the desired control torque </p>

</div>
</div>
<a id="a7fa487585e4b6d447c69ba78d9eca203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa487585e4b6d447c69ba78d9eca203">&#9670;&nbsp;</a></span>convex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmc__rbdyn_1_1Robot.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a>&amp; mc_rbdyn::Robot::convex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access a convex named <code>cName</code> </p>
<dl class="section return"><dt>Returns</dt><dd>a pair giving the convex's parent body and the sch::Object object </dd></dl>

</div>
</div>
<a id="a2b2dc756cfb84c337de115384febab34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2dc756cfb84c337de115384febab34">&#9670;&nbsp;</a></span>convex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1Robot.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a>&amp; mc_rbdyn::Robot::convex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access a convex named <code>cName</code> (const) </p>

</div>
</div>
<a id="aa176323f1dd1dc8f29ad40ccd4b23c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa176323f1dd1dc8f29ad40ccd4b23c9d">&#9670;&nbsp;</a></span>convexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="structmc__rbdyn_1_1Robot.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a>&gt;&amp; mc_rbdyn::Robot::convexes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access all convexes available in this robot</p>
<dl class="section return"><dt>Returns</dt><dd>a map where keys are the convex name and values are those returned by <a class="el" href="structmc__rbdyn_1_1Robot.html#a7fa487585e4b6d447c69ba78d9eca203">convex</a> </dd></dl>

</div>
</div>
<a id="aa4679daa562a23a753a3f5f77daa9861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4679daa562a23a753a3f5f77daa9861">&#9670;&nbsp;</a></span>cop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector2d mc_rbdyn::Robot::cop </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_pressure</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the cop in a given frame computed from gravity-free force measurements</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>A frame attached to a force sensor </td></tr>
    <tr><td class="paramname">min_pressure</td><td>Minimum pressure in N (default 0.5N).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Measured cop in provided frame<ul>
<li>CoP if pressure &gt;= min_pressure</li>
<li>Zero otherwise</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the frame does not exist or no sensor is attached to this frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b7aa66da24521f280bbc2d9c16cdda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7aa66da24521f280bbc2d9c16cdda7">&#9670;&nbsp;</a></span>copW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::copW </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_pressure</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the cop in inertial frame compute from gravity-free force measurements</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>A frame attached to a force sensor </td></tr>
    <tr><td class="paramname">min_pressure</td><td>Minimum pressure in N (default 0.5N).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Measured cop in inertial frame<ul>
<li>CoP if pressure &gt;= min_pressure</li>
<li>Zero otherwise</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the frame does not exist or no sensor is attached to this frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2c28ca834c5d81e66f581425c2d7f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c28ca834c5d81e66f581425c2d7f16">&#9670;&nbsp;</a></span>copyLoadedData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::copyLoadedData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmc__rbdyn_1_1Robot.html">Robot</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy loaded data from this robot to a new robot </p>

</div>
</div>
<a id="a9eac94be22b1481eaae48d110d97c49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eac94be22b1481eaae48d110d97c49e">&#9670;&nbsp;</a></span>copySurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmc__rbdyn_1_1Surface.html">mc_rbdyn::Surface</a>&amp; mc_rbdyn::Robot::copySurface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy an existing surface with a new name </p>

</div>
</div>
<a id="af35e2fdc9ec56540b48e9bd5247c7b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35e2fdc9ec56540b48e9bd5247c7b2b">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacemc__rbdyn.html#a33ca728cc2ff802237e8135754f359a8">RobotDataPtr</a> mc_rbdyn::Robot::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the data associated to this object </p>

</div>
</div>
<a id="a4e3272e412d22bf6d382117300c9ee42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3272e412d22bf6d382117300c9ee42">&#9670;&nbsp;</a></span>device() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; mc_rbdyn::Robot::device </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a generic device of type T named name</p>
<p>The reference returned by this function is remains valid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the device requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the device does not exist or does not have the right type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cff71ca3ef36a1f5b5a945d6e70b64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cff71ca3ef36a1f5b5a945d6e70b64b">&#9670;&nbsp;</a></span>device() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; mc_rbdyn::Robot::device </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non-const variant </p>

</div>
</div>
<a id="ac554847320d3540e5e7ac9d58baafca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac554847320d3540e5e7ac9d58baafca0">&#9670;&nbsp;</a></span>devices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1DevicePtrVector.html">DevicePtrVector</a>&amp; mc_rbdyn::Robot::devices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get all devices attached to a robot </p>

</div>
</div>
<a id="a1da8134deea10a32f7d35fc381649606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da8134deea10a32f7d35fc381649606">&#9670;&nbsp;</a></span>encoderValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; mc_rbdyn::Robot::encoderValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the encoder values </p>

</div>
</div>
<a id="a8a2e3e0b4b0e226712007e9fe905f9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2e3e0b4b0e226712007e9fe905f9e9">&#9670;&nbsp;</a></span>encoderVelocities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; mc_rbdyn::Robot::encoderVelocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the encoder velocities </p>

</div>
</div>
<a id="acd1794c11cac282d7c042216d431ebb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1794c11cac282d7c042216d431ebb7">&#9670;&nbsp;</a></span>eulerIntegration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::eulerIntegration </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply Euler integration to the robot using <code>step</code> timestep </p>

</div>
</div>
<a id="ae8d130fc22dda8e9bfbecad28acc26a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d130fc22dda8e9bfbecad28acc26a5">&#9670;&nbsp;</a></span>eulerIntegration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::eulerIntegration </td>
          <td>(</td>
          <td class="paramtype">rbd::MultiBodyConfig &amp;&#160;</td>
          <td class="paramname"><em>mbc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply Euler integration to <code>mbc</code> using the robot's <a class="el" href="structmc__rbdyn_1_1Robot.html#a79bdab3efcd9ada4d2b3aefa53374af1">mb()</a> and <code>step</code> timestep </p>

</div>
</div>
<a id="affafbe491eaf05a4cc9aba0a371beac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affafbe491eaf05a4cc9aba0a371beac1">&#9670;&nbsp;</a></span>findBodyForceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a>* mc_rbdyn::Robot::findBodyForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a force sensor attached (directly or indirectly) to the given body</p>
<p>Returns a null pointer if no such sensor exists </p>

</div>
</div>
<a id="adec9236c7e0a6848e0fb76704ea64372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec9236c7e0a6848e0fb76704ea64372">&#9670;&nbsp;</a></span>findIndirectForceSensorBodyName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mc_rbdyn::Robot::findIndirectForceSensorBodyName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bodyName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the name of the body to which a force sensor is attached, starting from the provided body and going up the kinematic tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bodyName</td><td>Name of the body to which the sensor is attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Body name to which the sensor is attached when found. Empty string otherwise </dd></dl>

</div>
</div>
<a id="a005d9859a7272ac6dbcab9c31aef8092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005d9859a7272ac6dbcab9c31aef8092">&#9670;&nbsp;</a></span>fixCollisionTransforms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::fixCollisionTransforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to set the collision transforms correctly </p>

</div>
</div>
<a id="a3d3381189f816f8871e540555a533e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3381189f816f8871e540555a533e64">&#9670;&nbsp;</a></span>fixSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::fixSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmc__rbdyn_1_1Surface.html">Surface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to set the specified surface X_b_s correctly</p>
<p>This function should only be called once per surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaces</td><td><a class="el" href="structmc__rbdyn_1_1Surface.html">Surface</a> that need to be modified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a218dfb7dbc50f94466e30871869b967d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218dfb7dbc50f94466e30871869b967d">&#9670;&nbsp;</a></span>fixSurfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::fixSurfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to set all robot surfaces' X_b_s correctly</p>
<p>This updates all surfaces in surfaces_ vector and should only be called once </p>

</div>
</div>
<a id="adada908603cd6527095ccb940d6405bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adada908603cd6527095ccb940d6405bb">&#9670;&nbsp;</a></span>flexibility() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structmc__rbdyn_1_1Flexibility.html">Flexibility</a>&gt;&amp; mc_rbdyn::Robot::flexibility </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the flexibilities of the robot (const) </p>

</div>
</div>
<a id="a52b9f6334096f8f9534d4dfab3a89495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b9f6334096f8f9534d4dfab3a89495">&#9670;&nbsp;</a></span>flexibility() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structmc__rbdyn_1_1Flexibility.html">Flexibility</a>&gt;&amp; mc_rbdyn::Robot::flexibility </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the flexibilities of the robot </p>

</div>
</div>
<a id="a40d807280f230919ff00adf3d43a5caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d807280f230919ff00adf3d43a5caa">&#9670;&nbsp;</a></span>forceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a>&amp; mc_rbdyn::Robot::forceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a force sensor by name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sensor named name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor with this name exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3d3115ea3d21076f556ce974f299f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d3115ea3d21076f556ce974f299f0e">&#9670;&nbsp;</a></span>forceSensors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a>&gt;&amp; mc_rbdyn::Robot::forceSensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all force sensors (const) </p>

</div>
</div>
<a id="ab7c546ec0809807016d316229d1d29c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c546ec0809807016d316229d1d29c0">&#9670;&nbsp;</a></span>forwardAcceleration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardAcceleration </td>
          <td>(</td>
          <td class="paramtype">const sva::MotionVecd &amp;&#160;</td>
          <td class="paramname"><em>A_0</em> = <code>sva::MotionVecd(Eigen::Vector6d::Zero())</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply forward acceleration to the robot </p>

</div>
</div>
<a id="ad5564b8d60b3dd8fa3e88e31f8f93a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5564b8d60b3dd8fa3e88e31f8f93a02">&#9670;&nbsp;</a></span>forwardAcceleration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardAcceleration </td>
          <td>(</td>
          <td class="paramtype">rbd::MultiBodyConfig &amp;&#160;</td>
          <td class="paramname"><em>mbc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::MotionVecd &amp;&#160;</td>
          <td class="paramname"><em>A_0</em> = <code>sva::MotionVecd(Eigen::Vector6d::Zero())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply forward acceleration to <code>mbc</code> using the robot's <a class="el" href="structmc__rbdyn_1_1Robot.html#a79bdab3efcd9ada4d2b3aefa53374af1">mb()</a> </p>

</div>
</div>
<a id="ae46b693d4431e61db9f1d4a05f66dd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46b693d4431e61db9f1d4a05f66dd5e">&#9670;&nbsp;</a></span>forwardKinematics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardKinematics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply forward kinematics to the robot </p>

</div>
</div>
<a id="a9520af131693e9b873ce4c37513cfa1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9520af131693e9b873ce4c37513cfa1d">&#9670;&nbsp;</a></span>forwardKinematics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardKinematics </td>
          <td>(</td>
          <td class="paramtype">rbd::MultiBodyConfig &amp;&#160;</td>
          <td class="paramname"><em>mbc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply forward kinematics to <code>mbc</code> using the robot's <a class="el" href="structmc__rbdyn_1_1Robot.html#a79bdab3efcd9ada4d2b3aefa53374af1">mb()</a> </p>

</div>
</div>
<a id="afd93342dd86da6803288346a3798d374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd93342dd86da6803288346a3798d374">&#9670;&nbsp;</a></span>forwardVelocity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply forward velocity to the robot </p>

</div>
</div>
<a id="a73998aca81be7062371f39ce5d60756a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73998aca81be7062371f39ce5d60756a">&#9670;&nbsp;</a></span>forwardVelocity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardVelocity </td>
          <td>(</td>
          <td class="paramtype">rbd::MultiBodyConfig &amp;&#160;</td>
          <td class="paramname"><em>mbc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply forward velocity to <code>mbc</code> using the robot's <a class="el" href="structmc__rbdyn_1_1Robot.html#a79bdab3efcd9ada4d2b3aefa53374af1">mb()</a> </p>

</div>
</div>
<a id="ac68ae766d6de9d5f8740001ac10a62db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68ae766d6de9d5f8740001ac10a62db">&#9670;&nbsp;</a></span>frame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1RobotFrame.html">RobotFrame</a>&amp; mc_rbdyn::Robot::frame </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the frame named <code>name</code> </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the frame does not exist </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3d92cb0d6c4ba8c42ee9a35a7d56bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d92cb0d6c4ba8c42ee9a35a7d56bab">&#9670;&nbsp;</a></span>frame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmc__rbdyn_1_1RobotFrame.html">RobotFrame</a>&amp; mc_rbdyn::Robot::frame </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the frame named <code>name</code> (non-const)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the frame does not exist </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c6c471776005048105c48791df73ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6c471776005048105c48791df73ea5">&#9670;&nbsp;</a></span>frames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; mc_rbdyn::Robot::frames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the list of available frames in this robot </p>

</div>
</div>
<a id="a8b970df4059237f37021b47d5aaf2494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b970df4059237f37021b47d5aaf2494">&#9670;&nbsp;</a></span>gripper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmc__control_1_1Gripper.html">mc_control::Gripper</a>&amp; mc_rbdyn::Robot::gripper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gripper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access a gripper by name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gripper</td><td>Gripper name</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the gripper does not exist within this robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1c37bc25e3eb43bd7f040c252647e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c37bc25e3eb43bd7f040c252647e64">&#9670;&nbsp;</a></span>gripper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__control_1_1Gripper.html">mc_control::Gripper</a>&amp; mc_rbdyn::Robot::gripper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gripper</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access a gripper by name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gripper</td><td>Gripper name</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the gripper does not exist within this robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a461d76c25d7b7d24be8f73afa1471e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461d76c25d7b7d24be8f73afa1471e03">&#9670;&nbsp;</a></span>grippers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="namespacemc__control.html#a39b3dee4f4017bab0f389d9bfd7877dc">mc_control::GripperRef</a>&gt;&amp; mc_rbdyn::Robot::grippers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access all grippers </p>

</div>
</div>
<a id="ae446ae5052274ecd2b2c8d8a641d02c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae446ae5052274ecd2b2c8d8a641d02c2">&#9670;&nbsp;</a></span>grippersByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;std::string, <a class="el" href="namespacemc__control.html#a67d3b51822d3e7d0c56d9af675f9eaa1">mc_control::GripperPtr</a>&gt;&amp; mc_rbdyn::Robot::grippersByName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8353aa6a66630a85c9249298ed960c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8353aa6a66630a85c9249298ed960c6a">&#9670;&nbsp;</a></span>hasBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the robot has a body named <code>name</code> </p>

</div>
</div>
<a id="a52d953d97ba1f0fbeed5e208e78e3d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d953d97ba1f0fbeed5e208e78e3d97">&#9670;&nbsp;</a></span>hasBodySensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasBodySensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the robot has a body sensor named name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the body sensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75aa71c0145f03a620619e8fe8b96107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aa71c0145f03a620619e8fe8b96107">&#9670;&nbsp;</a></span>hasConvex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasConvex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a convex <code>name</code> exists</p>
<dl class="section return"><dt>Returns</dt><dd>True if the convex exists, false otherwise </dd></dl>

</div>
</div>
<a id="a607854d4b0275f088553d91bbcdc9905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607854d4b0275f088553d91bbcdc9905">&#9670;&nbsp;</a></span>hasDevice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasDevice </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if a generic device of type T and named name exists in the robot</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of device requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42615f6ac857b53acb4ae0376c3986c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42615f6ac857b53acb4ae0376c3986c7">&#9670;&nbsp;</a></span>hasForceSensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if a force sensor exists</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sensor exists, false otherwise </dd></dl>

</div>
</div>
<a id="a4dce036249f32a7cd0f0257956be990e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dce036249f32a7cd0f0257956be990e">&#9670;&nbsp;</a></span>hasFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasFrame </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the robot has a frame named <code>name</code> </p>

</div>
</div>
<a id="ae15e501f93c406e3ad5d19ab6904bd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15e501f93c406e3ad5d19ab6904bd4e">&#9670;&nbsp;</a></span>hasGripper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasGripper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gripper</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a gripper is part of this robot </p>

</div>
</div>
<a id="aafb78a38ec8b2037519f030140a95976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb78a38ec8b2037519f030140a95976">&#9670;&nbsp;</a></span>hasJoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasJoint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the robot has a joint named <code>name</code> </p>

</div>
</div>
<a id="a59d3c6669d54957b2bfd0125aaf83dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d3c6669d54957b2bfd0125aaf83dca">&#9670;&nbsp;</a></span>hasSensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structmc__rbdyn_1_1Robot.html#a607854d4b0275f088553d91bbcdc9905">hasDevice</a> </dd></dl>

</div>
</div>
<a id="a47874ad9d5abdcd85701b02e2c85cefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47874ad9d5abdcd85701b02e2c85cefb">&#9670;&nbsp;</a></span>hasSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasSurface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a surface <code>surface</code> exists</p>
<dl class="section return"><dt>Returns</dt><dd>True if the surface exists, false otherwise </dd></dl>

</div>
</div>
<a id="a0c2ceb538921611b7b50a50634859e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2ceb538921611b7b50a50634859e5f">&#9670;&nbsp;</a></span>indirectBodyForceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a>&amp; mc_rbdyn::Robot::indirectBodyForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a force sensor directly or indirectly attached to a body. </p>
<p>When the sensor is not directly attached to the body, look up the kinematic chain until the root until a sensor is found.</p>
<dl class="section return"><dt>Returns</dt><dd>The sensor to which the body is indirectly attached</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is found between the body and the root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77d7387d7242da1e7c42420583dce311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d7387d7242da1e7c42420583dce311">&#9670;&nbsp;</a></span>indirectSurfaceForceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a>&amp; mc_rbdyn::Robot::indirectSurfaceForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a force sensor directly or indirectly attached to a surface. </p>
<p>When the sensor is not directly attached to the surface, look up the kinematic chain until the root until a sensor is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>Name of surface indirectly attached to the sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sensor to which the surface is indirectly attached</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is found between the surface and the root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a890c6fcf28ad497b922aaff1b536968a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890c6fcf28ad497b922aaff1b536968a">&#9670;&nbsp;</a></span>jl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::jl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower jerk limits (const) </p>

</div>
</div>
<a id="a8f86bf8a4708ee63e116eb6bdd0f5bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f86bf8a4708ee63e116eb6bdd0f5bdf">&#9670;&nbsp;</a></span>jl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::jl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower jerk limits </p>

</div>
</div>
<a id="a8e27a5f9fb46fdf980254c4ac5761f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e27a5f9fb46fdf980254c4ac5761f94">&#9670;&nbsp;</a></span>jointHasJointSensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::jointHasJointSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>joint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the specified joint has a joint sensor attached to it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>Joint to query </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ad6afc9dd0267860a325771e7f87ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad6afc9dd0267860a325771e7f87ea1">&#9670;&nbsp;</a></span>jointIndexByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mc_rbdyn::Robot::jointIndexByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the joint index in the mbc of the joint with index jointIndex in refJointOrder</p>
<dl class="section note"><dt>Note</dt><dd>Joint indices can be -1 for joints present in refJointOrder but not in the robot's mbc (such as filtered joints in some robot modules)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jointIndex</td><td>Joint index in refJointOrder</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>joint index in the mbc</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>jointIndex &gt;= refJointOrder.size() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3662367cdf4edb974bdad793b1189b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3662367cdf4edb974bdad793b1189b20">&#9670;&nbsp;</a></span>jointIndexInMBC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mc_rbdyn::Robot::jointIndexInMBC </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>jointIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the joint index in the mbc of the joint with index jointIndex in refJointOrder</p>
<dl class="section note"><dt>Note</dt><dd>Joint indices can be -1 for joints present in refJointOrder but not in the robot's mbc (such as filtered joints in some robot modules)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jointIndex</td><td>Joint index in refJointOrder</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>joint index in the mbc</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>jointIndex &gt;= refJointOrder.size() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6354b734b171f226d1fadc9a12aeef31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6354b734b171f226d1fadc9a12aeef31">&#9670;&nbsp;</a></span>jointJointSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1JointSensor.html">JointSensor</a>&amp; mc_rbdyn::Robot::jointJointSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>joint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a specific <a class="el" href="structmc__rbdyn_1_1JointSensor.html">JointSensor</a> by joint name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>Name of the joint</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>there is no sensor attached to the joint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06bea736214045982c99b3c70e660ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bea736214045982c99b3c70e660ae1">&#9670;&nbsp;</a></span>jointSensors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structmc__rbdyn_1_1JointSensor.html">JointSensor</a>&gt;&amp; mc_rbdyn::Robot::jointSensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return all joint sensors (const) </p>

</div>
</div>
<a id="a95798f9588d0656c61558ab20ad935b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95798f9588d0656c61558ab20ad935b4">&#9670;&nbsp;</a></span>jointTorque() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::jointTorque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().jointTorque (const) </p>

</div>
</div>
<a id="af946d00c2f9e36ed5c0899f237f35c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af946d00c2f9e36ed5c0899f237f35c32">&#9670;&nbsp;</a></span>jointTorque() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::jointTorque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().jointTorque </p>

</div>
</div>
<a id="af65b1b51c93d319952e2ae3965e204c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65b1b51c93d319952e2ae3965e204c8">&#9670;&nbsp;</a></span>jointTorques()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; mc_rbdyn::Robot::jointTorques </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the joint torques from sensors </p>

</div>
</div>
<a id="a112f8dbb672b9911d63f479d57525241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112f8dbb672b9911d63f479d57525241">&#9670;&nbsp;</a></span>ju() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::ju </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper jerk limits (const) </p>

</div>
</div>
<a id="a28c3d7ef8c743eebe234bf8f4fd418e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c3d7ef8c743eebe234bf8f4fd418e8">&#9670;&nbsp;</a></span>ju() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::ju </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper jerk limits </p>

</div>
</div>
<a id="a1554209253be449c1fb4cdd7e3d2478d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1554209253be449c1fb4cdd7e3d2478d">&#9670;&nbsp;</a></span>loadRSDFFromDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::loadRSDFFromDir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surfaceDir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load surfaces from the directory <code>surfaceDir</code> </p>

</div>
</div>
<a id="ad4db0746e4af259c63c288695f72beac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4db0746e4af259c63c288695f72beac">&#9670;&nbsp;</a></span>makeFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmc__rbdyn_1_1RobotFrame.html">RobotFrame</a>&amp; mc_rbdyn::Robot::makeFrame </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmc__rbdyn_1_1RobotFrame.html">RobotFrame</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sva::PTransformd&#160;</td>
          <td class="paramname"><em>X_p_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>baked</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new frame attached to this robot</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the frame</td></tr>
    <tr><td class="paramname">frame</td><td>Parent frame of this frame</td></tr>
    <tr><td class="paramname">X_p_f</td><td>Transformation from the parent frame to the frame</td></tr>
    <tr><td class="paramname">baked</td><td>Attach the newly created frame to <code>parent</code> parent's body rather than <code>parent</code> if true</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created frame</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td><code>parent</code> does not belong to this robot or if <code>name</code> already exists in this robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab70f3348aeda8560aa5740227eba3e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70f3348aeda8560aa5740227eba3e1f">&#9670;&nbsp;</a></span>makeFrames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::makeFrames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structmc__rbdyn_1_1RobotModule_1_1FrameDescription.html">mc_rbdyn::RobotModule::FrameDescription</a> &gt;&#160;</td>
          <td class="paramname"><em>frames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create new frames attached to this robot</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frames</td><td>Description of the frames</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>any of the frames' <code>parent</code> does not belong to this robot or if <code>name</code> already exists in this robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa59b1b6223978e23cb2ea636ddee0ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59b1b6223978e23cb2ea636ddee0ceb">&#9670;&nbsp;</a></span>makeTemporaryFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemc__rbdyn.html#a5a52a2394099019321a0411da30ea5f4">RobotFramePtr</a> mc_rbdyn::Robot::makeTemporaryFrame </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmc__rbdyn_1_1RobotFrame.html">RobotFrame</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sva::PTransformd&#160;</td>
          <td class="paramname"><em>X_p_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>baked</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new temporary frame</p>
<p>The frame is not kept by the robot and cannot be found via <a class="el" href="structmc__rbdyn_1_1Robot.html#ac68ae766d6de9d5f8740001ac10a62db">frame</a> or inside <a class="el" href="structmc__rbdyn_1_1Robot.html#a8c6c471776005048105c48791df73ea5">frames</a></p>
<p>The main purpose is to tie a frame lifetime to another object (e.g. a task, a constraint, a state...) that needs it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the frame</td></tr>
    <tr><td class="paramname">frame</td><td>Parent frame of this frame</td></tr>
    <tr><td class="paramname">X_p_f</td><td>Transformation from the parent frame to the frame</td></tr>
    <tr><td class="paramname">baked</td><td>Attach the newly created frame to <code>parent</code> parent's body rather than <code>parent</code> if true</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created frame</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td><code>parent</code> does not belong to this robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa368e46d6f3d90f8f4eca437358148f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa368e46d6f3d90f8f4eca437358148f8">&#9670;&nbsp;</a></span>mass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mc_rbdyn::Robot::mass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and returns the mass of the robot </p>

</div>
</div>
<a id="a79bdab3efcd9ada4d2b3aefa53374af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bdab3efcd9ada4d2b3aefa53374af1">&#9670;&nbsp;</a></span>mb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rbd::MultiBody&amp; mc_rbdyn::Robot::mb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access MultiBody representation of the robot </p>

</div>
</div>
<a id="ab09b1765903debcc06dce65ce830cfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09b1765903debcc06dce65ce830cfc0">&#9670;&nbsp;</a></span>mb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rbd::MultiBody&amp; mc_rbdyn::Robot::mb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access MultiBody representation of the robot (const) </p>

</div>
</div>
<a id="a0051e9ce612a34601d6934f7d5caaeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0051e9ce612a34601d6934f7d5caaeb4">&#9670;&nbsp;</a></span>mbc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rbd::MultiBodyConfig&amp; mc_rbdyn::Robot::mbc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access MultiBodyConfig of the robot's <a class="el" href="structmc__rbdyn_1_1Robot.html#a79bdab3efcd9ada4d2b3aefa53374af1">mb()</a> </p>

</div>
</div>
<a id="aece5a00f65317b116f70ed2937239421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece5a00f65317b116f70ed2937239421">&#9670;&nbsp;</a></span>mbc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rbd::MultiBodyConfig&amp; mc_rbdyn::Robot::mbc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access MultiBodyConfig of the robot's <a class="el" href="structmc__rbdyn_1_1Robot.html#a79bdab3efcd9ada4d2b3aefa53374af1">mb()</a> (const) </p>

</div>
</div>
<a id="a900ba960e115fa967889ebdb842f6a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900ba960e115fa967889ebdb842f6a3e">&#9670;&nbsp;</a></span>mbg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rbd::MultiBodyGraph&amp; mc_rbdyn::Robot::mbg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access MultiBodyGraph that generated the robot's <a class="el" href="structmc__rbdyn_1_1Robot.html#a79bdab3efcd9ada4d2b3aefa53374af1">mb()</a> </p>

</div>
</div>
<a id="a78336b8d90c933da75cd138227072321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78336b8d90c933da75cd138227072321">&#9670;&nbsp;</a></span>mbg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rbd::MultiBodyGraph&amp; mc_rbdyn::Robot::mbg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access MultiBodyGraph that generated the robot's <a class="el" href="structmc__rbdyn_1_1Robot.html#a79bdab3efcd9ada4d2b3aefa53374af1">mb()</a> (const) </p>

</div>
</div>
<a id="a3e734d771ca6cf96801de8765cee637d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e734d771ca6cf96801de8765cee637d">&#9670;&nbsp;</a></span>module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1RobotModule.html">RobotModule</a>&amp; mc_rbdyn::Robot::module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the associated <a class="el" href="structmc__rbdyn_1_1RobotModule.html">RobotModule</a> </p>

</div>
</div>
<a id="a9f0c4c44861063b684d43d4ad78a995e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0c4c44861063b684d43d4ad78a995e">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; mc_rbdyn::Robot::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of the robot</p>
<dl class="section note"><dt>Note</dt><dd>To rename a robot, use <a class="el" href="structmc__rbdyn_1_1Robots.html#a2dc538d2351dacdde105943658330f39">Robots::rename(const std::string &amp;, const std::string &amp;)</a> </dd></dl>

</div>
</div>
<a id="a117494f13e48578a752a102e322189b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117494f13e48578a752a102e322189b0">&#9670;&nbsp;</a></span>netWrench()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sva::ForceVecd mc_rbdyn::Robot::netWrench </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sensorNames</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes net total wrench from a list of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorNames</td><td>Names of all sensors used to compute the net wrench</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Net total wrench (without gravity) in the inertial frame </dd></dl>

</div>
</div>
<a id="a410eefe8c059340207a45a1d79be6221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410eefe8c059340207a45a1d79be6221">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmc__rbdyn_1_1Robot.html">Robot</a>&amp; mc_rbdyn::Robot::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmc__rbdyn_1_1Robot.html">Robot</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48843047df8893808f80971fa3f9257f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48843047df8893808f80971fa3f9257f">&#9670;&nbsp;</a></span>posW() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::PTransformd&amp; mc_rbdyn::Robot::posW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the robot's global pose </p>

</div>
</div>
<a id="a54fe0da3fe099906b79cb20de8076659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fe0da3fe099906b79cb20de8076659">&#9670;&nbsp;</a></span>posW() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::posW </td>
          <td>(</td>
          <td class="paramtype">const sva::PTransformd &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the robot's global pose. This is mostly meant for initialization purposes. In other scenarios there might be more things to do to properly move a robot (e.g. update contacts, set speed to zero).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>The new global pose</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>joint(0) is neither free flyer nor fixed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function takes care of calling rbd::forwardKinematics </dd></dl>

</div>
</div>
<a id="a485eb8aa4ceb0a0a5010844d16e47f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485eb8aa4ceb0a0a5010844d16e47f95">&#9670;&nbsp;</a></span>q() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().q (const) </p>

</div>
</div>
<a id="a8ad8d3434a21adb16f8c41a5444ea067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad8d3434a21adb16f8c41a5444ea067">&#9670;&nbsp;</a></span>q() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to robot.mbc().q </p>

</div>
</div>
<a id="ac18cb6ecabada0aac1f823b7e9170308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18cb6ecabada0aac1f823b7e9170308">&#9670;&nbsp;</a></span>ql() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::ql </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower limits (const) </p>

</div>
</div>
<a id="afc061e1b33c4f633a04015ab3fb20f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc061e1b33c4f633a04015ab3fb20f94">&#9670;&nbsp;</a></span>ql() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::ql </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower limits </p>

</div>
</div>
<a id="ac42c2ce3eea4e1100b4fc77b95821021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42c2ce3eea4e1100b4fc77b95821021">&#9670;&nbsp;</a></span>qu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::qu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper limits (const) </p>

</div>
</div>
<a id="ac6915de62543382030defd22b9f8011c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6915de62543382030defd22b9f8011c">&#9670;&nbsp;</a></span>qu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::qu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper limits </p>

</div>
</div>
<a id="a00856f04c24c914b9197fe11f2d573eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00856f04c24c914b9197fe11f2d573eb">&#9670;&nbsp;</a></span>refJointOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; mc_rbdyn::Robot::refJointOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the reference joint order for this robot </p>

</div>
</div>
<a id="a3296b923f06db47d80641b7acf46e5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3296b923f06db47d80641b7acf46e5bf">&#9670;&nbsp;</a></span>removeConvex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::removeConvex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a given convex</p>
<p>Using this function while the given convex is involved in a collision is <em>not</em> safe and will very likely result in a crash.</p>
<p>This has no effect if <code>name</code> is not a convex of the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the convex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af110c909887516af9f6758118978b643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af110c909887516af9f6758118978b643">&#9670;&nbsp;</a></span>robotIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mc_rbdyn::Robot::robotIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's index in <a class="el" href="structmc__rbdyn_1_1Robot.html#a4a2161c1f89c0b9e3a812ca390ff7666">robots()</a> </p>

</div>
</div>
<a id="a4a2161c1f89c0b9e3a812ca390ff7666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2161c1f89c0b9e3a812ca390ff7666">&#9670;&nbsp;</a></span>robots() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmc__rbdyn_1_1Robots.html">mc_rbdyn::Robots</a>&amp; mc_rbdyn::Robot::robots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access <a class="el" href="structmc__rbdyn_1_1Robots.html">Robots</a> instance this instance belongs to </p>

</div>
</div>
<a id="a6c413ebff3be3f588eff569106ba4426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c413ebff3be3f588eff569106ba4426">&#9670;&nbsp;</a></span>robots() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1Robots.html">mc_rbdyn::Robots</a>&amp; mc_rbdyn::Robot::robots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access <a class="el" href="structmc__rbdyn_1_1Robots.html">Robots</a> instance this instance belongs to (const) </p>

</div>
</div>
<a id="ac945ba1c44d9dfb2f2312d13c8ed24b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac945ba1c44d9dfb2f2312d13c8ed24b4">&#9670;&nbsp;</a></span>sensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; mc_rbdyn::Robot::sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structmc__rbdyn_1_1Robot.html#a4e3272e412d22bf6d382117300c9ee42">device</a> </dd></dl>

</div>
</div>
<a id="a72a8bd2c7daead0016449a6056fd2035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a8bd2c7daead0016449a6056fd2035">&#9670;&nbsp;</a></span>sensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; mc_rbdyn::Robot::sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structmc__rbdyn_1_1Robot.html#a4e3272e412d22bf6d382117300c9ee42">device</a> </dd></dl>

</div>
</div>
<a id="ac4b932fc4c4956b16490006dd8591d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b932fc4c4956b16490006dd8591d0e">&#9670;&nbsp;</a></span>stance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;double&gt; &gt; mc_rbdyn::Robot::stance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the robot's default stance (e.g. half-sitting for humanoid) </p>

</div>
</div>
<a id="aa4b724e51881215dd4293f9578656755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b724e51881215dd4293f9578656755">&#9670;&nbsp;</a></span>surface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmc__rbdyn_1_1Surface.html">mc_rbdyn::Surface</a>&amp; mc_rbdyn::Robot::surface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access a surface by its name <code>sName</code> </p>

</div>
</div>
<a id="a032e4252cb8c2c1d2ab82bd353b1cfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032e4252cb8c2c1d2ab82bd353b1cfb2">&#9670;&nbsp;</a></span>surface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1Surface.html">mc_rbdyn::Surface</a>&amp; mc_rbdyn::Robot::surface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access a surface by its name <code>sName</code> (const) </p>

</div>
</div>
<a id="ace64ab0161e9b00e262b408733d19629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace64ab0161e9b00e262b408733d19629">&#9670;&nbsp;</a></span>surfaceForceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a>&amp; mc_rbdyn::Robot::surfaceForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surfaceName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a force sensor attached to the provided surface</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>Name of the surface to which the sensor is attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attached sensor</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is directly attached to this surface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structmc__rbdyn_1_1ForceSensor.html">ForceSensor</a> &amp; indirectBodyForceSensor(const std::string &amp; surface); To get a <a class="el" href="structmc__rbdyn_1_1Robot.html#ac945ba1c44d9dfb2f2312d13c8ed24b4">sensor</a> directly or indirectly attached to the <a class="el" href="structmc__rbdyn_1_1Robot.html#aa4b724e51881215dd4293f9578656755">surface</a>. </dd></dl>

</div>
</div>
<a id="a7fb66cf0e07c2f24d9329cce0f6e5d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb66cf0e07c2f24d9329cce0f6e5d3b">&#9670;&nbsp;</a></span>surfaceHasForceSensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::surfaceHasForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the surface has a force sensor directly attached to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>Name of the surface to which the sensor is directly attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>surfaceHasIndirectForceSensor(const std::string &amp;) if you wish to check whether a <a class="el" href="structmc__rbdyn_1_1Robot.html#ac945ba1c44d9dfb2f2312d13c8ed24b4">sensor</a> is indirectly attached to a body</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td><code>surface</code> does not exist in this robot</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the surface has a force sensor attached to it, false otherwise </dd></dl>

</div>
</div>
<a id="ae05708ca15a7afb1c1b24315f4468356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05708ca15a7afb1c1b24315f4468356">&#9670;&nbsp;</a></span>surfaceHasIndirectForceSensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::surfaceHasIndirectForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the surface has a force sensor attached to it (directly or indirectly)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>Name of the surface to which the sensor is directly attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the surface has a force sensor attached to it, false otherwise </dd></dl>

</div>
</div>
<a id="a0c21632fb2dc076e87cc4f4b6f840ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c21632fb2dc076e87cc4f4b6f840ddb">&#9670;&nbsp;</a></span>surfacePose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sva::PTransformd mc_rbdyn::Robot::surfacePose </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pose of a surface frame with respect to the inertial frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sName</td><td>Name of surface frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee61e66a131e6f3e24982d4c68ffe958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee61e66a131e6f3e24982d4c68ffe958">&#9670;&nbsp;</a></span>surfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="namespacemc__rbdyn.html#a848cf0b2e8f6ca6f18ceba1769d9a426">mc_rbdyn::SurfacePtr</a>&gt;&amp; mc_rbdyn::Robot::surfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all available surfaces </p>

</div>
</div>
<a id="a928b9370f7643511d1ec80892245fb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928b9370f7643511d1ec80892245fb88">&#9670;&nbsp;</a></span>surfaceWrench()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sva::ForceVecd mc_rbdyn::Robot::surfaceWrench </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surfaceName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the gravity-free wrench in surface frame</p>
<dl class="section note"><dt>Note</dt><dd>If the surface is indirectly attached to the sensor (i.e there are joints in-between), then the kinematic transformation will be taken into account but the effect of bodies in-between is not accounted for in the returned wrench.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceName</td><td>A surface attached to a force sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Measured wrench in surface frame</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is attached to this surface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fa7e717817cab5e190f17d0397ff934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa7e717817cab5e190f17d0397ff934">&#9670;&nbsp;</a></span>tdl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tdl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower torque-derivative limits (const) </p>

</div>
</div>
<a id="a39a5fe0d5e143aae2d95ba39e56ab0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a5fe0d5e143aae2d95ba39e56ab0a9">&#9670;&nbsp;</a></span>tdl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tdl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower torque-derivative limits </p>

</div>
</div>
<a id="a2607ecfbe200094f4bba59ac7c5c390d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2607ecfbe200094f4bba59ac7c5c390d">&#9670;&nbsp;</a></span>tdu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tdu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper torque-derivative limits (const) </p>

</div>
</div>
<a id="a77a7831e452c28f863abba6992990ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a7831e452c28f863abba6992990ac8">&#9670;&nbsp;</a></span>tdu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tdu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper torque-derivative limits </p>

</div>
</div>
<a id="afd4cbabd88c9ee4565a2555dcc0208ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4cbabd88c9ee4565a2555dcc0208ae">&#9670;&nbsp;</a></span>tl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower torque limits (const) </p>

</div>
</div>
<a id="adf6dfded6aa9e9c6ca6ff6d8e386b66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6dfded6aa9e9c6ca6ff6d8e386b66d">&#9670;&nbsp;</a></span>tl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower torque limits </p>

</div>
</div>
<a id="a74f8c3970a3aff460fc5abad5b493eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f8c3970a3aff460fc5abad5b493eb6">&#9670;&nbsp;</a></span>tu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper torque limits (const) </p>

</div>
</div>
<a id="afe854537bd0f1fb8ab64ce91f5f6105d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe854537bd0f1fb8ab64ce91f5f6105d">&#9670;&nbsp;</a></span>tu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper torque limits </p>

</div>
</div>
<a id="a1f10151a30f06aafd99ecb2ed7b2738e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f10151a30f06aafd99ecb2ed7b2738e">&#9670;&nbsp;</a></span>tvmConvex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmc__tvm_1_1Convex.html">mc_tvm::Convex</a>&amp; mc_rbdyn::Robot::tvmConvex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the TVM convex associated to this robot convex</p>
<p>FIXME Returns a non-const reference from a const method because it is most often used to register dependencies between TVM nodes which require non-const objects</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the convex</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the convex does not exist </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8ceee5e97be39dced4c2fc1e1d32a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ceee5e97be39dced4c2fc1e1d32a7d">&#9670;&nbsp;</a></span>tvmRobot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmc__tvm_1_1Robot.html">mc_tvm::Robot</a>&amp; mc_rbdyn::Robot::tvmRobot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the TVM robot associated to this robot</p>
<p>FIXME Returns a non-const reference from a const method because it is most often used to register dependencies between TVM nodes which require non-const objects </p>

</div>
</div>
<a id="a50f3f6250f68bac91a2594e9e6383b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f3f6250f68bac91a2594e9e6383b2f">&#9670;&nbsp;</a></span>velW() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::velW </td>
          <td>(</td>
          <td class="paramtype">const sva::MotionVecd &amp;&#160;</td>
          <td class="paramname"><em>vel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the robot's floating base velocity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vel</td><td>New floating base velocity in the inertial frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function takes care of calling rbd::forwardVelocity </dd></dl>

</div>
</div>
<a id="a38618f0ff197fccef53069f51e9fcafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38618f0ff197fccef53069f51e9fcafc">&#9670;&nbsp;</a></span>velW() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::MotionVecd&amp; mc_rbdyn::Robot::velW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the robot's floating base velocity expressed in the inertial frame </p>

</div>
</div>
<a id="ab63444fe66136d722426aca78449d62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63444fe66136d722426aca78449d62a">&#9670;&nbsp;</a></span>vl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::vl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower velocity limits (const) </p>

</div>
</div>
<a id="a8a8dbaec40be4ad0be51f4df67502d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8dbaec40be4ad0be51f4df67502d39">&#9670;&nbsp;</a></span>vl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::vl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular lower velocity limits </p>

</div>
</div>
<a id="ac77b8ab43b004940508945dcb1234e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77b8ab43b004940508945dcb1234e60">&#9670;&nbsp;</a></span>vu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::vu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper velocity limits (const) </p>

</div>
</div>
<a id="ae6c3ad6f7d81353b09689ea6e41eec34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c3ad6f7d81353b09689ea6e41eec34">&#9670;&nbsp;</a></span>vu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::vu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the robot's angular upper velocity limits </p>

</div>
</div>
<a id="a76547cf0aab26354dad897265d6060ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76547cf0aab26354dad897265d6060ee">&#9670;&nbsp;</a></span>X_b1_b2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sva::PTransformd mc_rbdyn::Robot::X_b1_b2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Relative transformation X_b1_b2 from body b1 to body b2</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>name of first body </td></tr>
    <tr><td class="paramname">b2</td><td>name of second body </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>b1 or b2 does not exist within the robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4">&#9670;&nbsp;</a></span>zmp() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">const sva::ForceVecd &amp;&#160;</td>
          <td class="paramname"><em>netTotalWrench</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actual ZMP computation from net total wrench and the ZMP plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netTotalWrench</td><td>Total wrench for all links in contact </td></tr>
    <tr><td class="paramname">plane_p</td><td>Arbitrary point on the ZMP plane </td></tr>
    <tr><td class="paramname">plane_n</td><td>Normal to the ZMP plane (normalized) </td></tr>
    <tr><td class="paramname">minimalNetNormalForce[N]</td><td>Mininal force above which the ZMP computation is considered valid. Must be &gt;0 (prevents a divide by zero).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zmp expressed in the requested plane</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">To</td><td>prevent dividing by zero, throws if the projected force is below minimalNetNormalForce newton. This is highly unlikely to happen and would likely indicate indicate that you are computing a ZMP from invalid forces (such as with the robot in the air).</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="zmpDoc"></a> </p><dl class="section see"><dt>See also</dt><dd>Eigen::Vector3d <a class="el" href="namespacemc__rbdyn.html#a329453006944dae96fa60d86dca66db8" title="Actual ZMP computation from net total wrench and the ZMP plane. ">mc_rbdyn::zmp</a>(const sva::ForceVecd &amp; netTotalWrench, const Eigen::Vector3d &amp; plane_p, const Eigen::Vector3d &amp; plane_n, double minimalNetNormalForce) </dd></dl>

</div>
</div>
<a id="acfcb02ade95368eba497ffab50bab0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcb02ade95368eba497ffab50bab0d2">&#9670;&nbsp;</a></span>zmp() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>zmpOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::ForceVecd &amp;&#160;</td>
          <td class="paramname"><em>netTotalWrench</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actual ZMP computation from net total wrench and the ZMP plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zmpOut</td><td>Output of the ZMP computation expressed in the requested frame </td></tr>
    <tr><td class="paramname">netTotalWrench</td><td>Total wrench for all links in contact </td></tr>
    <tr><td class="paramname">plane_p</td><td>Arbitrary point on the ZMP plane </td></tr>
    <tr><td class="paramname">plane_n</td><td>Normal to the ZMP plane (normalized) </td></tr>
    <tr><td class="paramname">minimalNetNormalForce[N]</td><td>Mininal force above which the ZMP computation is considered valid. Must be &gt;0 (prevents a divide by zero).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the computation was successful, false otherwise and <code>zmpOut</code> is untouched</dd></dl>
<dl class="section see"><dt>See also</dt><dd>bool <a class="el" href="namespacemc__rbdyn.html#a329453006944dae96fa60d86dca66db8" title="Actual ZMP computation from net total wrench and the ZMP plane. ">mc_rbdyn::zmp</a>(Eigen::Vector3d &amp; zmpOut, const sva::ForceVecd &amp; netTotalWrench, const Eigen::Vector3d &amp; plane_p, const Eigen::Vector3d &amp; plane_n, double minimalNetNormalForce) </dd></dl>

</div>
</div>
<a id="aca98040d3ecdb597c65f3615a06d588d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca98040d3ecdb597c65f3615a06d588d">&#9670;&nbsp;</a></span>zmp() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">const sva::ForceVecd &amp;&#160;</td>
          <td class="paramname"><em>netTotalWrench</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::PTransformd &amp;&#160;</td>
          <td class="paramname"><em>zmpFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZMP computation from net total wrench and a frame. </p>
<p>See <a class="el" href="namespacemc__rbdyn.html#zmpDoc">zmpDoc</a></p>
<dl class="section see"><dt>See also</dt><dd>Eigen::Vector3d <a class="el" href="namespacemc__rbdyn.html#a329453006944dae96fa60d86dca66db8" title="Actual ZMP computation from net total wrench and the ZMP plane. ">mc_rbdyn::zmp</a>(const sva::ForceVecd &amp; netTotalWrench, const sva::PTransformd &amp; zmpFrame, double minimalNetNormalForce) const;</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netTotalWrench</td><td></td></tr>
    <tr><td class="paramname">zmpFrame</td><td><a class="el" href="structmc__rbdyn_1_1Frame.html">Frame</a> used for ZMP computation. The convention here is that the contact frame should have its z-axis pointing in the normal direction of the contact towards the robot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ZMP expressed in the plane defined by the zmpFrame frame. </dd></dl>

</div>
</div>
<a id="aa2224fc6a6299e9ed0ec8fdd8f3b3d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2224fc6a6299e9ed0ec8fdd8f3b3d4c">&#9670;&nbsp;</a></span>zmp() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>zmpOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::ForceVecd &amp;&#160;</td>
          <td class="paramname"><em>netTotalWrench</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::PTransformd &amp;&#160;</td>
          <td class="paramname"><em>zmpFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ZMP computation from net total wrench and a frame. </p>
<p>See <a class="el" href="namespacemc__rbdyn.html#zmpDoc">zmpDoc</a></p>
<dl class="section see"><dt>See also</dt><dd>Eigen::Vector3d <a class="el" href="namespacemc__rbdyn.html#a329453006944dae96fa60d86dca66db8" title="Actual ZMP computation from net total wrench and the ZMP plane. ">mc_rbdyn::zmp</a>(Eigen::Vector3d &amp; zmpOut, const sva::ForceVecd &amp; netTotalWrench, const sva::PTransformd &amp; zmpFrame, double minimalNetNormalForce)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zmpOut</td><td>Output of the ZMP computation expressed in the plane defined by the zmpFrame frame </td></tr>
    <tr><td class="paramname">netTotalWrench</td><td></td></tr>
    <tr><td class="paramname">zmpFrame</td><td><a class="el" href="structmc__rbdyn_1_1Frame.html">Frame</a> used for ZMP computation. The convention here is that the contact frame should have its z-axis pointing in the normal direction of the contact towards the robot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the computation was successful, false otherwise and <code>zmpOut</code> is untouched </dd></dl>

</div>
</div>
<a id="a472551d6b434e3e5a2239b35cffc639b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472551d6b434e3e5a2239b35cffc639b">&#9670;&nbsp;</a></span>zmp() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sensorNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the ZMP from sensor names and a plane</p>
<p>See <a class="el" href="namespacemc__rbdyn.html#zmpDoc">zmpDoc</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorNames</td><td>Names of all sensors attached to a link in contact with the environment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4348f47e45430a9ed99a00c2940e2f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4348f47e45430a9ed99a00c2940e2f00">&#9670;&nbsp;</a></span>zmp() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>zmpOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sensorNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the ZMP from sensor names and a plane</p>
<p>See <a class="el" href="namespacemc__rbdyn.html#zmpDoc">zmpDoc</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorNames</td><td>Names of all sensors attached to a link in contact with the environment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b62d2a94e3c81f2c436828bc9ed5186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b62d2a94e3c81f2c436828bc9ed5186">&#9670;&nbsp;</a></span>zmp() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sensorNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::PTransformd &amp;&#160;</td>
          <td class="paramname"><em>zmpFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the ZMP from sensor names and a frame. </p>
<p>See <a class="el" href="namespacemc__rbdyn.html#zmpDoc">zmpDoc</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorNames</td><td>Names of all sensors attached to a link in contact with the environment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8c0589359353a2d34b5f4331fa32793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c0589359353a2d34b5f4331fa32793">&#9670;&nbsp;</a></span>zmp() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>zmpOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sensorNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::PTransformd &amp;&#160;</td>
          <td class="paramname"><em>zmpFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the ZMP from sensor names and a frame. </p>
<p>See <a class="el" href="namespacemc__rbdyn.html#zmpDoc">zmpDoc</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorNames</td><td>Names of all sensors attached to a link in contact with the environment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad70ad9c81c418baf93ecccd6a75ff12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70ad9c81c418baf93ecccd6a75ff12f">&#9670;&nbsp;</a></span>zmpTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::zmpTarget </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>zmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the target zmp defined with respect to base-link. This target is intended to be used by an external stabilizer such as Kawada's</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zmp</td><td>Note that usually the ZMP is a 2-vector assuming a perfectly flat ground. The convention here is that the ground is at (tz=0). Therefore the target zmp should be defined as (ZMPx, ZMPy, -zbaselink) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fa1d2571113230a15a6726fb06b91fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa1d2571113230a15a6726fb06b91fa">&#9670;&nbsp;</a></span>zmpTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3d&amp; mc_rbdyn::Robot::zmpTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the target zmp</p>
<dl class="section return"><dt>Returns</dt><dd>Target ZMP. See zmpTarget(Eigen::Vector3d) for details. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a7ea6242bb22401bac23542e1db3a74ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea6242bb22401bac23542e1db3a74ed">&#9670;&nbsp;</a></span>Robots</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structmc__rbdyn_1_1Robots.html">Robots</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/mc_rbdyn/<a class="el" href="mc__rbdyn_2Robot_8h_source.html">Robot.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemc__rbdyn.html">mc_rbdyn</a></li><li class="navelem"><a class="el" href="structmc__rbdyn_1_1Robot.html">Robot</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
