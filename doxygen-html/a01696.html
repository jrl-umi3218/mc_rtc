<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>mc_rbdyn::Robot Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script>
<script src="MathJax/MathJax.js"></script>
<!-- To use the latest MathJax version instead, you can use: -->
<!--<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a01696.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a01693.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mc_rbdyn::Robot Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;mc_rbdyn/Robot.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a28270fdeec598bc23d8761191a6226d4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a28270fdeec598bc23d8761191a6226d4">S_ObjectPtr</a> = std::shared_ptr&lt; sch::S_Object &gt;</td></tr>
<tr class="separator:a28270fdeec598bc23d8761191a6226d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf56b7bf79a4e2be37e3c8615d156ad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a> = std::pair&lt; std::string, <a class="el" href="a01696.html#a28270fdeec598bc23d8761191a6226d4">S_ObjectPtr</a> &gt;</td></tr>
<tr class="separator:aeaf56b7bf79a4e2be37e3c8615d156ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a023a2a4a841760ae65a2d868bb6139fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a023a2a4a841760ae65a2d868bb6139fa">Robot</a> (<a class="el" href="a01696.html">Robot</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a023a2a4a841760ae65a2d868bb6139fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0f6aac369cb793546b62a13809a897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01696.html">Robot</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a2e0f6aac369cb793546b62a13809a897">operator=</a> (<a class="el" href="a01696.html">Robot</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a2e0f6aac369cb793546b62a13809a897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0c4c44861063b684d43d4ad78a995e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a> () const</td></tr>
<tr class="memdesc:a9f0c4c44861063b684d43d4ad78a995e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the robot.  <a href="#a9f0c4c44861063b684d43d4ad78a995e">More...</a><br /></td></tr>
<tr class="separator:a9f0c4c44861063b684d43d4ad78a995e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e734d771ca6cf96801de8765cee637d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01724.html">RobotModule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a3e734d771ca6cf96801de8765cee637d">module</a> () const</td></tr>
<tr class="memdesc:a3e734d771ca6cf96801de8765cee637d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the associated <a class="el" href="a01724.html">RobotModule</a>.  <a href="#a3e734d771ca6cf96801de8765cee637d">More...</a><br /></td></tr>
<tr class="separator:a3e734d771ca6cf96801de8765cee637d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb78a38ec8b2037519f030140a95976"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aafb78a38ec8b2037519f030140a95976">hasJoint</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:aafb78a38ec8b2037519f030140a95976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the robot has a joint named <code>name</code>.  <a href="#aafb78a38ec8b2037519f030140a95976">More...</a><br /></td></tr>
<tr class="separator:aafb78a38ec8b2037519f030140a95976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8353aa6a66630a85c9249298ed960c6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a8353aa6a66630a85c9249298ed960c6a">hasBody</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:a8353aa6a66630a85c9249298ed960c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the robot has a body named <code>name</code>.  <a href="#a8353aa6a66630a85c9249298ed960c6a">More...</a><br /></td></tr>
<tr class="separator:a8353aa6a66630a85c9249298ed960c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47874ad9d5abdcd85701b02e2c85cefb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a47874ad9d5abdcd85701b02e2c85cefb">hasSurface</a> (const std::string &amp;<a class="el" href="a01696.html#aa4b724e51881215dd4293f9578656755">surface</a>) const</td></tr>
<tr class="memdesc:a47874ad9d5abdcd85701b02e2c85cefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a surface <code>surface</code> exists.  <a href="#a47874ad9d5abdcd85701b02e2c85cefb">More...</a><br /></td></tr>
<tr class="separator:a47874ad9d5abdcd85701b02e2c85cefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b724e51881215dd4293f9578656755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01744.html">mc_rbdyn::Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aa4b724e51881215dd4293f9578656755">surface</a> (const std::string &amp;sName)</td></tr>
<tr class="memdesc:aa4b724e51881215dd4293f9578656755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a surface by its name <code>sName</code>.  <a href="#aa4b724e51881215dd4293f9578656755">More...</a><br /></td></tr>
<tr class="separator:aa4b724e51881215dd4293f9578656755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032e4252cb8c2c1d2ab82bd353b1cfb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01744.html">mc_rbdyn::Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a032e4252cb8c2c1d2ab82bd353b1cfb2">surface</a> (const std::string &amp;sName) const</td></tr>
<tr class="memdesc:a032e4252cb8c2c1d2ab82bd353b1cfb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a surface by its name <code>sName</code> (const)  <a href="#a032e4252cb8c2c1d2ab82bd353b1cfb2">More...</a><br /></td></tr>
<tr class="separator:a032e4252cb8c2c1d2ab82bd353b1cfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c21632fb2dc076e87cc4f4b6f840ddb"><td class="memItemLeft" align="right" valign="top">sva::PTransformd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a0c21632fb2dc076e87cc4f4b6f840ddb">surfacePose</a> (const std::string &amp;sName) const</td></tr>
<tr class="memdesc:a0c21632fb2dc076e87cc4f4b6f840ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pose of a surface frame with respect to the inertial frame.  <a href="#a0c21632fb2dc076e87cc4f4b6f840ddb">More...</a><br /></td></tr>
<tr class="separator:a0c21632fb2dc076e87cc4f4b6f840ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eac94be22b1481eaae48d110d97c49e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01744.html">mc_rbdyn::Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a9eac94be22b1481eaae48d110d97c49e">copySurface</a> (const std::string &amp;sName, const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="memdesc:a9eac94be22b1481eaae48d110d97c49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an existing surface with a new name.  <a href="#a9eac94be22b1481eaae48d110d97c49e">More...</a><br /></td></tr>
<tr class="separator:a9eac94be22b1481eaae48d110d97c49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02691447f1d554276f01339ba6c3aad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a02691447f1d554276f01339ba6c3aad7">addSurface</a> (<a class="el" href="a00766.html#a848cf0b2e8f6ca6f18ceba1769d9a426">mc_rbdyn::SurfacePtr</a> <a class="el" href="a01696.html#aa4b724e51881215dd4293f9578656755">surface</a>, bool doNotReplace=true)</td></tr>
<tr class="memdesc:a02691447f1d554276f01339ba6c3aad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a surface with a new name.  <a href="#a02691447f1d554276f01339ba6c3aad7">More...</a><br /></td></tr>
<tr class="separator:a02691447f1d554276f01339ba6c3aad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee61e66a131e6f3e24982d4c68ffe958"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="a00766.html#a848cf0b2e8f6ca6f18ceba1769d9a426">mc_rbdyn::SurfacePtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aee61e66a131e6f3e24982d4c68ffe958">surfaces</a> () const</td></tr>
<tr class="memdesc:aee61e66a131e6f3e24982d4c68ffe958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all available surfaces.  <a href="#aee61e66a131e6f3e24982d4c68ffe958">More...</a><br /></td></tr>
<tr class="separator:aee61e66a131e6f3e24982d4c68ffe958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0e0346563b3ba8d3fda355e27367a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aac0e0346563b3ba8d3fda355e27367a8">availableSurfaces</a> () const</td></tr>
<tr class="memdesc:aac0e0346563b3ba8d3fda355e27367a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of available surfaces.  <a href="#aac0e0346563b3ba8d3fda355e27367a8">More...</a><br /></td></tr>
<tr class="separator:aac0e0346563b3ba8d3fda355e27367a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa71c0145f03a620619e8fe8b96107"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a75aa71c0145f03a620619e8fe8b96107">hasConvex</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:a75aa71c0145f03a620619e8fe8b96107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a convex <code>name</code> exists.  <a href="#a75aa71c0145f03a620619e8fe8b96107">More...</a><br /></td></tr>
<tr class="separator:a75aa71c0145f03a620619e8fe8b96107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa487585e4b6d447c69ba78d9eca203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01696.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a7fa487585e4b6d447c69ba78d9eca203">convex</a> (const std::string &amp;cName)</td></tr>
<tr class="memdesc:a7fa487585e4b6d447c69ba78d9eca203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a convex named <code>cName</code>.  <a href="#a7fa487585e4b6d447c69ba78d9eca203">More...</a><br /></td></tr>
<tr class="separator:a7fa487585e4b6d447c69ba78d9eca203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2dc756cfb84c337de115384febab34"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01696.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a2b2dc756cfb84c337de115384febab34">convex</a> (const std::string &amp;cName) const</td></tr>
<tr class="memdesc:a2b2dc756cfb84c337de115384febab34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a convex named <code>cName</code> (const)  <a href="#a2b2dc756cfb84c337de115384febab34">More...</a><br /></td></tr>
<tr class="separator:a2b2dc756cfb84c337de115384febab34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa176323f1dd1dc8f29ad40ccd4b23c9d"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="a01696.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aa176323f1dd1dc8f29ad40ccd4b23c9d">convexes</a> () const</td></tr>
<tr class="memdesc:aa176323f1dd1dc8f29ad40ccd4b23c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all convexes available in this robot.  <a href="#aa176323f1dd1dc8f29ad40ccd4b23c9d">More...</a><br /></td></tr>
<tr class="separator:aa176323f1dd1dc8f29ad40ccd4b23c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30c16125ec220e6525f86339d894a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ae30c16125ec220e6525f86339d894a3c">addConvex</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>, const std::string &amp;body, <a class="el" href="a01696.html#a28270fdeec598bc23d8761191a6226d4">S_ObjectPtr</a> <a class="el" href="a01696.html#a7fa487585e4b6d447c69ba78d9eca203">convex</a>, const sva::PTransformd &amp;X_b_c=sva::PTransformd::Identity())</td></tr>
<tr class="memdesc:ae30c16125ec220e6525f86339d894a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a convex online.  <a href="#ae30c16125ec220e6525f86339d894a3c">More...</a><br /></td></tr>
<tr class="separator:ae30c16125ec220e6525f86339d894a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3296b923f06db47d80641b7acf46e5bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a3296b923f06db47d80641b7acf46e5bf">removeConvex</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="memdesc:a3296b923f06db47d80641b7acf46e5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a given convex.  <a href="#a3296b923f06db47d80641b7acf46e5bf">More...</a><br /></td></tr>
<tr class="separator:a3296b923f06db47d80641b7acf46e5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd5ae09effe07a9a766050bcfee859"><td class="memItemLeft" align="right" valign="top">const sva::PTransformd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a91bd5ae09effe07a9a766050bcfee859">bodyTransform</a> (const std::string &amp;bName) const</td></tr>
<tr class="memdesc:a91bd5ae09effe07a9a766050bcfee859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access transformation from body <code>bName</code> to original base.  <a href="#a91bd5ae09effe07a9a766050bcfee859">More...</a><br /></td></tr>
<tr class="separator:a91bd5ae09effe07a9a766050bcfee859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022bd9c9318d298da53c823ca93b5f1c"><td class="memItemLeft" align="right" valign="top">const sva::PTransformd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a022bd9c9318d298da53c823ca93b5f1c">bodyTransform</a> (int bodyIndex) const</td></tr>
<tr class="memdesc:a022bd9c9318d298da53c823ca93b5f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access body transform by index.  <a href="#a022bd9c9318d298da53c823ca93b5f1c">More...</a><br /></td></tr>
<tr class="separator:a022bd9c9318d298da53c823ca93b5f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135b6be808af82a5b0d21ffda5a8fe17"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sva::PTransformd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a135b6be808af82a5b0d21ffda5a8fe17">bodyTransforms</a> () const</td></tr>
<tr class="memdesc:a135b6be808af82a5b0d21ffda5a8fe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access body transform vector.  <a href="#a135b6be808af82a5b0d21ffda5a8fe17">More...</a><br /></td></tr>
<tr class="separator:a135b6be808af82a5b0d21ffda5a8fe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af239b709cd1907f1aa264dfa2cb9fd15"><td class="memItemLeft" align="right" valign="top">const sva::PTransformd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#af239b709cd1907f1aa264dfa2cb9fd15">collisionTransform</a> (const std::string &amp;cName) const</td></tr>
<tr class="memdesc:af239b709cd1907f1aa264dfa2cb9fd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access transformation between the collision mesh and the body.  <a href="#af239b709cd1907f1aa264dfa2cb9fd15">More...</a><br /></td></tr>
<tr class="separator:af239b709cd1907f1aa264dfa2cb9fd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1554209253be449c1fb4cdd7e3d2478d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a1554209253be449c1fb4cdd7e3d2478d">loadRSDFFromDir</a> (const std::string &amp;surfaceDir)</td></tr>
<tr class="memdesc:a1554209253be449c1fb4cdd7e3d2478d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load surfaces from the directory <code>surfaceDir</code>.  <a href="#a1554209253be449c1fb4cdd7e3d2478d">More...</a><br /></td></tr>
<tr class="separator:a1554209253be449c1fb4cdd7e3d2478d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b932fc4c4956b16490006dd8591d0e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ac4b932fc4c4956b16490006dd8591d0e">stance</a> () const</td></tr>
<tr class="memdesc:ac4b932fc4c4956b16490006dd8591d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the robot's default stance (e.g.  <a href="#ac4b932fc4c4956b16490006dd8591d0e">More...</a><br /></td></tr>
<tr class="separator:ac4b932fc4c4956b16490006dd8591d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af110c909887516af9f6758118978b643"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#af110c909887516af9f6758118978b643">robotIndex</a> () const</td></tr>
<tr class="memdesc:af110c909887516af9f6758118978b643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's index in robots()  <a href="#af110c909887516af9f6758118978b643">More...</a><br /></td></tr>
<tr class="separator:af110c909887516af9f6758118978b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46b693d4431e61db9f1d4a05f66dd5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ae46b693d4431e61db9f1d4a05f66dd5e">forwardKinematics</a> ()</td></tr>
<tr class="memdesc:ae46b693d4431e61db9f1d4a05f66dd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply forward kinematics to the robot.  <a href="#ae46b693d4431e61db9f1d4a05f66dd5e">More...</a><br /></td></tr>
<tr class="separator:ae46b693d4431e61db9f1d4a05f66dd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9520af131693e9b873ce4c37513cfa1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a9520af131693e9b873ce4c37513cfa1d">forwardKinematics</a> (rbd::MultiBodyConfig &amp;<a class="el" href="a01696.html#a0051e9ce612a34601d6934f7d5caaeb4">mbc</a>) const</td></tr>
<tr class="memdesc:a9520af131693e9b873ce4c37513cfa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply forward kinematics to <code>mbc</code> using the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a>  <a href="#a9520af131693e9b873ce4c37513cfa1d">More...</a><br /></td></tr>
<tr class="separator:a9520af131693e9b873ce4c37513cfa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd93342dd86da6803288346a3798d374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#afd93342dd86da6803288346a3798d374">forwardVelocity</a> ()</td></tr>
<tr class="memdesc:afd93342dd86da6803288346a3798d374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply forward velocity to the robot.  <a href="#afd93342dd86da6803288346a3798d374">More...</a><br /></td></tr>
<tr class="separator:afd93342dd86da6803288346a3798d374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73998aca81be7062371f39ce5d60756a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a73998aca81be7062371f39ce5d60756a">forwardVelocity</a> (rbd::MultiBodyConfig &amp;<a class="el" href="a01696.html#a0051e9ce612a34601d6934f7d5caaeb4">mbc</a>) const</td></tr>
<tr class="memdesc:a73998aca81be7062371f39ce5d60756a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply forward velocity to <code>mbc</code> using the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a>  <a href="#a73998aca81be7062371f39ce5d60756a">More...</a><br /></td></tr>
<tr class="separator:a73998aca81be7062371f39ce5d60756a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c546ec0809807016d316229d1d29c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ab7c546ec0809807016d316229d1d29c0">forwardAcceleration</a> (const sva::MotionVecd &amp;A_0=sva::MotionVecd(Eigen::Vector6d::Zero()))</td></tr>
<tr class="memdesc:ab7c546ec0809807016d316229d1d29c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply forward acceleration to the robot.  <a href="#ab7c546ec0809807016d316229d1d29c0">More...</a><br /></td></tr>
<tr class="separator:ab7c546ec0809807016d316229d1d29c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5564b8d60b3dd8fa3e88e31f8f93a02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ad5564b8d60b3dd8fa3e88e31f8f93a02">forwardAcceleration</a> (rbd::MultiBodyConfig &amp;<a class="el" href="a01696.html#a0051e9ce612a34601d6934f7d5caaeb4">mbc</a>, const sva::MotionVecd &amp;A_0=sva::MotionVecd(Eigen::Vector6d::Zero())) const</td></tr>
<tr class="memdesc:ad5564b8d60b3dd8fa3e88e31f8f93a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply forward acceleration to <code>mbc</code> using the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a>  <a href="#ad5564b8d60b3dd8fa3e88e31f8f93a02">More...</a><br /></td></tr>
<tr class="separator:ad5564b8d60b3dd8fa3e88e31f8f93a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1794c11cac282d7c042216d431ebb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#acd1794c11cac282d7c042216d431ebb7">eulerIntegration</a> (double step)</td></tr>
<tr class="memdesc:acd1794c11cac282d7c042216d431ebb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Euler integration to the robot using <code>step</code> timestep.  <a href="#acd1794c11cac282d7c042216d431ebb7">More...</a><br /></td></tr>
<tr class="separator:acd1794c11cac282d7c042216d431ebb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d130fc22dda8e9bfbecad28acc26a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ae8d130fc22dda8e9bfbecad28acc26a5">eulerIntegration</a> (rbd::MultiBodyConfig &amp;<a class="el" href="a01696.html#a0051e9ce612a34601d6934f7d5caaeb4">mbc</a>, double step) const</td></tr>
<tr class="memdesc:ae8d130fc22dda8e9bfbecad28acc26a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Euler integration to <code>mbc</code> using the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a> and <code>step</code> timestep.  <a href="#ae8d130fc22dda8e9bfbecad28acc26a5">More...</a><br /></td></tr>
<tr class="separator:ae8d130fc22dda8e9bfbecad28acc26a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48843047df8893808f80971fa3f9257f"><td class="memItemLeft" align="right" valign="top">const sva::PTransformd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a48843047df8893808f80971fa3f9257f">posW</a> () const</td></tr>
<tr class="memdesc:a48843047df8893808f80971fa3f9257f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the robot's global pose.  <a href="#a48843047df8893808f80971fa3f9257f">More...</a><br /></td></tr>
<tr class="separator:a48843047df8893808f80971fa3f9257f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fe0da3fe099906b79cb20de8076659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a54fe0da3fe099906b79cb20de8076659">posW</a> (const sva::PTransformd &amp;pt)</td></tr>
<tr class="memdesc:a54fe0da3fe099906b79cb20de8076659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the robot's global pose.  <a href="#a54fe0da3fe099906b79cb20de8076659">More...</a><br /></td></tr>
<tr class="separator:a54fe0da3fe099906b79cb20de8076659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f3f6250f68bac91a2594e9e6383b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a50f3f6250f68bac91a2594e9e6383b2f">velW</a> (const sva::MotionVecd &amp;vel)</td></tr>
<tr class="memdesc:a50f3f6250f68bac91a2594e9e6383b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the robot's floating base velocity.  <a href="#a50f3f6250f68bac91a2594e9e6383b2f">More...</a><br /></td></tr>
<tr class="separator:a50f3f6250f68bac91a2594e9e6383b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38618f0ff197fccef53069f51e9fcafc"><td class="memItemLeft" align="right" valign="top">const sva::MotionVecd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a38618f0ff197fccef53069f51e9fcafc">velW</a> () const</td></tr>
<tr class="memdesc:a38618f0ff197fccef53069f51e9fcafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the robot's floating base velocity expressed in the inertial frame.  <a href="#a38618f0ff197fccef53069f51e9fcafc">More...</a><br /></td></tr>
<tr class="separator:a38618f0ff197fccef53069f51e9fcafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7a59334340cf8b44a10c6c9cb64d76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a8c7a59334340cf8b44a10c6c9cb64d76">accW</a> (const sva::MotionVecd &amp;acc)</td></tr>
<tr class="memdesc:a8c7a59334340cf8b44a10c6c9cb64d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the robot's floating base acceleration.  <a href="#a8c7a59334340cf8b44a10c6c9cb64d76">More...</a><br /></td></tr>
<tr class="separator:a8c7a59334340cf8b44a10c6c9cb64d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b21b6e828397cebd4f015cf9e87f44"><td class="memItemLeft" align="right" valign="top">const sva::MotionVecd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a30b21b6e828397cebd4f015cf9e87f44">accW</a> () const</td></tr>
<tr class="memdesc:a30b21b6e828397cebd4f015cf9e87f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the robot's floating base acceleration expressed in the inertial frame.  <a href="#a30b21b6e828397cebd4f015cf9e87f44">More...</a><br /></td></tr>
<tr class="separator:a30b21b6e828397cebd4f015cf9e87f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b970df4059237f37021b47d5aaf2494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01476.html">mc_control::Gripper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a8b970df4059237f37021b47d5aaf2494">gripper</a> (const std::string &amp;gripper)</td></tr>
<tr class="memdesc:a8b970df4059237f37021b47d5aaf2494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a gripper by name.  <a href="#a8b970df4059237f37021b47d5aaf2494">More...</a><br /></td></tr>
<tr class="separator:a8b970df4059237f37021b47d5aaf2494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0c83dbee42dff616909c21b90825b8"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; std::string, <a class="el" href="a00761.html#a67d3b51822d3e7d0c56d9af675f9eaa1">mc_control::GripperPtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a6b0c83dbee42dff616909c21b90825b8">grippersByName</a> () const</td></tr>
<tr class="separator:a6b0c83dbee42dff616909c21b90825b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa96f71ad7e9c085d622c4885c15f1bb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="a00761.html#a39b3dee4f4017bab0f389d9bfd7877dc">mc_control::GripperRef</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#afa96f71ad7e9c085d622c4885c15f1bb">grippers</a> () const</td></tr>
<tr class="memdesc:afa96f71ad7e9c085d622c4885c15f1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access all grippers.  <a href="#afa96f71ad7e9c085d622c4885c15f1bb">More...</a><br /></td></tr>
<tr class="separator:afa96f71ad7e9c085d622c4885c15f1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Body sensors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are related to force sensors </p>
</div></td></tr>
<tr class="memitem:a3effaf63deb70c0d2463cf374cc2e7c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01580.html">BodySensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a3effaf63deb70c0d2463cf374cc2e7c1">bodySensor</a> ()</td></tr>
<tr class="memdesc:a3effaf63deb70c0d2463cf374cc2e7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first <a class="el" href="a01580.html" title="This structure defines a body sensor, that is a sensor that provides dynamic information about a body...">BodySensor</a> in the robot.  <a href="#a3effaf63deb70c0d2463cf374cc2e7c1">More...</a><br /></td></tr>
<tr class="separator:a3effaf63deb70c0d2463cf374cc2e7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e34acaf5dc3b279cc97e5cd4c215708"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01580.html">BodySensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a3e34acaf5dc3b279cc97e5cd4c215708">bodySensor</a> () const</td></tr>
<tr class="memdesc:a3e34acaf5dc3b279cc97e5cd4c215708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first <a class="el" href="a01580.html" title="This structure defines a body sensor, that is a sensor that provides dynamic information about a body...">BodySensor</a> in the robot (const)  <a href="#a3e34acaf5dc3b279cc97e5cd4c215708">More...</a><br /></td></tr>
<tr class="separator:a3e34acaf5dc3b279cc97e5cd4c215708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2572eb64a1ab6318f715e0163400e4bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a2572eb64a1ab6318f715e0163400e4bf">hasBodySensor</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:a2572eb64a1ab6318f715e0163400e4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the robot has a body sensor named name.  <a href="#a2572eb64a1ab6318f715e0163400e4bf">More...</a><br /></td></tr>
<tr class="separator:a2572eb64a1ab6318f715e0163400e4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558d26564bdb4888db21b2ae13d32f39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a558d26564bdb4888db21b2ae13d32f39">bodyHasBodySensor</a> (const std::string &amp;body) const</td></tr>
<tr class="memdesc:a558d26564bdb4888db21b2ae13d32f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified body has a body sensor attached to it.  <a href="#a558d26564bdb4888db21b2ae13d32f39">More...</a><br /></td></tr>
<tr class="separator:a558d26564bdb4888db21b2ae13d32f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439af8f5d3edc70f1f8cf8b947c61cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01580.html">BodySensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a439af8f5d3edc70f1f8cf8b947c61cdd">bodySensor</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="memdesc:a439af8f5d3edc70f1f8cf8b947c61cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a specific BobySensor by name.  <a href="#a439af8f5d3edc70f1f8cf8b947c61cdd">More...</a><br /></td></tr>
<tr class="separator:a439af8f5d3edc70f1f8cf8b947c61cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e04286463ae6f91105c0b83ef370da8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01580.html">BodySensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a6e04286463ae6f91105c0b83ef370da8">bodySensor</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:a6e04286463ae6f91105c0b83ef370da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a specific <a class="el" href="a01580.html" title="This structure defines a body sensor, that is a sensor that provides dynamic information about a body...">BodySensor</a> by name (const)  <a href="#a6e04286463ae6f91105c0b83ef370da8">More...</a><br /></td></tr>
<tr class="separator:a6e04286463ae6f91105c0b83ef370da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5ebf8a9421a34de48c2b31449478cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01580.html">BodySensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a4a5ebf8a9421a34de48c2b31449478cc">bodyBodySensor</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="memdesc:a4a5ebf8a9421a34de48c2b31449478cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a specific <a class="el" href="a01580.html" title="This structure defines a body sensor, that is a sensor that provides dynamic information about a body...">BodySensor</a> by body name.  <a href="#a4a5ebf8a9421a34de48c2b31449478cc">More...</a><br /></td></tr>
<tr class="separator:a4a5ebf8a9421a34de48c2b31449478cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4faa529e12f2d401c2d7a805f07ae75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01580.html">BodySensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ac4faa529e12f2d401c2d7a805f07ae75">bodyBodySensor</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:ac4faa529e12f2d401c2d7a805f07ae75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a specific <a class="el" href="a01580.html" title="This structure defines a body sensor, that is a sensor that provides dynamic information about a body...">BodySensor</a> by body name (const)  <a href="#ac4faa529e12f2d401c2d7a805f07ae75">More...</a><br /></td></tr>
<tr class="separator:ac4faa529e12f2d401c2d7a805f07ae75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7aeb8979e469e5d34c4ffea9267a70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00766.html#a728d731db2806e7673f67b958970e558">BodySensorVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a0a7aeb8979e469e5d34c4ffea9267a70">bodySensors</a> ()</td></tr>
<tr class="memdesc:a0a7aeb8979e469e5d34c4ffea9267a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all body sensors.  <a href="#a0a7aeb8979e469e5d34c4ffea9267a70">More...</a><br /></td></tr>
<tr class="separator:a0a7aeb8979e469e5d34c4ffea9267a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8a8b93689ec20b516f8d0ae460ea80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00766.html#a728d731db2806e7673f67b958970e558">BodySensorVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ace8a8b93689ec20b516f8d0ae460ea80">bodySensors</a> () const</td></tr>
<tr class="memdesc:ace8a8b93689ec20b516f8d0ae460ea80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all body sensors (const)  <a href="#ace8a8b93689ec20b516f8d0ae460ea80">More...</a><br /></td></tr>
<tr class="separator:ace8a8b93689ec20b516f8d0ae460ea80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Returns the joint index of joint named</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the joint does not exist within the robot. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:a7ad6afc9dd0267860a325771e7f87ea1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a7ad6afc9dd0267860a325771e7f87ea1">jointIndexByName</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a7ad6afc9dd0267860a325771e7f87ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3662367cdf4edb974bdad793b1189b20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a3662367cdf4edb974bdad793b1189b20">jointIndexInMBC</a> (size_t jointIndex) const</td></tr>
<tr class="memdesc:a3662367cdf4edb974bdad793b1189b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the joint index in the mbc of the joint with index jointIndex in refJointOrder.  <a href="#a3662367cdf4edb974bdad793b1189b20">More...</a><br /></td></tr>
<tr class="separator:a3662367cdf4edb974bdad793b1189b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Returns the body index of joint named</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the body does not exist within the robot. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:a5309b5ef9bb5b91bf0f1adb59813bde4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a5309b5ef9bb5b91bf0f1adb59813bde4">bodyIndexByName</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="separator:a5309b5ef9bb5b91bf0f1adb59813bde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bdab3efcd9ada4d2b3aefa53374af1"><td class="memItemLeft" align="right" valign="top">rbd::MultiBody &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1">mb</a> ()</td></tr>
<tr class="memdesc:a79bdab3efcd9ada4d2b3aefa53374af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access MultiBody representation of the robot.  <a href="#a79bdab3efcd9ada4d2b3aefa53374af1">More...</a><br /></td></tr>
<tr class="separator:a79bdab3efcd9ada4d2b3aefa53374af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09b1765903debcc06dce65ce830cfc0"><td class="memItemLeft" align="right" valign="top">const rbd::MultiBody &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ab09b1765903debcc06dce65ce830cfc0">mb</a> () const</td></tr>
<tr class="memdesc:ab09b1765903debcc06dce65ce830cfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access MultiBody representation of the robot (const)  <a href="#ab09b1765903debcc06dce65ce830cfc0">More...</a><br /></td></tr>
<tr class="separator:ab09b1765903debcc06dce65ce830cfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0051e9ce612a34601d6934f7d5caaeb4"><td class="memItemLeft" align="right" valign="top">rbd::MultiBodyConfig &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a0051e9ce612a34601d6934f7d5caaeb4">mbc</a> ()</td></tr>
<tr class="memdesc:a0051e9ce612a34601d6934f7d5caaeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access MultiBodyConfig of the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a>  <a href="#a0051e9ce612a34601d6934f7d5caaeb4">More...</a><br /></td></tr>
<tr class="separator:a0051e9ce612a34601d6934f7d5caaeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece5a00f65317b116f70ed2937239421"><td class="memItemLeft" align="right" valign="top">const rbd::MultiBodyConfig &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aece5a00f65317b116f70ed2937239421">mbc</a> () const</td></tr>
<tr class="memdesc:aece5a00f65317b116f70ed2937239421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access MultiBodyConfig of the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a> (const)  <a href="#aece5a00f65317b116f70ed2937239421">More...</a><br /></td></tr>
<tr class="separator:aece5a00f65317b116f70ed2937239421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900ba960e115fa967889ebdb842f6a3e"><td class="memItemLeft" align="right" valign="top">rbd::MultiBodyGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a900ba960e115fa967889ebdb842f6a3e">mbg</a> ()</td></tr>
<tr class="memdesc:a900ba960e115fa967889ebdb842f6a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access MultiBodyGraph that generated the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a>  <a href="#a900ba960e115fa967889ebdb842f6a3e">More...</a><br /></td></tr>
<tr class="separator:a900ba960e115fa967889ebdb842f6a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78336b8d90c933da75cd138227072321"><td class="memItemLeft" align="right" valign="top">const rbd::MultiBodyGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a78336b8d90c933da75cd138227072321">mbg</a> () const</td></tr>
<tr class="memdesc:a78336b8d90c933da75cd138227072321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access MultiBodyGraph that generated the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a> (const)  <a href="#a78336b8d90c933da75cd138227072321">More...</a><br /></td></tr>
<tr class="separator:a78336b8d90c933da75cd138227072321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485eb8aa4ceb0a0a5010844d16e47f95"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a485eb8aa4ceb0a0a5010844d16e47f95">q</a> () const</td></tr>
<tr class="memdesc:a485eb8aa4ceb0a0a5010844d16e47f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().q (const)  <a href="#a485eb8aa4ceb0a0a5010844d16e47f95">More...</a><br /></td></tr>
<tr class="separator:a485eb8aa4ceb0a0a5010844d16e47f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5773f91f2a9d0eb5cb4b6a0943551a1b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a5773f91f2a9d0eb5cb4b6a0943551a1b">alpha</a> () const</td></tr>
<tr class="memdesc:a5773f91f2a9d0eb5cb4b6a0943551a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().alpha (const)  <a href="#a5773f91f2a9d0eb5cb4b6a0943551a1b">More...</a><br /></td></tr>
<tr class="separator:a5773f91f2a9d0eb5cb4b6a0943551a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca1f147be470012cb1203f95d5c5abe"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aeca1f147be470012cb1203f95d5c5abe">alphaD</a> () const</td></tr>
<tr class="memdesc:aeca1f147be470012cb1203f95d5c5abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().alphaD (const)  <a href="#aeca1f147be470012cb1203f95d5c5abe">More...</a><br /></td></tr>
<tr class="separator:aeca1f147be470012cb1203f95d5c5abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95798f9588d0656c61558ab20ad935b4"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a95798f9588d0656c61558ab20ad935b4">jointTorque</a> () const</td></tr>
<tr class="memdesc:a95798f9588d0656c61558ab20ad935b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().jointTorque (const)  <a href="#a95798f9588d0656c61558ab20ad935b4">More...</a><br /></td></tr>
<tr class="separator:a95798f9588d0656c61558ab20ad935b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9415aa6bf2421a5e76bd85b04359b1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sva::PTransformd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a7e9415aa6bf2421a5e76bd85b04359b1">bodyPosW</a> () const</td></tr>
<tr class="memdesc:a7e9415aa6bf2421a5e76bd85b04359b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().bodyPosW (const)  <a href="#a7e9415aa6bf2421a5e76bd85b04359b1">More...</a><br /></td></tr>
<tr class="separator:a7e9415aa6bf2421a5e76bd85b04359b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1bcd2edaa8eeb17033ae3fafe1bde8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aad1bcd2edaa8eeb17033ae3fafe1bde8">bodyVelW</a> () const</td></tr>
<tr class="memdesc:aad1bcd2edaa8eeb17033ae3fafe1bde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().bodyVelW (const)  <a href="#aad1bcd2edaa8eeb17033ae3fafe1bde8">More...</a><br /></td></tr>
<tr class="separator:aad1bcd2edaa8eeb17033ae3fafe1bde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ce1f653158bc3b79dd903ee1c05d9c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ac4ce1f653158bc3b79dd903ee1c05d9c">bodyVelB</a> () const</td></tr>
<tr class="memdesc:ac4ce1f653158bc3b79dd903ee1c05d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().bodyVelB (const)  <a href="#ac4ce1f653158bc3b79dd903ee1c05d9c">More...</a><br /></td></tr>
<tr class="separator:ac4ce1f653158bc3b79dd903ee1c05d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4739f4a8c3d2ac6a20797e7287b959"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a1e4739f4a8c3d2ac6a20797e7287b959">bodyAccB</a> () const</td></tr>
<tr class="memdesc:a1e4739f4a8c3d2ac6a20797e7287b959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().bodyAccB (const)  <a href="#a1e4739f4a8c3d2ac6a20797e7287b959">More...</a><br /></td></tr>
<tr class="separator:a1e4739f4a8c3d2ac6a20797e7287b959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad8d3434a21adb16f8c41a5444ea067"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a8ad8d3434a21adb16f8c41a5444ea067">q</a> ()</td></tr>
<tr class="memdesc:a8ad8d3434a21adb16f8c41a5444ea067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().q.  <a href="#a8ad8d3434a21adb16f8c41a5444ea067">More...</a><br /></td></tr>
<tr class="separator:a8ad8d3434a21adb16f8c41a5444ea067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36db2265563e037f7b98f2a3b8ac826"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ad36db2265563e037f7b98f2a3b8ac826">alpha</a> ()</td></tr>
<tr class="memdesc:ad36db2265563e037f7b98f2a3b8ac826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().alpha.  <a href="#ad36db2265563e037f7b98f2a3b8ac826">More...</a><br /></td></tr>
<tr class="separator:ad36db2265563e037f7b98f2a3b8ac826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611ff3ed6802a623056076abba7283ac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a611ff3ed6802a623056076abba7283ac">alphaD</a> ()</td></tr>
<tr class="memdesc:a611ff3ed6802a623056076abba7283ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().alphaD.  <a href="#a611ff3ed6802a623056076abba7283ac">More...</a><br /></td></tr>
<tr class="separator:a611ff3ed6802a623056076abba7283ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af946d00c2f9e36ed5c0899f237f35c32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#af946d00c2f9e36ed5c0899f237f35c32">jointTorque</a> ()</td></tr>
<tr class="memdesc:af946d00c2f9e36ed5c0899f237f35c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().jointTorque.  <a href="#af946d00c2f9e36ed5c0899f237f35c32">More...</a><br /></td></tr>
<tr class="separator:af946d00c2f9e36ed5c0899f237f35c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0aad75ddf11178d780abe0a64d7021"><td class="memItemLeft" align="right" valign="top">std::vector&lt; sva::PTransformd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#adf0aad75ddf11178d780abe0a64d7021">bodyPosW</a> ()</td></tr>
<tr class="memdesc:adf0aad75ddf11178d780abe0a64d7021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().bodyPosW.  <a href="#adf0aad75ddf11178d780abe0a64d7021">More...</a><br /></td></tr>
<tr class="separator:adf0aad75ddf11178d780abe0a64d7021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252c64f915ca619afcdcf27e9dd63dd2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a252c64f915ca619afcdcf27e9dd63dd2">bodyVelW</a> ()</td></tr>
<tr class="memdesc:a252c64f915ca619afcdcf27e9dd63dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().bodyVelW.  <a href="#a252c64f915ca619afcdcf27e9dd63dd2">More...</a><br /></td></tr>
<tr class="separator:a252c64f915ca619afcdcf27e9dd63dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b38b6bbe93a7b6cc48d9091e9ee8b5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a54b38b6bbe93a7b6cc48d9091e9ee8b5">bodyVelB</a> ()</td></tr>
<tr class="memdesc:a54b38b6bbe93a7b6cc48d9091e9ee8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().bodyVelB.  <a href="#a54b38b6bbe93a7b6cc48d9091e9ee8b5">More...</a><br /></td></tr>
<tr class="separator:a54b38b6bbe93a7b6cc48d9091e9ee8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfdb088e19e290eea18767e249ca79e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; sva::MotionVecd &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#accfdb088e19e290eea18767e249ca79e">bodyAccB</a> ()</td></tr>
<tr class="memdesc:accfdb088e19e290eea18767e249ca79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to robot.mbc().bodyAccB.  <a href="#accfdb088e19e290eea18767e249ca79e">More...</a><br /></td></tr>
<tr class="separator:accfdb088e19e290eea18767e249ca79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7764d03bd41fedfa98443d4a0b262e9"><td class="memItemLeft" align="right" valign="top">const sva::PTransformd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#af7764d03bd41fedfa98443d4a0b262e9">bodyPosW</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:af7764d03bd41fedfa98443d4a0b262e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the position of body <code>name</code> in world coordinates.  <a href="#af7764d03bd41fedfa98443d4a0b262e9">More...</a><br /></td></tr>
<tr class="separator:af7764d03bd41fedfa98443d4a0b262e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76547cf0aab26354dad897265d6060ee"><td class="memItemLeft" align="right" valign="top">sva::PTransformd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a76547cf0aab26354dad897265d6060ee">X_b1_b2</a> (const std::string &amp;b1, const std::string &amp;b2) const</td></tr>
<tr class="memdesc:a76547cf0aab26354dad897265d6060ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative transformation X_b1_b2 from body b1 to body b2.  <a href="#a76547cf0aab26354dad897265d6060ee">More...</a><br /></td></tr>
<tr class="separator:a76547cf0aab26354dad897265d6060ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4808b0299894e9343b6c27b1cc6e14"><td class="memItemLeft" align="right" valign="top">const sva::MotionVecd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#abc4808b0299894e9343b6c27b1cc6e14">bodyVelW</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:abc4808b0299894e9343b6c27b1cc6e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the velocity of body <code>name</code> in world coordinates.  <a href="#abc4808b0299894e9343b6c27b1cc6e14">More...</a><br /></td></tr>
<tr class="separator:abc4808b0299894e9343b6c27b1cc6e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86619b4049ec59d383a445bafe43830e"><td class="memItemLeft" align="right" valign="top">const sva::MotionVecd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a86619b4049ec59d383a445bafe43830e">bodyVelB</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:a86619b4049ec59d383a445bafe43830e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the velocity of body <code>name</code> in body coordinates.  <a href="#a86619b4049ec59d383a445bafe43830e">More...</a><br /></td></tr>
<tr class="separator:a86619b4049ec59d383a445bafe43830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e766814295ca73b3bf6da8e90f4421"><td class="memItemLeft" align="right" valign="top">const sva::MotionVecd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a81e766814295ca73b3bf6da8e90f4421">bodyAccB</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:a81e766814295ca73b3bf6da8e90f4421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the acceleration of body <code>name</code> in body coordinates.  <a href="#a81e766814295ca73b3bf6da8e90f4421">More...</a><br /></td></tr>
<tr class="separator:a81e766814295ca73b3bf6da8e90f4421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e858c693b7e94ded9704e13463e1ae5"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a4e858c693b7e94ded9704e13463e1ae5">com</a> () const</td></tr>
<tr class="memdesc:a4e858c693b7e94ded9704e13463e1ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and returns the current robot's CoM.  <a href="#a4e858c693b7e94ded9704e13463e1ae5">More...</a><br /></td></tr>
<tr class="separator:a4e858c693b7e94ded9704e13463e1ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17c3d6b4bff8b9bcbedad822a86fdbc"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aa17c3d6b4bff8b9bcbedad822a86fdbc">comVelocity</a> () const</td></tr>
<tr class="memdesc:aa17c3d6b4bff8b9bcbedad822a86fdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and returns the current robot's CoM velocity.  <a href="#aa17c3d6b4bff8b9bcbedad822a86fdbc">More...</a><br /></td></tr>
<tr class="separator:aa17c3d6b4bff8b9bcbedad822a86fdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f1932b13b8a4589f66dd792522e1ae"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a68f1932b13b8a4589f66dd792522e1ae">comAcceleration</a> () const</td></tr>
<tr class="memdesc:a68f1932b13b8a4589f66dd792522e1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and returns the current robot's CoM acceleration.  <a href="#a68f1932b13b8a4589f66dd792522e1ae">More...</a><br /></td></tr>
<tr class="separator:a68f1932b13b8a4589f66dd792522e1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928b9370f7643511d1ec80892245fb88"><td class="memItemLeft" align="right" valign="top">sva::ForceVecd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a928b9370f7643511d1ec80892245fb88">surfaceWrench</a> (const std::string &amp;surfaceName) const</td></tr>
<tr class="memdesc:a928b9370f7643511d1ec80892245fb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gravity-free wrench in surface frame.  <a href="#a928b9370f7643511d1ec80892245fb88">More...</a><br /></td></tr>
<tr class="separator:a928b9370f7643511d1ec80892245fb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207f3ea22bce722a3d68ac37aed8ca03"><td class="memItemLeft" align="right" valign="top">sva::ForceVecd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a207f3ea22bce722a3d68ac37aed8ca03">bodyWrench</a> (const std::string &amp;bodyName) const</td></tr>
<tr class="memdesc:a207f3ea22bce722a3d68ac37aed8ca03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gravity-free wrench in body frame.  <a href="#a207f3ea22bce722a3d68ac37aed8ca03">More...</a><br /></td></tr>
<tr class="separator:a207f3ea22bce722a3d68ac37aed8ca03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411485264496b268c8ace71adcc3e75e"><td class="memItemLeft" align="right" valign="top">Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a411485264496b268c8ace71adcc3e75e">cop</a> (const std::string &amp;surfaceName, double min_pressure=0.5) const</td></tr>
<tr class="memdesc:a411485264496b268c8ace71adcc3e75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cop in surface frame computed from gravity-free force measurements.  <a href="#a411485264496b268c8ace71adcc3e75e">More...</a><br /></td></tr>
<tr class="separator:a411485264496b268c8ace71adcc3e75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2042bcdb8f612347b16e72c1853d0f1a"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a2042bcdb8f612347b16e72c1853d0f1a">copW</a> (const std::string &amp;surfaceName, double min_pressure=0.5) const</td></tr>
<tr class="memdesc:a2042bcdb8f612347b16e72c1853d0f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cop in inertial frame compute from gravity-free force measurements.  <a href="#a2042bcdb8f612347b16e72c1853d0f1a">More...</a><br /></td></tr>
<tr class="separator:a2042bcdb8f612347b16e72c1853d0f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117494f13e48578a752a102e322189b0"><td class="memItemLeft" align="right" valign="top">sva::ForceVecd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a117494f13e48578a752a102e322189b0">netWrench</a> (const std::vector&lt; std::string &gt; &amp;sensorNames) const</td></tr>
<tr class="memdesc:a117494f13e48578a752a102e322189b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes net total wrench from a list of sensors.  <a href="#a117494f13e48578a752a102e322189b0">More...</a><br /></td></tr>
<tr class="separator:a117494f13e48578a752a102e322189b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4">zmp</a> (const sva::ForceVecd &amp;netTotalWrench, const Eigen::Vector3d &amp;plane_p, const Eigen::Vector3d &amp;plane_n, double minimalNetNormalForce=1.) const</td></tr>
<tr class="memdesc:a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual ZMP computation from net total wrench and the ZMP plane.  <a href="#a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4">More...</a><br /></td></tr>
<tr class="separator:a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca98040d3ecdb597c65f3615a06d588d"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aca98040d3ecdb597c65f3615a06d588d">zmp</a> (const sva::ForceVecd &amp;netTotalWrench, const sva::PTransformd &amp;zmpFrame, double minimalNetNormalForce=1.) const</td></tr>
<tr class="memdesc:aca98040d3ecdb597c65f3615a06d588d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZMP computation from net total wrench and a frame.  <a href="#aca98040d3ecdb597c65f3615a06d588d">More...</a><br /></td></tr>
<tr class="separator:aca98040d3ecdb597c65f3615a06d588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472551d6b434e3e5a2239b35cffc639b"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a472551d6b434e3e5a2239b35cffc639b">zmp</a> (const std::vector&lt; std::string &gt; &amp;sensorNames, const Eigen::Vector3d &amp;plane_p, const Eigen::Vector3d &amp;plane_n, double minimalNetNormalForce=1.) const</td></tr>
<tr class="memdesc:a472551d6b434e3e5a2239b35cffc639b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the ZMP from sensor names and a plane.  <a href="#a472551d6b434e3e5a2239b35cffc639b">More...</a><br /></td></tr>
<tr class="separator:a472551d6b434e3e5a2239b35cffc639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b62d2a94e3c81f2c436828bc9ed5186"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a4b62d2a94e3c81f2c436828bc9ed5186">zmp</a> (const std::vector&lt; std::string &gt; &amp;sensorNames, const sva::PTransformd &amp;zmpFrame, double minimalNetNormalForce=1.) const</td></tr>
<tr class="memdesc:a4b62d2a94e3c81f2c436828bc9ed5186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the ZMP from sensor names and a frame.  <a href="#a4b62d2a94e3c81f2c436828bc9ed5186">More...</a><br /></td></tr>
<tr class="separator:a4b62d2a94e3c81f2c436828bc9ed5186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18cb6ecabada0aac1f823b7e9170308"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ac18cb6ecabada0aac1f823b7e9170308">ql</a> () const</td></tr>
<tr class="memdesc:ac18cb6ecabada0aac1f823b7e9170308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular lower limits (const)  <a href="#ac18cb6ecabada0aac1f823b7e9170308">More...</a><br /></td></tr>
<tr class="separator:ac18cb6ecabada0aac1f823b7e9170308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42c2ce3eea4e1100b4fc77b95821021"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ac42c2ce3eea4e1100b4fc77b95821021">qu</a> () const</td></tr>
<tr class="memdesc:ac42c2ce3eea4e1100b4fc77b95821021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular upper limits (const)  <a href="#ac42c2ce3eea4e1100b4fc77b95821021">More...</a><br /></td></tr>
<tr class="separator:ac42c2ce3eea4e1100b4fc77b95821021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63444fe66136d722426aca78449d62a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ab63444fe66136d722426aca78449d62a">vl</a> () const</td></tr>
<tr class="memdesc:ab63444fe66136d722426aca78449d62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular lower velocity limits (const)  <a href="#ab63444fe66136d722426aca78449d62a">More...</a><br /></td></tr>
<tr class="separator:ab63444fe66136d722426aca78449d62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b8ab43b004940508945dcb1234e60"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ac77b8ab43b004940508945dcb1234e60">vu</a> () const</td></tr>
<tr class="memdesc:ac77b8ab43b004940508945dcb1234e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular upper velocity limits (const)  <a href="#ac77b8ab43b004940508945dcb1234e60">More...</a><br /></td></tr>
<tr class="separator:ac77b8ab43b004940508945dcb1234e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353666f3eb88becdbde844f6e6915807"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a353666f3eb88becdbde844f6e6915807">al</a> () const</td></tr>
<tr class="memdesc:a353666f3eb88becdbde844f6e6915807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular lower acceleration limits (const)  <a href="#a353666f3eb88becdbde844f6e6915807">More...</a><br /></td></tr>
<tr class="separator:a353666f3eb88becdbde844f6e6915807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b3183f0c2579662c80c1c94aca9410"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ab0b3183f0c2579662c80c1c94aca9410">au</a> () const</td></tr>
<tr class="memdesc:ab0b3183f0c2579662c80c1c94aca9410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular upper acceleration limits (const)  <a href="#ab0b3183f0c2579662c80c1c94aca9410">More...</a><br /></td></tr>
<tr class="separator:ab0b3183f0c2579662c80c1c94aca9410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4cbabd88c9ee4565a2555dcc0208ae"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#afd4cbabd88c9ee4565a2555dcc0208ae">tl</a> () const</td></tr>
<tr class="memdesc:afd4cbabd88c9ee4565a2555dcc0208ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular lower torque limits (const)  <a href="#afd4cbabd88c9ee4565a2555dcc0208ae">More...</a><br /></td></tr>
<tr class="separator:afd4cbabd88c9ee4565a2555dcc0208ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f8c3970a3aff460fc5abad5b493eb6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a74f8c3970a3aff460fc5abad5b493eb6">tu</a> () const</td></tr>
<tr class="memdesc:a74f8c3970a3aff460fc5abad5b493eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular upper torque limits (const)  <a href="#a74f8c3970a3aff460fc5abad5b493eb6">More...</a><br /></td></tr>
<tr class="separator:a74f8c3970a3aff460fc5abad5b493eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa7e717817cab5e190f17d0397ff934"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a9fa7e717817cab5e190f17d0397ff934">tdl</a> () const</td></tr>
<tr class="memdesc:a9fa7e717817cab5e190f17d0397ff934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular lower torque-derivative limits (const)  <a href="#a9fa7e717817cab5e190f17d0397ff934">More...</a><br /></td></tr>
<tr class="separator:a9fa7e717817cab5e190f17d0397ff934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2607ecfbe200094f4bba59ac7c5c390d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a2607ecfbe200094f4bba59ac7c5c390d">tdu</a> () const</td></tr>
<tr class="memdesc:a2607ecfbe200094f4bba59ac7c5c390d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular upper torque-derivative limits (const)  <a href="#a2607ecfbe200094f4bba59ac7c5c390d">More...</a><br /></td></tr>
<tr class="separator:a2607ecfbe200094f4bba59ac7c5c390d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc061e1b33c4f633a04015ab3fb20f94"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#afc061e1b33c4f633a04015ab3fb20f94">ql</a> ()</td></tr>
<tr class="memdesc:afc061e1b33c4f633a04015ab3fb20f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular lower limits.  <a href="#afc061e1b33c4f633a04015ab3fb20f94">More...</a><br /></td></tr>
<tr class="separator:afc061e1b33c4f633a04015ab3fb20f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6915de62543382030defd22b9f8011c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ac6915de62543382030defd22b9f8011c">qu</a> ()</td></tr>
<tr class="memdesc:ac6915de62543382030defd22b9f8011c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular upper limits.  <a href="#ac6915de62543382030defd22b9f8011c">More...</a><br /></td></tr>
<tr class="separator:ac6915de62543382030defd22b9f8011c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8dbaec40be4ad0be51f4df67502d39"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a8a8dbaec40be4ad0be51f4df67502d39">vl</a> ()</td></tr>
<tr class="memdesc:a8a8dbaec40be4ad0be51f4df67502d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular lower velocity limits.  <a href="#a8a8dbaec40be4ad0be51f4df67502d39">More...</a><br /></td></tr>
<tr class="separator:a8a8dbaec40be4ad0be51f4df67502d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c3ad6f7d81353b09689ea6e41eec34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ae6c3ad6f7d81353b09689ea6e41eec34">vu</a> ()</td></tr>
<tr class="memdesc:ae6c3ad6f7d81353b09689ea6e41eec34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular upper velocity limits.  <a href="#ae6c3ad6f7d81353b09689ea6e41eec34">More...</a><br /></td></tr>
<tr class="separator:ae6c3ad6f7d81353b09689ea6e41eec34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64263a01616ad04b3f5212fd5742fd2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ab64263a01616ad04b3f5212fd5742fd2">al</a> ()</td></tr>
<tr class="memdesc:ab64263a01616ad04b3f5212fd5742fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular lower acceleration limits.  <a href="#ab64263a01616ad04b3f5212fd5742fd2">More...</a><br /></td></tr>
<tr class="separator:ab64263a01616ad04b3f5212fd5742fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b41cfc1ed67b789573ca788b6e79cf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ab0b41cfc1ed67b789573ca788b6e79cf">au</a> ()</td></tr>
<tr class="memdesc:ab0b41cfc1ed67b789573ca788b6e79cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular upper acceleration limits.  <a href="#ab0b41cfc1ed67b789573ca788b6e79cf">More...</a><br /></td></tr>
<tr class="separator:ab0b41cfc1ed67b789573ca788b6e79cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6dfded6aa9e9c6ca6ff6d8e386b66d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#adf6dfded6aa9e9c6ca6ff6d8e386b66d">tl</a> ()</td></tr>
<tr class="memdesc:adf6dfded6aa9e9c6ca6ff6d8e386b66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular lower torque limits.  <a href="#adf6dfded6aa9e9c6ca6ff6d8e386b66d">More...</a><br /></td></tr>
<tr class="separator:adf6dfded6aa9e9c6ca6ff6d8e386b66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe854537bd0f1fb8ab64ce91f5f6105d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#afe854537bd0f1fb8ab64ce91f5f6105d">tu</a> ()</td></tr>
<tr class="memdesc:afe854537bd0f1fb8ab64ce91f5f6105d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular upper torque limits.  <a href="#afe854537bd0f1fb8ab64ce91f5f6105d">More...</a><br /></td></tr>
<tr class="separator:afe854537bd0f1fb8ab64ce91f5f6105d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a5fe0d5e143aae2d95ba39e56ab0a9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a39a5fe0d5e143aae2d95ba39e56ab0a9">tdl</a> ()</td></tr>
<tr class="memdesc:a39a5fe0d5e143aae2d95ba39e56ab0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular lower torque-derivative limits.  <a href="#a39a5fe0d5e143aae2d95ba39e56ab0a9">More...</a><br /></td></tr>
<tr class="separator:a39a5fe0d5e143aae2d95ba39e56ab0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a7831e452c28f863abba6992990ac8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a77a7831e452c28f863abba6992990ac8">tdu</a> ()</td></tr>
<tr class="memdesc:a77a7831e452c28f863abba6992990ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the robot's angular upper torque-derivative limits.  <a href="#a77a7831e452c28f863abba6992990ac8">More...</a><br /></td></tr>
<tr class="separator:a77a7831e452c28f863abba6992990ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adada908603cd6527095ccb940d6405bb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="a01628.html">Flexibility</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#adada908603cd6527095ccb940d6405bb">flexibility</a> () const</td></tr>
<tr class="memdesc:adada908603cd6527095ccb940d6405bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the flexibilities of the robot (const)  <a href="#adada908603cd6527095ccb940d6405bb">More...</a><br /></td></tr>
<tr class="separator:adada908603cd6527095ccb940d6405bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b9f6334096f8f9534d4dfab3a89495"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01628.html">Flexibility</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a52b9f6334096f8f9534d4dfab3a89495">flexibility</a> ()</td></tr>
<tr class="memdesc:a52b9f6334096f8f9534d4dfab3a89495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the flexibilities of the robot.  <a href="#a52b9f6334096f8f9534d4dfab3a89495">More...</a><br /></td></tr>
<tr class="separator:a52b9f6334096f8f9534d4dfab3a89495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70ad9c81c418baf93ecccd6a75ff12f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ad70ad9c81c418baf93ecccd6a75ff12f">zmpTarget</a> (const Eigen::Vector3d &amp;<a class="el" href="a01696.html#a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4">zmp</a>)</td></tr>
<tr class="memdesc:ad70ad9c81c418baf93ecccd6a75ff12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target zmp defined with respect to base-link.  <a href="#ad70ad9c81c418baf93ecccd6a75ff12f">More...</a><br /></td></tr>
<tr class="separator:ad70ad9c81c418baf93ecccd6a75ff12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa1d2571113230a15a6726fb06b91fa"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3d &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a8fa1d2571113230a15a6726fb06b91fa">zmpTarget</a> () const</td></tr>
<tr class="memdesc:a8fa1d2571113230a15a6726fb06b91fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target zmp.  <a href="#a8fa1d2571113230a15a6726fb06b91fa">More...</a><br /></td></tr>
<tr class="separator:a8fa1d2571113230a15a6726fb06b91fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357a8bb518ee6ce00d8b25c5437b79c5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a357a8bb518ee6ce00d8b25c5437b79c5">mass</a> () const</td></tr>
<tr class="memdesc:a357a8bb518ee6ce00d8b25c5437b79c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and returns the mass of the robot.  <a href="#a357a8bb518ee6ce00d8b25c5437b79c5">More...</a><br /></td></tr>
<tr class="separator:a357a8bb518ee6ce00d8b25c5437b79c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Joint sensors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions give information about joints' status </p>
</div></td></tr>
<tr class="memitem:a1191c63affb21cb0e15698a48ee83355"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a1191c63affb21cb0e15698a48ee83355">encoderValues</a> () const</td></tr>
<tr class="memdesc:a1191c63affb21cb0e15698a48ee83355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the encoder values.  <a href="#a1191c63affb21cb0e15698a48ee83355">More...</a><br /></td></tr>
<tr class="separator:a1191c63affb21cb0e15698a48ee83355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab757a9c9f2f1a0c2f6a2d0ce73a4c89f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ab757a9c9f2f1a0c2f6a2d0ce73a4c89f">encoderValues</a> (const std::vector&lt; double &gt; &amp;encoderValues)</td></tr>
<tr class="memdesc:ab757a9c9f2f1a0c2f6a2d0ce73a4c89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the encoder values.  <a href="#ab757a9c9f2f1a0c2f6a2d0ce73a4c89f">More...</a><br /></td></tr>
<tr class="separator:ab757a9c9f2f1a0c2f6a2d0ce73a4c89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88153372c03f393b45a9d7ac88df0c5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ad88153372c03f393b45a9d7ac88df0c5">encoderVelocities</a> () const</td></tr>
<tr class="memdesc:ad88153372c03f393b45a9d7ac88df0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the encoder velocities.  <a href="#ad88153372c03f393b45a9d7ac88df0c5">More...</a><br /></td></tr>
<tr class="separator:ad88153372c03f393b45a9d7ac88df0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d2160fc0a6f5a7b206776fa9ac6242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a02d2160fc0a6f5a7b206776fa9ac6242">encoderVelocities</a> (const std::vector&lt; double &gt; &amp;encoderVelocities)</td></tr>
<tr class="memdesc:a02d2160fc0a6f5a7b206776fa9ac6242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the encoder velocities.  <a href="#a02d2160fc0a6f5a7b206776fa9ac6242">More...</a><br /></td></tr>
<tr class="separator:a02d2160fc0a6f5a7b206776fa9ac6242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c07f58dbe7a2cba53e4bec2abc2bdff"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a4c07f58dbe7a2cba53e4bec2abc2bdff">flexibilityValues</a> () const</td></tr>
<tr class="memdesc:a4c07f58dbe7a2cba53e4bec2abc2bdff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the flexibilities values.  <a href="#a4c07f58dbe7a2cba53e4bec2abc2bdff">More...</a><br /></td></tr>
<tr class="separator:a4c07f58dbe7a2cba53e4bec2abc2bdff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458513fda098c7ddd3ffa9f1605dbc0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a458513fda098c7ddd3ffa9f1605dbc0a">flexibilityValues</a> (const std::vector&lt; double &gt; &amp;flexibilityValues)</td></tr>
<tr class="memdesc:a458513fda098c7ddd3ffa9f1605dbc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flexibilities values.  <a href="#a458513fda098c7ddd3ffa9f1605dbc0a">More...</a><br /></td></tr>
<tr class="separator:a458513fda098c7ddd3ffa9f1605dbc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91168b4930361d5a61a60a925ae0cc6d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a91168b4930361d5a61a60a925ae0cc6d">jointTorques</a> () const</td></tr>
<tr class="memdesc:a91168b4930361d5a61a60a925ae0cc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the joint torques from sensors.  <a href="#a91168b4930361d5a61a60a925ae0cc6d">More...</a><br /></td></tr>
<tr class="separator:a91168b4930361d5a61a60a925ae0cc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6661a03573ba04f70c8cd14939dd0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#abc6661a03573ba04f70c8cd14939dd0e">jointTorques</a> (const std::vector&lt; double &gt; &amp;jointTorques)</td></tr>
<tr class="memdesc:abc6661a03573ba04f70c8cd14939dd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set joint torques from sensors.  <a href="#abc6661a03573ba04f70c8cd14939dd0e">More...</a><br /></td></tr>
<tr class="separator:abc6661a03573ba04f70c8cd14939dd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00856f04c24c914b9197fe11f2d573eb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a00856f04c24c914b9197fe11f2d573eb">refJointOrder</a> () const</td></tr>
<tr class="memdesc:a00856f04c24c914b9197fe11f2d573eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference joint order for this robot.  <a href="#a00856f04c24c914b9197fe11f2d573eb">More...</a><br /></td></tr>
<tr class="separator:a00856f04c24c914b9197fe11f2d573eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Force sensors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are related to force sensors </p>
</div></td></tr>
<tr class="memitem:ae6addeeebfb0b899376ed338b212a33a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ae6addeeebfb0b899376ed338b212a33a">hasForceSensor</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:ae6addeeebfb0b899376ed338b212a33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a force sensor exists.  <a href="#ae6addeeebfb0b899376ed338b212a33a">More...</a><br /></td></tr>
<tr class="separator:ae6addeeebfb0b899376ed338b212a33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183b8dbcdcda9c179b83c780bccea04b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a183b8dbcdcda9c179b83c780bccea04b">bodyHasForceSensor</a> (const std::string &amp;body) const</td></tr>
<tr class="memdesc:a183b8dbcdcda9c179b83c780bccea04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the body has a force sensor directly attached to it.  <a href="#a183b8dbcdcda9c179b83c780bccea04b">More...</a><br /></td></tr>
<tr class="separator:a183b8dbcdcda9c179b83c780bccea04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb66cf0e07c2f24d9329cce0f6e5d3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a7fb66cf0e07c2f24d9329cce0f6e5d3b">surfaceHasForceSensor</a> (const std::string &amp;<a class="el" href="a01696.html#aa4b724e51881215dd4293f9578656755">surface</a>) const</td></tr>
<tr class="memdesc:a7fb66cf0e07c2f24d9329cce0f6e5d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the surface has a force sensor directly attached to it.  <a href="#a7fb66cf0e07c2f24d9329cce0f6e5d3b">More...</a><br /></td></tr>
<tr class="separator:a7fb66cf0e07c2f24d9329cce0f6e5d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f6539a36fe9c2e4dc05b1ef3765963"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#af0f6539a36fe9c2e4dc05b1ef3765963">bodyHasIndirectForceSensor</a> (const std::string &amp;body) const</td></tr>
<tr class="memdesc:af0f6539a36fe9c2e4dc05b1ef3765963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the body has a force sensor attached to it (directly or indirectly)  <a href="#af0f6539a36fe9c2e4dc05b1ef3765963">More...</a><br /></td></tr>
<tr class="separator:af0f6539a36fe9c2e4dc05b1ef3765963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05708ca15a7afb1c1b24315f4468356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ae05708ca15a7afb1c1b24315f4468356">surfaceHasIndirectForceSensor</a> (const std::string &amp;<a class="el" href="a01696.html#aa4b724e51881215dd4293f9578656755">surface</a>) const</td></tr>
<tr class="memdesc:ae05708ca15a7afb1c1b24315f4468356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the surface has a force sensor attached to it (directly or indirectly)  <a href="#ae05708ca15a7afb1c1b24315f4468356">More...</a><br /></td></tr>
<tr class="separator:ae05708ca15a7afb1c1b24315f4468356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4b5161096f6e95ceaa57280f951dab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01632.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a4c4b5161096f6e95ceaa57280f951dab">forceSensor</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="memdesc:a4c4b5161096f6e95ceaa57280f951dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a force sensor by name.  <a href="#a4c4b5161096f6e95ceaa57280f951dab">More...</a><br /></td></tr>
<tr class="separator:a4c4b5161096f6e95ceaa57280f951dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d807280f230919ff00adf3d43a5caa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01632.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a40d807280f230919ff00adf3d43a5caa">forceSensor</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:a40d807280f230919ff00adf3d43a5caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant.  <a href="#a40d807280f230919ff00adf3d43a5caa">More...</a><br /></td></tr>
<tr class="separator:a40d807280f230919ff00adf3d43a5caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49efc5c9284a39c13647ff5500138d33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01632.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a49efc5c9284a39c13647ff5500138d33">bodyForceSensor</a> (const std::string &amp;body)</td></tr>
<tr class="memdesc:a49efc5c9284a39c13647ff5500138d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a force sensor attached to the provided body.  <a href="#a49efc5c9284a39c13647ff5500138d33">More...</a><br /></td></tr>
<tr class="separator:a49efc5c9284a39c13647ff5500138d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8ac9af47c038fda22f721e9c1d3a89"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01632.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a7d8ac9af47c038fda22f721e9c1d3a89">bodyForceSensor</a> (const std::string &amp;body) const</td></tr>
<tr class="memdesc:a7d8ac9af47c038fda22f721e9c1d3a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant.  <a href="#a7d8ac9af47c038fda22f721e9c1d3a89">More...</a><br /></td></tr>
<tr class="separator:a7d8ac9af47c038fda22f721e9c1d3a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bfab32c0f157b828a70134f1ffe985"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01632.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ac4bfab32c0f157b828a70134f1ffe985">surfaceForceSensor</a> (const std::string &amp;surfaceName)</td></tr>
<tr class="memdesc:ac4bfab32c0f157b828a70134f1ffe985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a force sensor attached to the provided surface.  <a href="#ac4bfab32c0f157b828a70134f1ffe985">More...</a><br /></td></tr>
<tr class="separator:ac4bfab32c0f157b828a70134f1ffe985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace64ab0161e9b00e262b408733d19629"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01632.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ace64ab0161e9b00e262b408733d19629">surfaceForceSensor</a> (const std::string &amp;surfaceName) const</td></tr>
<tr class="memdesc:ace64ab0161e9b00e262b408733d19629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant.  <a href="#ace64ab0161e9b00e262b408733d19629">More...</a><br /></td></tr>
<tr class="separator:ace64ab0161e9b00e262b408733d19629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901f76e997eccaa20ef748302229edf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01632.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a901f76e997eccaa20ef748302229edf6">indirectBodyForceSensor</a> (const std::string &amp;body)</td></tr>
<tr class="memdesc:a901f76e997eccaa20ef748302229edf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a force sensor directly or indirectly attached to a body.  <a href="#a901f76e997eccaa20ef748302229edf6">More...</a><br /></td></tr>
<tr class="separator:a901f76e997eccaa20ef748302229edf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2ceb538921611b7b50a50634859e5f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01632.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a0c2ceb538921611b7b50a50634859e5f">indirectBodyForceSensor</a> (const std::string &amp;body) const</td></tr>
<tr class="memdesc:a0c2ceb538921611b7b50a50634859e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant.  <a href="#a0c2ceb538921611b7b50a50634859e5f">More...</a><br /></td></tr>
<tr class="separator:a0c2ceb538921611b7b50a50634859e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4733eee02a2b700c1e5ab9796f92b26b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01632.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a4733eee02a2b700c1e5ab9796f92b26b">indirectSurfaceForceSensor</a> (const std::string &amp;<a class="el" href="a01696.html#aa4b724e51881215dd4293f9578656755">surface</a>)</td></tr>
<tr class="memdesc:a4733eee02a2b700c1e5ab9796f92b26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a force sensor directly or indirectly attached to a surface.  <a href="#a4733eee02a2b700c1e5ab9796f92b26b">More...</a><br /></td></tr>
<tr class="separator:a4733eee02a2b700c1e5ab9796f92b26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d7387d7242da1e7c42420583dce311"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01632.html">ForceSensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a77d7387d7242da1e7c42420583dce311">indirectSurfaceForceSensor</a> (const std::string &amp;<a class="el" href="a01696.html#aa4b724e51881215dd4293f9578656755">surface</a>) const</td></tr>
<tr class="memdesc:a77d7387d7242da1e7c42420583dce311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant.  <a href="#a77d7387d7242da1e7c42420583dce311">More...</a><br /></td></tr>
<tr class="separator:a77d7387d7242da1e7c42420583dce311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ece4044d66c5fb62667f7dc91dd6d4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01632.html">ForceSensor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#aa9ece4044d66c5fb62667f7dc91dd6d4">forceSensors</a> ()</td></tr>
<tr class="memdesc:aa9ece4044d66c5fb62667f7dc91dd6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all force sensors.  <a href="#aa9ece4044d66c5fb62667f7dc91dd6d4">More...</a><br /></td></tr>
<tr class="separator:aa9ece4044d66c5fb62667f7dc91dd6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fe91912f91e71eaff0a67af81b4ca0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="a01632.html">ForceSensor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ad3fe91912f91e71eaff0a67af81b4ca0">forceSensors</a> () const</td></tr>
<tr class="memdesc:ad3fe91912f91e71eaff0a67af81b4ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all force sensors (const)  <a href="#ad3fe91912f91e71eaff0a67af81b4ca0">More...</a><br /></td></tr>
<tr class="separator:ad3fe91912f91e71eaff0a67af81b4ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Devices</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are related to generic devices handling </p>
</div></td></tr>
<tr class="memitem:af183f29b2232cbc87cc8dc744f93424e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af183f29b2232cbc87cc8dc744f93424e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01696.html#af183f29b2232cbc87cc8dc744f93424e">hasDevice</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:af183f29b2232cbc87cc8dc744f93424e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a generic device of type T and named name exists in the robot.  <a href="#af183f29b2232cbc87cc8dc744f93424e">More...</a><br /></td></tr>
<tr class="separator:af183f29b2232cbc87cc8dc744f93424e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab011a5322c37711cf940653e7b814b50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab011a5322c37711cf940653e7b814b50"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01696.html#ab011a5322c37711cf940653e7b814b50">hasSensor</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:ab011a5322c37711cf940653e7b814b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for.  <a href="#ab011a5322c37711cf940653e7b814b50">More...</a><br /></td></tr>
<tr class="separator:ab011a5322c37711cf940653e7b814b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3272e412d22bf6d382117300c9ee42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e3272e412d22bf6d382117300c9ee42"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01696.html#a4e3272e412d22bf6d382117300c9ee42">device</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:a4e3272e412d22bf6d382117300c9ee42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a generic device of type T named name.  <a href="#a4e3272e412d22bf6d382117300c9ee42">More...</a><br /></td></tr>
<tr class="separator:a4e3272e412d22bf6d382117300c9ee42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cff71ca3ef36a1f5b5a945d6e70b64b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cff71ca3ef36a1f5b5a945d6e70b64b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01696.html#a6cff71ca3ef36a1f5b5a945d6e70b64b">device</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="memdesc:a6cff71ca3ef36a1f5b5a945d6e70b64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const variant.  <a href="#a6cff71ca3ef36a1f5b5a945d6e70b64b">More...</a><br /></td></tr>
<tr class="separator:a6cff71ca3ef36a1f5b5a945d6e70b64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac945ba1c44d9dfb2f2312d13c8ed24b4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac945ba1c44d9dfb2f2312d13c8ed24b4"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01696.html#ac945ba1c44d9dfb2f2312d13c8ed24b4">sensor</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>) const</td></tr>
<tr class="memdesc:ac945ba1c44d9dfb2f2312d13c8ed24b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for.  <a href="#ac945ba1c44d9dfb2f2312d13c8ed24b4">More...</a><br /></td></tr>
<tr class="separator:ac945ba1c44d9dfb2f2312d13c8ed24b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a8bd2c7daead0016449a6056fd2035"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72a8bd2c7daead0016449a6056fd2035"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01696.html#a72a8bd2c7daead0016449a6056fd2035">sensor</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>)</td></tr>
<tr class="memdesc:a72a8bd2c7daead0016449a6056fd2035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for.  <a href="#a72a8bd2c7daead0016449a6056fd2035">More...</a><br /></td></tr>
<tr class="separator:a72a8bd2c7daead0016449a6056fd2035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1736b85ddedafef83111d6c67ff6f129"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a1736b85ddedafef83111d6c67ff6f129">addDevice</a> (<a class="el" href="a00766.html#a356f67585abd89ae94368d4644d6e865">DevicePtr</a> <a class="el" href="a01696.html#a4e3272e412d22bf6d382117300c9ee42">device</a>)</td></tr>
<tr class="memdesc:a1736b85ddedafef83111d6c67ff6f129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a generic device to the robot.  <a href="#a1736b85ddedafef83111d6c67ff6f129">More...</a><br /></td></tr>
<tr class="separator:a1736b85ddedafef83111d6c67ff6f129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc302e460bc53880eb062681e9e50a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#abc302e460bc53880eb062681e9e50a54">addSensor</a> (<a class="el" href="a00766.html#aa1e86054c466a23bfdcb3470f71c8aad">SensorPtr</a> <a class="el" href="a01696.html#ac945ba1c44d9dfb2f2312d13c8ed24b4">sensor</a>)</td></tr>
<tr class="memdesc:abc302e460bc53880eb062681e9e50a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for.  <a href="#abc302e460bc53880eb062681e9e50a54">More...</a><br /></td></tr>
<tr class="separator:abc302e460bc53880eb062681e9e50a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a51de36111dee056232ab11ac45067d62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a51de36111dee056232ab11ac45067d62">Robot</a> (const std::string &amp;<a class="el" href="a01696.html#a9f0c4c44861063b684d43d4ad78a995e">name</a>, <a class="el" href="a01736.html">Robots</a> &amp;robots, unsigned int robots_idx, bool loadFiles, const sva::PTransformd *base=nullptr, const std::string &amp;baseName=&quot;&quot;)</td></tr>
<tr class="memdesc:a51de36111dee056232ab11ac45067d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by <a class="el" href="a01736.html">Robots</a> parent instance after mb/mbc/mbg/RobotModule are stored.  <a href="#a51de36111dee056232ab11ac45067d62">More...</a><br /></td></tr>
<tr class="separator:a51de36111dee056232ab11ac45067d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1c0713e88cb71a2a9971868cc4fc8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#acd1c0713e88cb71a2a9971868cc4fc8d">copy</a> (<a class="el" href="a01736.html">Robots</a> &amp;robots, const std::string &amp;copyName, unsigned int robots_idx, const <a class="el" href="a01576.html">Base</a> &amp;base) const</td></tr>
<tr class="memdesc:acd1c0713e88cb71a2a9971868cc4fc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing <a class="el" href="a01696.html">Robot</a> with a new base.  <a href="#acd1c0713e88cb71a2a9971868cc4fc8d">More...</a><br /></td></tr>
<tr class="separator:acd1c0713e88cb71a2a9971868cc4fc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91ec5960fce1e8f2a2466af047bcebb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#ac91ec5960fce1e8f2a2466af047bcebb">copy</a> (<a class="el" href="a01736.html">Robots</a> &amp;robots, const std::string &amp;copyName, unsigned int robots_idx) const</td></tr>
<tr class="memdesc:ac91ec5960fce1e8f2a2466af047bcebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing <a class="el" href="a01696.html">Robot</a>.  <a href="#ac91ec5960fce1e8f2a2466af047bcebb">More...</a><br /></td></tr>
<tr class="separator:ac91ec5960fce1e8f2a2466af047bcebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218dfb7dbc50f94466e30871869b967d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a218dfb7dbc50f94466e30871869b967d">fixSurfaces</a> ()</td></tr>
<tr class="memdesc:a218dfb7dbc50f94466e30871869b967d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to set the surfaces' X_b_s correctly.  <a href="#a218dfb7dbc50f94466e30871869b967d">More...</a><br /></td></tr>
<tr class="separator:a218dfb7dbc50f94466e30871869b967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005d9859a7272ac6dbcab9c31aef8092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a005d9859a7272ac6dbcab9c31aef8092">fixCollisionTransforms</a> ()</td></tr>
<tr class="memdesc:a005d9859a7272ac6dbcab9c31aef8092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to set the collision transforms correctly.  <a href="#a005d9859a7272ac6dbcab9c31aef8092">More...</a><br /></td></tr>
<tr class="separator:a005d9859a7272ac6dbcab9c31aef8092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec9236c7e0a6848e0fb76704ea64372"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#adec9236c7e0a6848e0fb76704ea64372">findIndirectForceSensorBodyName</a> (const std::string &amp;bodyName) const</td></tr>
<tr class="memdesc:adec9236c7e0a6848e0fb76704ea64372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the name of the body to which a force sensor is attached, starting from the provided body and going up the kinematic tree.  <a href="#adec9236c7e0a6848e0fb76704ea64372">More...</a><br /></td></tr>
<tr class="separator:adec9236c7e0a6848e0fb76704ea64372"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7ea6242bb22401bac23542e1db3a74ed"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01696.html#a7ea6242bb22401bac23542e1db3a74ed">Robots</a></td></tr>
<tr class="separator:a7ea6242bb22401bac23542e1db3a74ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aeaf56b7bf79a4e2be37e3c8615d156ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf56b7bf79a4e2be37e3c8615d156ad">&#9670;&nbsp;</a></span>convex_pair_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a01696.html#aeaf56b7bf79a4e2be37e3c8615d156ad">mc_rbdyn::Robot::convex_pair_t</a> =  std::pair&lt;std::string, <a class="el" href="a01696.html#a28270fdeec598bc23d8761191a6226d4">S_ObjectPtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28270fdeec598bc23d8761191a6226d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28270fdeec598bc23d8761191a6226d4">&#9670;&nbsp;</a></span>S_ObjectPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a01696.html#a28270fdeec598bc23d8761191a6226d4">mc_rbdyn::Robot::S_ObjectPtr</a> =  std::shared_ptr&lt;sch::S_Object&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a023a2a4a841760ae65a2d868bb6139fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023a2a4a841760ae65a2d868bb6139fa">&#9670;&nbsp;</a></span>Robot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mc_rbdyn::Robot::Robot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01696.html">Robot</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51de36111dee056232ab11ac45067d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51de36111dee056232ab11ac45067d62">&#9670;&nbsp;</a></span>Robot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mc_rbdyn::Robot::Robot </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01736.html">Robots</a> &amp;&#160;</td>
          <td class="paramname"><em>robots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>robots_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loadFiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::PTransformd *&#160;</td>
          <td class="paramname"><em>base</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by <a class="el" href="a01736.html">Robots</a> parent instance after mb/mbc/mbg/RobotModule are stored. </p>
<p>When loadFiles is set to false, the convex and surfaces files are not loaded. This is used when copying one robot into another. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8c7a59334340cf8b44a10c6c9cb64d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7a59334340cf8b44a10c6c9cb64d76">&#9670;&nbsp;</a></span>accW() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::accW </td>
          <td>(</td>
          <td class="paramtype">const sva::MotionVecd &amp;&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the robot's floating base acceleration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vel</td><td>New floating base acceleration in the inertial frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function takes care of calling rbd::forwardAcceleration </dd></dl>

</div>
</div>
<a id="a30b21b6e828397cebd4f015cf9e87f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b21b6e828397cebd4f015cf9e87f44">&#9670;&nbsp;</a></span>accW() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::MotionVecd mc_rbdyn::Robot::accW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the robot's floating base acceleration expressed in the inertial frame. </p>

</div>
</div>
<a id="ae30c16125ec220e6525f86339d894a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30c16125ec220e6525f86339d894a3c">&#9670;&nbsp;</a></span>addConvex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::addConvex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01696.html#a28270fdeec598bc23d8761191a6226d4">S_ObjectPtr</a>&#160;</td>
          <td class="paramname"><em>convex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::PTransformd &amp;&#160;</td>
          <td class="paramname"><em>X_b_c</em> = <code>sva::PTransformd::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a convex online. </p>
<p>This has no effect if <code>name</code> is already a convex of the robot</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the convex</td></tr>
    <tr><td class="paramname">body</td><td>Name of the convex's parent body</td></tr>
    <tr><td class="paramname">convex</td><td>sch::Object object representing the convex</td></tr>
    <tr><td class="paramname">X_b_c</td><td>Transformation fro the convex's parent body to the convex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1736b85ddedafef83111d6c67ff6f129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1736b85ddedafef83111d6c67ff6f129">&#9670;&nbsp;</a></span>addDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::addDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00766.html#a356f67585abd89ae94368d4644d6e865">DevicePtr</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a generic device to the robot. </p>

</div>
</div>
<a id="abc302e460bc53880eb062681e9e50a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc302e460bc53880eb062681e9e50a54">&#9670;&nbsp;</a></span>addSensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::addSensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00766.html#aa1e86054c466a23bfdcb3470f71c8aad">SensorPtr</a>&#160;</td>
          <td class="paramname"><em>sensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01696.html#a1736b85ddedafef83111d6c67ff6f129" title="Add a generic device to the robot. ">addDevice</a> </dd></dl>

</div>
</div>
<a id="a02691447f1d554276f01339ba6c3aad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02691447f1d554276f01339ba6c3aad7">&#9670;&nbsp;</a></span>addSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::addSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00766.html#a848cf0b2e8f6ca6f18ceba1769d9a426">mc_rbdyn::SurfacePtr</a>&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doNotReplace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a surface with a new name. </p>

</div>
</div>
<a id="a353666f3eb88becdbde844f6e6915807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353666f3eb88becdbde844f6e6915807">&#9670;&nbsp;</a></span>al() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::al </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular lower acceleration limits (const) </p>

</div>
</div>
<a id="ab64263a01616ad04b3f5212fd5742fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64263a01616ad04b3f5212fd5742fd2">&#9670;&nbsp;</a></span>al() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::al </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular lower acceleration limits. </p>

</div>
</div>
<a id="a5773f91f2a9d0eb5cb4b6a0943551a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5773f91f2a9d0eb5cb4b6a0943551a1b">&#9670;&nbsp;</a></span>alpha() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::alpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().alpha (const) </p>

</div>
</div>
<a id="ad36db2265563e037f7b98f2a3b8ac826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36db2265563e037f7b98f2a3b8ac826">&#9670;&nbsp;</a></span>alpha() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::alpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().alpha. </p>

</div>
</div>
<a id="aeca1f147be470012cb1203f95d5c5abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca1f147be470012cb1203f95d5c5abe">&#9670;&nbsp;</a></span>alphaD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::alphaD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().alphaD (const) </p>

</div>
</div>
<a id="a611ff3ed6802a623056076abba7283ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611ff3ed6802a623056076abba7283ac">&#9670;&nbsp;</a></span>alphaD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::alphaD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().alphaD. </p>

</div>
</div>
<a id="ab0b3183f0c2579662c80c1c94aca9410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b3183f0c2579662c80c1c94aca9410">&#9670;&nbsp;</a></span>au() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::au </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular upper acceleration limits (const) </p>

</div>
</div>
<a id="ab0b41cfc1ed67b789573ca788b6e79cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b41cfc1ed67b789573ca788b6e79cf">&#9670;&nbsp;</a></span>au() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::au </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular upper acceleration limits. </p>

</div>
</div>
<a id="aac0e0346563b3ba8d3fda355e27367a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0e0346563b3ba8d3fda355e27367a8">&#9670;&nbsp;</a></span>availableSurfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; mc_rbdyn::Robot::availableSurfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of available surfaces. </p>

</div>
</div>
<a id="a1e4739f4a8c3d2ac6a20797e7287b959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4739f4a8c3d2ac6a20797e7287b959">&#9670;&nbsp;</a></span>bodyAccB() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyAccB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().bodyAccB (const) </p>

</div>
</div>
<a id="accfdb088e19e290eea18767e249ca79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfdb088e19e290eea18767e249ca79e">&#9670;&nbsp;</a></span>bodyAccB() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyAccB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().bodyAccB. </p>

</div>
</div>
<a id="a81e766814295ca73b3bf6da8e90f4421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e766814295ca73b3bf6da8e90f4421">&#9670;&nbsp;</a></span>bodyAccB() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::MotionVecd&amp; mc_rbdyn::Robot::bodyAccB </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the acceleration of body <code>name</code> in body coordinates. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the body doest not exist within the robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a5ebf8a9421a34de48c2b31449478cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5ebf8a9421a34de48c2b31449478cc">&#9670;&nbsp;</a></span>bodyBodySensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01580.html">BodySensor</a>&amp; mc_rbdyn::Robot::bodyBodySensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a specific <a class="el" href="a01580.html" title="This structure defines a body sensor, that is a sensor that provides dynamic information about a body...">BodySensor</a> by body name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the body</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>there is no sensor attached to the body </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4faa529e12f2d401c2d7a805f07ae75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4faa529e12f2d401c2d7a805f07ae75">&#9670;&nbsp;</a></span>bodyBodySensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01580.html">BodySensor</a>&amp; mc_rbdyn::Robot::bodyBodySensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a specific <a class="el" href="a01580.html" title="This structure defines a body sensor, that is a sensor that provides dynamic information about a body...">BodySensor</a> by body name (const) </p>

</div>
</div>
<a id="a49efc5c9284a39c13647ff5500138d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49efc5c9284a39c13647ff5500138d33">&#9670;&nbsp;</a></span>bodyForceSensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01632.html">ForceSensor</a>&amp; mc_rbdyn::Robot::bodyForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a force sensor attached to the provided body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>Name of the body to which the sensor is attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attached sensor</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is directly attached to this body</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01632.html" title="This struct is intended to hold static information about a force sensor and the current reading of sa...">ForceSensor</a> &amp; <a class="el" href="a01696.html#a901f76e997eccaa20ef748302229edf6" title="Return a force sensor directly or indirectly attached to a body. ">indirectBodyForceSensor(const std::string &amp; body)</a>; To get a <a class="el" href="a01696.html#ac945ba1c44d9dfb2f2312d13c8ed24b4" title="Alias for. ">sensor</a> directly or indirectly attached to the body. </dd></dl>

</div>
</div>
<a id="a7d8ac9af47c038fda22f721e9c1d3a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8ac9af47c038fda22f721e9c1d3a89">&#9670;&nbsp;</a></span>bodyForceSensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01632.html">ForceSensor</a>&amp; mc_rbdyn::Robot::bodyForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const variant. </p>

</div>
</div>
<a id="a558d26564bdb4888db21b2ae13d32f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558d26564bdb4888db21b2ae13d32f39">&#9670;&nbsp;</a></span>bodyHasBodySensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::bodyHasBodySensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified body has a body sensor attached to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>Body to query </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a183b8dbcdcda9c179b83c780bccea04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183b8dbcdcda9c179b83c780bccea04b">&#9670;&nbsp;</a></span>bodyHasForceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::bodyHasForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the body has a force sensor directly attached to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>Name of the body to which the sensor is directly attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>bodyHasIndirectForceSensor(const std::string &amp;) if you wish to check whether a <a class="el" href="a01696.html#ac945ba1c44d9dfb2f2312d13c8ed24b4" title="Alias for. ">sensor</a> is indirectly attached to a body</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the body has a force sensor attached to it, false otherwise </dd></dl>

</div>
</div>
<a id="af0f6539a36fe9c2e4dc05b1ef3765963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f6539a36fe9c2e4dc05b1ef3765963">&#9670;&nbsp;</a></span>bodyHasIndirectForceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::bodyHasIndirectForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the body has a force sensor attached to it (directly or indirectly) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>Name of the body to which the sensor is (directly or indirectly) attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the body has a force sensor attached to it, false otherwise </dd></dl>

</div>
</div>
<a id="a5309b5ef9bb5b91bf0f1adb59813bde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5309b5ef9bb5b91bf0f1adb59813bde4">&#9670;&nbsp;</a></span>bodyIndexByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mc_rbdyn::Robot::bodyIndexByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e9415aa6bf2421a5e76bd85b04359b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9415aa6bf2421a5e76bd85b04359b1">&#9670;&nbsp;</a></span>bodyPosW() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sva::PTransformd&gt;&amp; mc_rbdyn::Robot::bodyPosW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().bodyPosW (const) </p>

</div>
</div>
<a id="adf0aad75ddf11178d780abe0a64d7021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0aad75ddf11178d780abe0a64d7021">&#9670;&nbsp;</a></span>bodyPosW() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;sva::PTransformd&gt;&amp; mc_rbdyn::Robot::bodyPosW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().bodyPosW. </p>

</div>
</div>
<a id="af7764d03bd41fedfa98443d4a0b262e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7764d03bd41fedfa98443d4a0b262e9">&#9670;&nbsp;</a></span>bodyPosW() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::PTransformd&amp; mc_rbdyn::Robot::bodyPosW </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the position of body <code>name</code> in world coordinates. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the body does not exist within the robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3effaf63deb70c0d2463cf374cc2e7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3effaf63deb70c0d2463cf374cc2e7c1">&#9670;&nbsp;</a></span>bodySensor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01580.html">BodySensor</a>&amp; mc_rbdyn::Robot::bodySensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first <a class="el" href="a01580.html" title="This structure defines a body sensor, that is a sensor that provides dynamic information about a body...">BodySensor</a> in the robot. </p>
<p>If the robot does not have body sensors, it returns a default (invalid) one </p>

</div>
</div>
<a id="a3e34acaf5dc3b279cc97e5cd4c215708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e34acaf5dc3b279cc97e5cd4c215708">&#9670;&nbsp;</a></span>bodySensor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01580.html">BodySensor</a>&amp; mc_rbdyn::Robot::bodySensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first <a class="el" href="a01580.html" title="This structure defines a body sensor, that is a sensor that provides dynamic information about a body...">BodySensor</a> in the robot (const) </p>

</div>
</div>
<a id="a439af8f5d3edc70f1f8cf8b947c61cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439af8f5d3edc70f1f8cf8b947c61cdd">&#9670;&nbsp;</a></span>bodySensor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01580.html">BodySensor</a>&amp; mc_rbdyn::Robot::bodySensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a specific BobySensor by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the sensor does not exist </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e04286463ae6f91105c0b83ef370da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e04286463ae6f91105c0b83ef370da8">&#9670;&nbsp;</a></span>bodySensor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01580.html">BodySensor</a>&amp; mc_rbdyn::Robot::bodySensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a specific <a class="el" href="a01580.html" title="This structure defines a body sensor, that is a sensor that provides dynamic information about a body...">BodySensor</a> by name (const) </p>

</div>
</div>
<a id="a0a7aeb8979e469e5d34c4ffea9267a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7aeb8979e469e5d34c4ffea9267a70">&#9670;&nbsp;</a></span>bodySensors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00766.html#a728d731db2806e7673f67b958970e558">BodySensorVector</a>&amp; mc_rbdyn::Robot::bodySensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all body sensors. </p>

</div>
</div>
<a id="ace8a8b93689ec20b516f8d0ae460ea80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8a8b93689ec20b516f8d0ae460ea80">&#9670;&nbsp;</a></span>bodySensors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00766.html#a728d731db2806e7673f67b958970e558">BodySensorVector</a>&amp; mc_rbdyn::Robot::bodySensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all body sensors (const) </p>

</div>
</div>
<a id="a91bd5ae09effe07a9a766050bcfee859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bd5ae09effe07a9a766050bcfee859">&#9670;&nbsp;</a></span>bodyTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::PTransformd&amp; mc_rbdyn::Robot::bodyTransform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access transformation from body <code>bName</code> to original base. </p>
<p>This can be used to correct transformations that were stored with the original base. Usually the robot's base is the original base so these transforms are identity. </p>

</div>
</div>
<a id="a022bd9c9318d298da53c823ca93b5f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022bd9c9318d298da53c823ca93b5f1c">&#9670;&nbsp;</a></span>bodyTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::PTransformd&amp; mc_rbdyn::Robot::bodyTransform </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bodyIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access body transform by index. </p>

</div>
</div>
<a id="a135b6be808af82a5b0d21ffda5a8fe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135b6be808af82a5b0d21ffda5a8fe17">&#9670;&nbsp;</a></span>bodyTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sva::PTransformd&gt;&amp; mc_rbdyn::Robot::bodyTransforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access body transform vector. </p>

</div>
</div>
<a id="ac4ce1f653158bc3b79dd903ee1c05d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ce1f653158bc3b79dd903ee1c05d9c">&#9670;&nbsp;</a></span>bodyVelB() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyVelB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().bodyVelB (const) </p>

</div>
</div>
<a id="a54b38b6bbe93a7b6cc48d9091e9ee8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b38b6bbe93a7b6cc48d9091e9ee8b5">&#9670;&nbsp;</a></span>bodyVelB() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyVelB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().bodyVelB. </p>

</div>
</div>
<a id="a86619b4049ec59d383a445bafe43830e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86619b4049ec59d383a445bafe43830e">&#9670;&nbsp;</a></span>bodyVelB() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::MotionVecd&amp; mc_rbdyn::Robot::bodyVelB </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the velocity of body <code>name</code> in body coordinates. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the body doest not exist within the robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad1bcd2edaa8eeb17033ae3fafe1bde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1bcd2edaa8eeb17033ae3fafe1bde8">&#9670;&nbsp;</a></span>bodyVelW() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyVelW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().bodyVelW (const) </p>

</div>
</div>
<a id="a252c64f915ca619afcdcf27e9dd63dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252c64f915ca619afcdcf27e9dd63dd2">&#9670;&nbsp;</a></span>bodyVelW() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;sva::MotionVecd&gt;&amp; mc_rbdyn::Robot::bodyVelW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().bodyVelW. </p>

</div>
</div>
<a id="abc4808b0299894e9343b6c27b1cc6e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4808b0299894e9343b6c27b1cc6e14">&#9670;&nbsp;</a></span>bodyVelW() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::MotionVecd&amp; mc_rbdyn::Robot::bodyVelW </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the velocity of body <code>name</code> in world coordinates. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the body doest not exist within the robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a207f3ea22bce722a3d68ac37aed8ca03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207f3ea22bce722a3d68ac37aed8ca03">&#9670;&nbsp;</a></span>bodyWrench()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sva::ForceVecd mc_rbdyn::Robot::bodyWrench </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bodyName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gravity-free wrench in body frame. </p>
<dl class="section note"><dt>Note</dt><dd>If the body is indirectly attached to the sensor (i.e there are joints in-between), then the kinematic transformation will be taken into account but the effect of bodies in-between is not accounted for in the returned wrench.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bodyName</td><td>A body attached to a force sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Measured wrench in body frame</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is attached to this surface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af239b709cd1907f1aa264dfa2cb9fd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af239b709cd1907f1aa264dfa2cb9fd15">&#9670;&nbsp;</a></span>collisionTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::PTransformd&amp; mc_rbdyn::Robot::collisionTransform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access transformation between the collision mesh and the body. </p>

</div>
</div>
<a id="a4e858c693b7e94ded9704e13463e1ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e858c693b7e94ded9704e13463e1ae5">&#9670;&nbsp;</a></span>com()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::com </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and returns the current robot's CoM. </p>

</div>
</div>
<a id="a68f1932b13b8a4589f66dd792522e1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f1932b13b8a4589f66dd792522e1ae">&#9670;&nbsp;</a></span>comAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::comAcceleration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and returns the current robot's CoM acceleration. </p>

</div>
</div>
<a id="aa17c3d6b4bff8b9bcbedad822a86fdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17c3d6b4bff8b9bcbedad822a86fdbc">&#9670;&nbsp;</a></span>comVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::comVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and returns the current robot's CoM velocity. </p>

</div>
</div>
<a id="a7fa487585e4b6d447c69ba78d9eca203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa487585e4b6d447c69ba78d9eca203">&#9670;&nbsp;</a></span>convex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01696.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a>&amp; mc_rbdyn::Robot::convex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a convex named <code>cName</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair giving the convex's parent body and the sch::Object object </dd></dl>

</div>
</div>
<a id="a2b2dc756cfb84c337de115384febab34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2dc756cfb84c337de115384febab34">&#9670;&nbsp;</a></span>convex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01696.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a>&amp; mc_rbdyn::Robot::convex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a convex named <code>cName</code> (const) </p>

</div>
</div>
<a id="aa176323f1dd1dc8f29ad40ccd4b23c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa176323f1dd1dc8f29ad40ccd4b23c9d">&#9670;&nbsp;</a></span>convexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="a01696.html#aeaf56b7bf79a4e2be37e3c8615d156ad">convex_pair_t</a>&gt;&amp; mc_rbdyn::Robot::convexes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access all convexes available in this robot. </p>
<dl class="section return"><dt>Returns</dt><dd>a map where keys are the convex name and values are those returned by <a class="el" href="a01696.html#a7fa487585e4b6d447c69ba78d9eca203">convex</a> </dd></dl>

</div>
</div>
<a id="a411485264496b268c8ace71adcc3e75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411485264496b268c8ace71adcc3e75e">&#9670;&nbsp;</a></span>cop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector2d mc_rbdyn::Robot::cop </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surfaceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_pressure</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cop in surface frame computed from gravity-free force measurements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceName</td><td>A surface attached to a force sensor </td></tr>
    <tr><td class="paramname">min_pressure</td><td>Minimum pressure in N (default 0.5N).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Measured cop in surface frame<ul>
<li>CoP if pressure &gt;= min_pressure</li>
<li>Zero otherwise</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is attached to this surface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2042bcdb8f612347b16e72c1853d0f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2042bcdb8f612347b16e72c1853d0f1a">&#9670;&nbsp;</a></span>copW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::copW </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surfaceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_pressure</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cop in inertial frame compute from gravity-free force measurements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceName</td><td>A surface attached to a force sensor </td></tr>
    <tr><td class="paramname">min_pressure</td><td>Minimum pressure in N (default 0.5N).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Measured cop in inertial frame<ul>
<li>CoP if pressure &gt;= min_pressure</li>
<li>Zero otherwise</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is attached to this surface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd1c0713e88cb71a2a9971868cc4fc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1c0713e88cb71a2a9971868cc4fc8d">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01736.html">Robots</a> &amp;&#160;</td>
          <td class="paramname"><em>robots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>copyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>robots_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01576.html">Base</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy existing <a class="el" href="a01696.html">Robot</a> with a new base. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if a robot named &lt;copyName&gt; already exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac91ec5960fce1e8f2a2466af047bcebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91ec5960fce1e8f2a2466af047bcebb">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01736.html">Robots</a> &amp;&#160;</td>
          <td class="paramname"><em>robots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>copyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>robots_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy existing <a class="el" href="a01696.html">Robot</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if a robot named &lt;copyName&gt; already exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9eac94be22b1481eaae48d110d97c49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eac94be22b1481eaae48d110d97c49e">&#9670;&nbsp;</a></span>copySurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01744.html">mc_rbdyn::Surface</a>&amp; mc_rbdyn::Robot::copySurface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy an existing surface with a new name. </p>

</div>
</div>
<a id="a4e3272e412d22bf6d382117300c9ee42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3272e412d22bf6d382117300c9ee42">&#9670;&nbsp;</a></span>device() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; mc_rbdyn::Robot::device </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a generic device of type T named name. </p>
<p>The reference returned by this function is remains valid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the device requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the device does not exist or does not have the right type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cff71ca3ef36a1f5b5a945d6e70b64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cff71ca3ef36a1f5b5a945d6e70b64b">&#9670;&nbsp;</a></span>device() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; mc_rbdyn::Robot::device </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-const variant. </p>

</div>
</div>
<a id="a1191c63affb21cb0e15698a48ee83355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1191c63affb21cb0e15698a48ee83355">&#9670;&nbsp;</a></span>encoderValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; mc_rbdyn::Robot::encoderValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the encoder values. </p>

</div>
</div>
<a id="ab757a9c9f2f1a0c2f6a2d0ce73a4c89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab757a9c9f2f1a0c2f6a2d0ce73a4c89f">&#9670;&nbsp;</a></span>encoderValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::encoderValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>encoderValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the encoder values. </p>

</div>
</div>
<a id="ad88153372c03f393b45a9d7ac88df0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88153372c03f393b45a9d7ac88df0c5">&#9670;&nbsp;</a></span>encoderVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; mc_rbdyn::Robot::encoderVelocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the encoder velocities. </p>

</div>
</div>
<a id="a02d2160fc0a6f5a7b206776fa9ac6242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d2160fc0a6f5a7b206776fa9ac6242">&#9670;&nbsp;</a></span>encoderVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::encoderVelocities </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>encoderVelocities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the encoder velocities. </p>

</div>
</div>
<a id="acd1794c11cac282d7c042216d431ebb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1794c11cac282d7c042216d431ebb7">&#9670;&nbsp;</a></span>eulerIntegration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::eulerIntegration </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply Euler integration to the robot using <code>step</code> timestep. </p>

</div>
</div>
<a id="ae8d130fc22dda8e9bfbecad28acc26a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d130fc22dda8e9bfbecad28acc26a5">&#9670;&nbsp;</a></span>eulerIntegration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::eulerIntegration </td>
          <td>(</td>
          <td class="paramtype">rbd::MultiBodyConfig &amp;&#160;</td>
          <td class="paramname"><em>mbc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply Euler integration to <code>mbc</code> using the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a> and <code>step</code> timestep. </p>

</div>
</div>
<a id="adec9236c7e0a6848e0fb76704ea64372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec9236c7e0a6848e0fb76704ea64372">&#9670;&nbsp;</a></span>findIndirectForceSensorBodyName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mc_rbdyn::Robot::findIndirectForceSensorBodyName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bodyName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the name of the body to which a force sensor is attached, starting from the provided body and going up the kinematic tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bodyName</td><td>Name of the body to which the sensor is attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Body name to which the sensor is attached when found. Empty string otherwise </dd></dl>

</div>
</div>
<a id="a005d9859a7272ac6dbcab9c31aef8092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005d9859a7272ac6dbcab9c31aef8092">&#9670;&nbsp;</a></span>fixCollisionTransforms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::fixCollisionTransforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to set the collision transforms correctly. </p>

</div>
</div>
<a id="a218dfb7dbc50f94466e30871869b967d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218dfb7dbc50f94466e30871869b967d">&#9670;&nbsp;</a></span>fixSurfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::fixSurfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to set the surfaces' X_b_s correctly. </p>

</div>
</div>
<a id="adada908603cd6527095ccb940d6405bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adada908603cd6527095ccb940d6405bb">&#9670;&nbsp;</a></span>flexibility() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="a01628.html">Flexibility</a>&gt;&amp; mc_rbdyn::Robot::flexibility </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the flexibilities of the robot (const) </p>

</div>
</div>
<a id="a52b9f6334096f8f9534d4dfab3a89495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b9f6334096f8f9534d4dfab3a89495">&#9670;&nbsp;</a></span>flexibility() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a01628.html">Flexibility</a>&gt;&amp; mc_rbdyn::Robot::flexibility </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the flexibilities of the robot. </p>

</div>
</div>
<a id="a4c07f58dbe7a2cba53e4bec2abc2bdff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c07f58dbe7a2cba53e4bec2abc2bdff">&#9670;&nbsp;</a></span>flexibilityValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; mc_rbdyn::Robot::flexibilityValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the flexibilities values. </p>

</div>
</div>
<a id="a458513fda098c7ddd3ffa9f1605dbc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458513fda098c7ddd3ffa9f1605dbc0a">&#9670;&nbsp;</a></span>flexibilityValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::flexibilityValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>flexibilityValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flexibilities values. </p>

</div>
</div>
<a id="a4c4b5161096f6e95ceaa57280f951dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4b5161096f6e95ceaa57280f951dab">&#9670;&nbsp;</a></span>forceSensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01632.html">ForceSensor</a>&amp; mc_rbdyn::Robot::forceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a force sensor by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sensor named name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor with this name exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40d807280f230919ff00adf3d43a5caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d807280f230919ff00adf3d43a5caa">&#9670;&nbsp;</a></span>forceSensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01632.html">ForceSensor</a>&amp; mc_rbdyn::Robot::forceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const variant. </p>

</div>
</div>
<a id="aa9ece4044d66c5fb62667f7dc91dd6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ece4044d66c5fb62667f7dc91dd6d4">&#9670;&nbsp;</a></span>forceSensors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a01632.html">ForceSensor</a>&gt;&amp; mc_rbdyn::Robot::forceSensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all force sensors. </p>

</div>
</div>
<a id="ad3fe91912f91e71eaff0a67af81b4ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fe91912f91e71eaff0a67af81b4ca0">&#9670;&nbsp;</a></span>forceSensors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="a01632.html">ForceSensor</a>&gt;&amp; mc_rbdyn::Robot::forceSensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all force sensors (const) </p>

</div>
</div>
<a id="ab7c546ec0809807016d316229d1d29c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c546ec0809807016d316229d1d29c0">&#9670;&nbsp;</a></span>forwardAcceleration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardAcceleration </td>
          <td>(</td>
          <td class="paramtype">const sva::MotionVecd &amp;&#160;</td>
          <td class="paramname"><em>A_0</em> = <code>sva::MotionVecd(Eigen::Vector6d::Zero())</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply forward acceleration to the robot. </p>

</div>
</div>
<a id="ad5564b8d60b3dd8fa3e88e31f8f93a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5564b8d60b3dd8fa3e88e31f8f93a02">&#9670;&nbsp;</a></span>forwardAcceleration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardAcceleration </td>
          <td>(</td>
          <td class="paramtype">rbd::MultiBodyConfig &amp;&#160;</td>
          <td class="paramname"><em>mbc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::MotionVecd &amp;&#160;</td>
          <td class="paramname"><em>A_0</em> = <code>sva::MotionVecd(Eigen::Vector6d::Zero())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply forward acceleration to <code>mbc</code> using the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a> </p>

</div>
</div>
<a id="ae46b693d4431e61db9f1d4a05f66dd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46b693d4431e61db9f1d4a05f66dd5e">&#9670;&nbsp;</a></span>forwardKinematics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardKinematics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply forward kinematics to the robot. </p>

</div>
</div>
<a id="a9520af131693e9b873ce4c37513cfa1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9520af131693e9b873ce4c37513cfa1d">&#9670;&nbsp;</a></span>forwardKinematics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardKinematics </td>
          <td>(</td>
          <td class="paramtype">rbd::MultiBodyConfig &amp;&#160;</td>
          <td class="paramname"><em>mbc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply forward kinematics to <code>mbc</code> using the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a> </p>

</div>
</div>
<a id="afd93342dd86da6803288346a3798d374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd93342dd86da6803288346a3798d374">&#9670;&nbsp;</a></span>forwardVelocity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply forward velocity to the robot. </p>

</div>
</div>
<a id="a73998aca81be7062371f39ce5d60756a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73998aca81be7062371f39ce5d60756a">&#9670;&nbsp;</a></span>forwardVelocity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::forwardVelocity </td>
          <td>(</td>
          <td class="paramtype">rbd::MultiBodyConfig &amp;&#160;</td>
          <td class="paramname"><em>mbc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply forward velocity to <code>mbc</code> using the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a> </p>

</div>
</div>
<a id="a8b970df4059237f37021b47d5aaf2494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b970df4059237f37021b47d5aaf2494">&#9670;&nbsp;</a></span>gripper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01476.html">mc_control::Gripper</a>&amp; mc_rbdyn::Robot::gripper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gripper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a gripper by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gripper</td><td>Gripper name</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the gripper does not exist within this robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa96f71ad7e9c085d622c4885c15f1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa96f71ad7e9c085d622c4885c15f1bb">&#9670;&nbsp;</a></span>grippers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="a00761.html#a39b3dee4f4017bab0f389d9bfd7877dc">mc_control::GripperRef</a>&gt;&amp; mc_rbdyn::Robot::grippers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access all grippers. </p>

<p class="reference">References <a class="el" href="a03385.html#a5f64edebd03a669545de1ba699d6cb49">MC_RBDYN_DLLAPI</a>, <a class="el" href="a00759.html#ga70b316b2f0c0caf547e160e74c2a029d">mc_rbdyn::robotFromConfig()</a>, <a class="el" href="a00759.html#gaf9b711ec2baa5684b8f422d740464b5f">mc_rbdyn::robotIndexFromConfig()</a>, and <a class="el" href="a00759.html#ga40325ac769295d23f270976eead26245">mc_rbdyn::robotNameFromConfig()</a>.</p>

</div>
</div>
<a id="a6b0c83dbee42dff616909c21b90825b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0c83dbee42dff616909c21b90825b8">&#9670;&nbsp;</a></span>grippersByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;std::string, <a class="el" href="a00761.html#a67d3b51822d3e7d0c56d9af675f9eaa1">mc_control::GripperPtr</a>&gt;&amp; mc_rbdyn::Robot::grippersByName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8353aa6a66630a85c9249298ed960c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8353aa6a66630a85c9249298ed960c6a">&#9670;&nbsp;</a></span>hasBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the robot has a body named <code>name</code>. </p>

</div>
</div>
<a id="a2572eb64a1ab6318f715e0163400e4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2572eb64a1ab6318f715e0163400e4bf">&#9670;&nbsp;</a></span>hasBodySensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasBodySensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the robot has a body sensor named name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the body sensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75aa71c0145f03a620619e8fe8b96107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aa71c0145f03a620619e8fe8b96107">&#9670;&nbsp;</a></span>hasConvex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasConvex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a convex <code>name</code> exists. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the convex exists, false otherwise </dd></dl>

</div>
</div>
<a id="af183f29b2232cbc87cc8dc744f93424e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af183f29b2232cbc87cc8dc744f93424e">&#9670;&nbsp;</a></span>hasDevice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasDevice </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a generic device of type T and named name exists in the robot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of device requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6addeeebfb0b899376ed338b212a33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6addeeebfb0b899376ed338b212a33a">&#9670;&nbsp;</a></span>hasForceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a force sensor exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sensor exists, false otherwise </dd></dl>

</div>
</div>
<a id="aafb78a38ec8b2037519f030140a95976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb78a38ec8b2037519f030140a95976">&#9670;&nbsp;</a></span>hasJoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasJoint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the robot has a joint named <code>name</code>. </p>

<p class="reference">Referenced by <a class="el" href="a02404.html#a5d90bfa419602be569c6098e822cdb0d">mc_tasks::MetaTask::ensureHasJoints()</a>.</p>

</div>
</div>
<a id="ab011a5322c37711cf940653e7b814b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab011a5322c37711cf940653e7b814b50">&#9670;&nbsp;</a></span>hasSensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01696.html#af183f29b2232cbc87cc8dc744f93424e" title="Returns true if a generic device of type T and named name exists in the robot. ">hasDevice</a> </dd></dl>

</div>
</div>
<a id="a47874ad9d5abdcd85701b02e2c85cefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47874ad9d5abdcd85701b02e2c85cefb">&#9670;&nbsp;</a></span>hasSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::hasSurface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a surface <code>surface</code> exists. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the surface exists, false otherwise </dd></dl>

</div>
</div>
<a id="a901f76e997eccaa20ef748302229edf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901f76e997eccaa20ef748302229edf6">&#9670;&nbsp;</a></span>indirectBodyForceSensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01632.html">ForceSensor</a>&amp; mc_rbdyn::Robot::indirectBodyForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a force sensor directly or indirectly attached to a body. </p>
<p>When the sensor is not directly attached to the body, look up the kinematic chain until the root until a sensor is found.</p>
<dl class="section return"><dt>Returns</dt><dd>The sensor to which the body is indirectly attached</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is found between the body and the root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c2ceb538921611b7b50a50634859e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2ceb538921611b7b50a50634859e5f">&#9670;&nbsp;</a></span>indirectBodyForceSensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01632.html">ForceSensor</a>&amp; mc_rbdyn::Robot::indirectBodyForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const variant. </p>

</div>
</div>
<a id="a4733eee02a2b700c1e5ab9796f92b26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4733eee02a2b700c1e5ab9796f92b26b">&#9670;&nbsp;</a></span>indirectSurfaceForceSensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01632.html">ForceSensor</a>&amp; mc_rbdyn::Robot::indirectSurfaceForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a force sensor directly or indirectly attached to a surface. </p>
<p>When the sensor is not directly attached to the surface, look up the kinematic chain until the root until a sensor is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>Name of surface indirectly attached to the sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sensor to which the surface is indirectly attached</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is found between the surface and the root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77d7387d7242da1e7c42420583dce311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d7387d7242da1e7c42420583dce311">&#9670;&nbsp;</a></span>indirectSurfaceForceSensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01632.html">ForceSensor</a>&amp; mc_rbdyn::Robot::indirectSurfaceForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const variant. </p>

</div>
</div>
<a id="a7ad6afc9dd0267860a325771e7f87ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad6afc9dd0267860a325771e7f87ea1">&#9670;&nbsp;</a></span>jointIndexByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mc_rbdyn::Robot::jointIndexByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3662367cdf4edb974bdad793b1189b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3662367cdf4edb974bdad793b1189b20">&#9670;&nbsp;</a></span>jointIndexInMBC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mc_rbdyn::Robot::jointIndexInMBC </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>jointIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the joint index in the mbc of the joint with index jointIndex in refJointOrder. </p>
<dl class="section note"><dt>Note</dt><dd>Joint indices can be -1 for joints present in refJointOrder but not in the robot's mbc (such as filtered joints in some robot modules)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jointIndex</td><td>Joint index in refJointOrder</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>joint index in the mbc</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>jointIndex &gt;= refJointOrder.size() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95798f9588d0656c61558ab20ad935b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95798f9588d0656c61558ab20ad935b4">&#9670;&nbsp;</a></span>jointTorque() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::jointTorque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().jointTorque (const) </p>

</div>
</div>
<a id="af946d00c2f9e36ed5c0899f237f35c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af946d00c2f9e36ed5c0899f237f35c32">&#9670;&nbsp;</a></span>jointTorque() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::jointTorque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().jointTorque. </p>

</div>
</div>
<a id="a91168b4930361d5a61a60a925ae0cc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91168b4930361d5a61a60a925ae0cc6d">&#9670;&nbsp;</a></span>jointTorques() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; mc_rbdyn::Robot::jointTorques </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the joint torques from sensors. </p>

</div>
</div>
<a id="abc6661a03573ba04f70c8cd14939dd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6661a03573ba04f70c8cd14939dd0e">&#9670;&nbsp;</a></span>jointTorques() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::jointTorques </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>jointTorques</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set joint torques from sensors. </p>

</div>
</div>
<a id="a1554209253be449c1fb4cdd7e3d2478d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1554209253be449c1fb4cdd7e3d2478d">&#9670;&nbsp;</a></span>loadRSDFFromDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::loadRSDFFromDir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surfaceDir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load surfaces from the directory <code>surfaceDir</code>. </p>

</div>
</div>
<a id="a357a8bb518ee6ce00d8b25c5437b79c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357a8bb518ee6ce00d8b25c5437b79c5">&#9670;&nbsp;</a></span>mass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mc_rbdyn::Robot::mass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and returns the mass of the robot. </p>

</div>
</div>
<a id="a79bdab3efcd9ada4d2b3aefa53374af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bdab3efcd9ada4d2b3aefa53374af1">&#9670;&nbsp;</a></span>mb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rbd::MultiBody&amp; mc_rbdyn::Robot::mb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access MultiBody representation of the robot. </p>

</div>
</div>
<a id="ab09b1765903debcc06dce65ce830cfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09b1765903debcc06dce65ce830cfc0">&#9670;&nbsp;</a></span>mb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rbd::MultiBody&amp; mc_rbdyn::Robot::mb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access MultiBody representation of the robot (const) </p>

</div>
</div>
<a id="a0051e9ce612a34601d6934f7d5caaeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0051e9ce612a34601d6934f7d5caaeb4">&#9670;&nbsp;</a></span>mbc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rbd::MultiBodyConfig&amp; mc_rbdyn::Robot::mbc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access MultiBodyConfig of the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a> </p>

</div>
</div>
<a id="aece5a00f65317b116f70ed2937239421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece5a00f65317b116f70ed2937239421">&#9670;&nbsp;</a></span>mbc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rbd::MultiBodyConfig&amp; mc_rbdyn::Robot::mbc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access MultiBodyConfig of the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a> (const) </p>

</div>
</div>
<a id="a900ba960e115fa967889ebdb842f6a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900ba960e115fa967889ebdb842f6a3e">&#9670;&nbsp;</a></span>mbg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rbd::MultiBodyGraph&amp; mc_rbdyn::Robot::mbg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access MultiBodyGraph that generated the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a> </p>

</div>
</div>
<a id="a78336b8d90c933da75cd138227072321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78336b8d90c933da75cd138227072321">&#9670;&nbsp;</a></span>mbg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rbd::MultiBodyGraph&amp; mc_rbdyn::Robot::mbg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access MultiBodyGraph that generated the robot's <a class="el" href="a01696.html#a79bdab3efcd9ada4d2b3aefa53374af1" title="Access MultiBody representation of the robot. ">mb()</a> (const) </p>

</div>
</div>
<a id="a3e734d771ca6cf96801de8765cee637d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e734d771ca6cf96801de8765cee637d">&#9670;&nbsp;</a></span>module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01724.html">RobotModule</a>&amp; mc_rbdyn::Robot::module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the associated <a class="el" href="a01724.html">RobotModule</a>. </p>

</div>
</div>
<a id="a9f0c4c44861063b684d43d4ad78a995e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0c4c44861063b684d43d4ad78a995e">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; mc_rbdyn::Robot::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the robot. </p>
<dl class="section note"><dt>Note</dt><dd>To rename a robot, use <a class="el" href="a01736.html#a2dc538d2351dacdde105943658330f39" title="Rename an existing robot. ">Robots::rename(const std::string &amp;, const std::string &amp;)</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="a02404.html#a5d90bfa419602be569c6098e822cdb0d">mc_tasks::MetaTask::ensureHasJoints()</a>.</p>

</div>
</div>
<a id="a117494f13e48578a752a102e322189b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117494f13e48578a752a102e322189b0">&#9670;&nbsp;</a></span>netWrench()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sva::ForceVecd mc_rbdyn::Robot::netWrench </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sensorNames</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes net total wrench from a list of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorNames</td><td>Names of all sensors used to compute the net wrench</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Net total wrench (without gravity) in the inertial frame </dd></dl>

</div>
</div>
<a id="a2e0f6aac369cb793546b62a13809a897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0f6aac369cb793546b62a13809a897">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01696.html">Robot</a>&amp; mc_rbdyn::Robot::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01696.html">Robot</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48843047df8893808f80971fa3f9257f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48843047df8893808f80971fa3f9257f">&#9670;&nbsp;</a></span>posW() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::PTransformd&amp; mc_rbdyn::Robot::posW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the robot's global pose. </p>

</div>
</div>
<a id="a54fe0da3fe099906b79cb20de8076659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fe0da3fe099906b79cb20de8076659">&#9670;&nbsp;</a></span>posW() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::posW </td>
          <td>(</td>
          <td class="paramtype">const sva::PTransformd &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the robot's global pose. </p>
<p>This is mostly meant for initialization purposes. In other scenarios there might be more things to do to properly move a robot (e.g. update contacts, set speed to zero).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>The new global pose</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>joint(0) is neither free flyer nor fixed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function takes care of calling rbd::forwardKinematics </dd></dl>

</div>
</div>
<a id="a485eb8aa4ceb0a0a5010844d16e47f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485eb8aa4ceb0a0a5010844d16e47f95">&#9670;&nbsp;</a></span>q() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().q (const) </p>

</div>
</div>
<a id="a8ad8d3434a21adb16f8c41a5444ea067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad8d3434a21adb16f8c41a5444ea067">&#9670;&nbsp;</a></span>q() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to robot.mbc().q. </p>

</div>
</div>
<a id="ac18cb6ecabada0aac1f823b7e9170308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18cb6ecabada0aac1f823b7e9170308">&#9670;&nbsp;</a></span>ql() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::ql </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular lower limits (const) </p>

</div>
</div>
<a id="afc061e1b33c4f633a04015ab3fb20f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc061e1b33c4f633a04015ab3fb20f94">&#9670;&nbsp;</a></span>ql() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::ql </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular lower limits. </p>

</div>
</div>
<a id="ac42c2ce3eea4e1100b4fc77b95821021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42c2ce3eea4e1100b4fc77b95821021">&#9670;&nbsp;</a></span>qu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::qu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular upper limits (const) </p>

</div>
</div>
<a id="ac6915de62543382030defd22b9f8011c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6915de62543382030defd22b9f8011c">&#9670;&nbsp;</a></span>qu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::qu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular upper limits. </p>

</div>
</div>
<a id="a00856f04c24c914b9197fe11f2d573eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00856f04c24c914b9197fe11f2d573eb">&#9670;&nbsp;</a></span>refJointOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; mc_rbdyn::Robot::refJointOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reference joint order for this robot. </p>

</div>
</div>
<a id="a3296b923f06db47d80641b7acf46e5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3296b923f06db47d80641b7acf46e5bf">&#9670;&nbsp;</a></span>removeConvex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::removeConvex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a given convex. </p>
<p>Using this function while the given convex is involved in a collision is <em>not</em> safe and will very likely result in a crash.</p>
<p>This has no effect if <code>name</code> is not a convex of the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the convex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af110c909887516af9f6758118978b643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af110c909887516af9f6758118978b643">&#9670;&nbsp;</a></span>robotIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mc_rbdyn::Robot::robotIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's index in robots() </p>

</div>
</div>
<a id="ac945ba1c44d9dfb2f2312d13c8ed24b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac945ba1c44d9dfb2f2312d13c8ed24b4">&#9670;&nbsp;</a></span>sensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; mc_rbdyn::Robot::sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01696.html#a4e3272e412d22bf6d382117300c9ee42" title="Get a generic device of type T named name. ">device</a> </dd></dl>

</div>
</div>
<a id="a72a8bd2c7daead0016449a6056fd2035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a8bd2c7daead0016449a6056fd2035">&#9670;&nbsp;</a></span>sensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; mc_rbdyn::Robot::sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01696.html#a4e3272e412d22bf6d382117300c9ee42" title="Get a generic device of type T named name. ">device</a> </dd></dl>

</div>
</div>
<a id="ac4b932fc4c4956b16490006dd8591d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b932fc4c4956b16490006dd8591d0e">&#9670;&nbsp;</a></span>stance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;double&gt; &gt; mc_rbdyn::Robot::stance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the robot's default stance (e.g. </p>
<p>half-sitting for humanoid) </p>

</div>
</div>
<a id="aa4b724e51881215dd4293f9578656755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b724e51881215dd4293f9578656755">&#9670;&nbsp;</a></span>surface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01744.html">mc_rbdyn::Surface</a>&amp; mc_rbdyn::Robot::surface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a surface by its name <code>sName</code>. </p>

</div>
</div>
<a id="a032e4252cb8c2c1d2ab82bd353b1cfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032e4252cb8c2c1d2ab82bd353b1cfb2">&#9670;&nbsp;</a></span>surface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01744.html">mc_rbdyn::Surface</a>&amp; mc_rbdyn::Robot::surface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a surface by its name <code>sName</code> (const) </p>

</div>
</div>
<a id="ac4bfab32c0f157b828a70134f1ffe985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bfab32c0f157b828a70134f1ffe985">&#9670;&nbsp;</a></span>surfaceForceSensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01632.html">ForceSensor</a>&amp; mc_rbdyn::Robot::surfaceForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surfaceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a force sensor attached to the provided surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>Name of the surface to which the sensor is attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attached sensor</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is directly attached to this surface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01632.html" title="This struct is intended to hold static information about a force sensor and the current reading of sa...">ForceSensor</a> &amp; <a class="el" href="a01696.html#a901f76e997eccaa20ef748302229edf6" title="Return a force sensor directly or indirectly attached to a body. ">indirectBodyForceSensor(const std::string &amp; surface)</a>; To get a <a class="el" href="a01696.html#ac945ba1c44d9dfb2f2312d13c8ed24b4" title="Alias for. ">sensor</a> directly or indirectly attached to the <a class="el" href="a01696.html#aa4b724e51881215dd4293f9578656755" title="Access a surface by its name sName. ">surface</a>. </dd></dl>

</div>
</div>
<a id="ace64ab0161e9b00e262b408733d19629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace64ab0161e9b00e262b408733d19629">&#9670;&nbsp;</a></span>surfaceForceSensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01632.html">ForceSensor</a>&amp; mc_rbdyn::Robot::surfaceForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surfaceName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const variant. </p>

</div>
</div>
<a id="a7fb66cf0e07c2f24d9329cce0f6e5d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb66cf0e07c2f24d9329cce0f6e5d3b">&#9670;&nbsp;</a></span>surfaceHasForceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::surfaceHasForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the surface has a force sensor directly attached to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>Name of the surface to which the sensor is directly attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>surfaceHasIndirectForceSensor(const std::string &amp;) if you wish to check whether a <a class="el" href="a01696.html#ac945ba1c44d9dfb2f2312d13c8ed24b4" title="Alias for. ">sensor</a> is indirectly attached to a body</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the surface has a force sensor attached to it, false otherwise </dd></dl>

</div>
</div>
<a id="ae05708ca15a7afb1c1b24315f4468356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05708ca15a7afb1c1b24315f4468356">&#9670;&nbsp;</a></span>surfaceHasIndirectForceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mc_rbdyn::Robot::surfaceHasIndirectForceSensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the surface has a force sensor attached to it (directly or indirectly) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>Name of the surface to which the sensor is directly attached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the surface has a force sensor attached to it, false otherwise </dd></dl>

</div>
</div>
<a id="a0c21632fb2dc076e87cc4f4b6f840ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c21632fb2dc076e87cc4f4b6f840ddb">&#9670;&nbsp;</a></span>surfacePose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sva::PTransformd mc_rbdyn::Robot::surfacePose </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pose of a surface frame with respect to the inertial frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sName</td><td>Name of surface frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee61e66a131e6f3e24982d4c68ffe958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee61e66a131e6f3e24982d4c68ffe958">&#9670;&nbsp;</a></span>surfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="a00766.html#a848cf0b2e8f6ca6f18ceba1769d9a426">mc_rbdyn::SurfacePtr</a>&gt;&amp; mc_rbdyn::Robot::surfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all available surfaces. </p>

</div>
</div>
<a id="a928b9370f7643511d1ec80892245fb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928b9370f7643511d1ec80892245fb88">&#9670;&nbsp;</a></span>surfaceWrench()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sva::ForceVecd mc_rbdyn::Robot::surfaceWrench </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>surfaceName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gravity-free wrench in surface frame. </p>
<dl class="section note"><dt>Note</dt><dd>If the surface is indirectly attached to the sensor (i.e there are joints in-between), then the kinematic transformation will be taken into account but the effect of bodies in-between is not accounted for in the returned wrench.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceName</td><td>A surface attached to a force sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Measured wrench in surface frame</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>no sensor is attached to this surface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fa7e717817cab5e190f17d0397ff934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa7e717817cab5e190f17d0397ff934">&#9670;&nbsp;</a></span>tdl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tdl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular lower torque-derivative limits (const) </p>

</div>
</div>
<a id="a39a5fe0d5e143aae2d95ba39e56ab0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a5fe0d5e143aae2d95ba39e56ab0a9">&#9670;&nbsp;</a></span>tdl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tdl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular lower torque-derivative limits. </p>

</div>
</div>
<a id="a2607ecfbe200094f4bba59ac7c5c390d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2607ecfbe200094f4bba59ac7c5c390d">&#9670;&nbsp;</a></span>tdu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tdu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular upper torque-derivative limits (const) </p>

</div>
</div>
<a id="a77a7831e452c28f863abba6992990ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a7831e452c28f863abba6992990ac8">&#9670;&nbsp;</a></span>tdu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tdu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular upper torque-derivative limits. </p>

</div>
</div>
<a id="afd4cbabd88c9ee4565a2555dcc0208ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4cbabd88c9ee4565a2555dcc0208ae">&#9670;&nbsp;</a></span>tl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular lower torque limits (const) </p>

</div>
</div>
<a id="adf6dfded6aa9e9c6ca6ff6d8e386b66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6dfded6aa9e9c6ca6ff6d8e386b66d">&#9670;&nbsp;</a></span>tl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular lower torque limits. </p>

</div>
</div>
<a id="a74f8c3970a3aff460fc5abad5b493eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f8c3970a3aff460fc5abad5b493eb6">&#9670;&nbsp;</a></span>tu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular upper torque limits (const) </p>

</div>
</div>
<a id="afe854537bd0f1fb8ab64ce91f5f6105d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe854537bd0f1fb8ab64ce91f5f6105d">&#9670;&nbsp;</a></span>tu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::tu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular upper torque limits. </p>

</div>
</div>
<a id="a50f3f6250f68bac91a2594e9e6383b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f3f6250f68bac91a2594e9e6383b2f">&#9670;&nbsp;</a></span>velW() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::velW </td>
          <td>(</td>
          <td class="paramtype">const sva::MotionVecd &amp;&#160;</td>
          <td class="paramname"><em>vel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the robot's floating base velocity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vel</td><td>New floating base velocity in the inertial frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function takes care of calling rbd::forwardVelocity </dd></dl>

</div>
</div>
<a id="a38618f0ff197fccef53069f51e9fcafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38618f0ff197fccef53069f51e9fcafc">&#9670;&nbsp;</a></span>velW() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sva::MotionVecd&amp; mc_rbdyn::Robot::velW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the robot's floating base velocity expressed in the inertial frame. </p>

</div>
</div>
<a id="ab63444fe66136d722426aca78449d62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63444fe66136d722426aca78449d62a">&#9670;&nbsp;</a></span>vl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::vl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular lower velocity limits (const) </p>

</div>
</div>
<a id="a8a8dbaec40be4ad0be51f4df67502d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8dbaec40be4ad0be51f4df67502d39">&#9670;&nbsp;</a></span>vl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::vl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular lower velocity limits. </p>

</div>
</div>
<a id="ac77b8ab43b004940508945dcb1234e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77b8ab43b004940508945dcb1234e60">&#9670;&nbsp;</a></span>vu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::vu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular upper velocity limits (const) </p>

</div>
</div>
<a id="ae6c3ad6f7d81353b09689ea6e41eec34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c3ad6f7d81353b09689ea6e41eec34">&#9670;&nbsp;</a></span>vu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt;&amp; mc_rbdyn::Robot::vu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the robot's angular upper velocity limits. </p>

</div>
</div>
<a id="a76547cf0aab26354dad897265d6060ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76547cf0aab26354dad897265d6060ee">&#9670;&nbsp;</a></span>X_b1_b2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sva::PTransformd mc_rbdyn::Robot::X_b1_b2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relative transformation X_b1_b2 from body b1 to body b2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>name of first body </td></tr>
    <tr><td class="paramname">b2</td><td>name of second body </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>b1 or b2 does not exist within the robot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2dbbe9a2cb2c0eb61790cd7f3dc9c4">&#9670;&nbsp;</a></span>zmp() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">const sva::ForceVecd &amp;&#160;</td>
          <td class="paramname"><em>netTotalWrench</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actual ZMP computation from net total wrench and the ZMP plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netTotalWrench</td><td>Total wrench for all links in contact </td></tr>
    <tr><td class="paramname">plane_p</td><td>Arbitrary point on the ZMP plane </td></tr>
    <tr><td class="paramname">plane_n</td><td>Normal to the ZMP plane (normalized) </td></tr>
    <tr><td class="paramname">minimalNetNormalForce[N]</td><td>Mininal force above which the ZMP computation is considered valid. Must be &gt;0 (prevents a divide by zero).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zmp expressed in the requested plane</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">To</td><td>prevent dividing by zero, throws if the projected force is below minimalNetNormalForce newton. This is highly unlikely to happen and would likely indicate indicate that you are computing a ZMP from invalid forces (such as with the robot in the air).</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="zmpDoc"></a> </p><dl class="section see"><dt>See also</dt><dd>Eigen::Vector3d <a class="el" href="a00766.html#a329453006944dae96fa60d86dca66db8" title="Actual ZMP computation from net total wrench and the ZMP plane. ">mc_rbdyn::zmp</a>(const sva::ForceVecd &amp; netTotalWrench, const Eigen::Vector3d &amp; plane_p, const Eigen::Vector3d &amp; plane_n, double minimalNetNormalForce) </dd></dl>

</div>
</div>
<a id="aca98040d3ecdb597c65f3615a06d588d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca98040d3ecdb597c65f3615a06d588d">&#9670;&nbsp;</a></span>zmp() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">const sva::ForceVecd &amp;&#160;</td>
          <td class="paramname"><em>netTotalWrench</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::PTransformd &amp;&#160;</td>
          <td class="paramname"><em>zmpFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZMP computation from net total wrench and a frame. </p>
<p>See <a class="el" href="a00766.html#zmpDoc">zmpDoc</a></p>
<dl class="section see"><dt>See also</dt><dd>Eigen::Vector3d <a class="el" href="a00766.html#a329453006944dae96fa60d86dca66db8" title="Actual ZMP computation from net total wrench and the ZMP plane. ">mc_rbdyn::zmp</a>(const sva::ForceVecd &amp; netTotalWrench, const sva::PTransformd &amp; zmpFrame, double minimalNetNormalForce) const;</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netTotalWrench</td><td></td></tr>
    <tr><td class="paramname">zmpFrame</td><td>Frame used for ZMP computation. The convention here is that the contact frame should have its z-axis pointing in the normal direction of the contact towards the robot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ZMP expressed in the plane defined by the zmpFrame frame. </dd></dl>

</div>
</div>
<a id="a472551d6b434e3e5a2239b35cffc639b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472551d6b434e3e5a2239b35cffc639b">&#9670;&nbsp;</a></span>zmp() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sensorNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>plane_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the ZMP from sensor names and a plane. </p>
<p>See <a class="el" href="a00766.html#zmpDoc">zmpDoc</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorNames</td><td>Names of all sensors attached to a link in contact with the environment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b62d2a94e3c81f2c436828bc9ed5186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b62d2a94e3c81f2c436828bc9ed5186">&#9670;&nbsp;</a></span>zmp() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d mc_rbdyn::Robot::zmp </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sensorNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sva::PTransformd &amp;&#160;</td>
          <td class="paramname"><em>zmpFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimalNetNormalForce</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the ZMP from sensor names and a frame. </p>
<p>See <a class="el" href="a00766.html#zmpDoc">zmpDoc</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorNames</td><td>Names of all sensors attached to a link in contact with the environment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad70ad9c81c418baf93ecccd6a75ff12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70ad9c81c418baf93ecccd6a75ff12f">&#9670;&nbsp;</a></span>zmpTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mc_rbdyn::Robot::zmpTarget </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>zmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target zmp defined with respect to base-link. </p>
<p>This target is intended to be used by an external stabilizer such as Kawada's</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zmp</td><td>Note that usually the ZMP is a 2-vector assuming a perfectly flat ground. The convention here is that the ground is at (tz=0). Therefore the target zmp should be defined as (ZMPx, ZMPy, -zbaselink) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fa1d2571113230a15a6726fb06b91fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa1d2571113230a15a6726fb06b91fa">&#9670;&nbsp;</a></span>zmpTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3d&amp; mc_rbdyn::Robot::zmpTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the target zmp. </p>
<dl class="section return"><dt>Returns</dt><dd>Target ZMP. See zmpTarget(Eigen::Vector3d) for details. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a7ea6242bb22401bac23542e1db3a74ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea6242bb22401bac23542e1db3a74ed">&#9670;&nbsp;</a></span>Robots</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="a01736.html">Robots</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00766.html">mc_rbdyn</a></li><li class="navelem"><a class="el" href="a01696.html">Robot</a></li>
    <li class="footer">Generated on Tue Oct 27 2020 11:09:02 for mc_rtc by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
