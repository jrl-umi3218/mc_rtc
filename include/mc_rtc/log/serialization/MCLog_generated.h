// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MCLOG_MC_RTC_LOG_H_
#define FLATBUFFERS_GENERATED_MCLOG_MC_RTC_LOG_H_

#include "flatbuffers/flatbuffers.h"

namespace mc_rtc {
namespace log {

struct Bool;

struct Double;

struct DoubleVector;

struct UnsignedInt;

struct String;

struct Vector3d;

struct Quaterniond;

struct PTransformd;

struct ForceVecd;

struct MotionVecd;

struct Log;

enum LogData {
  LogData_NONE = 0,
  LogData_Bool = 1,
  LogData_Double = 2,
  LogData_DoubleVector = 3,
  LogData_UnsignedInt = 4,
  LogData_String = 5,
  LogData_Vector3d = 6,
  LogData_Quaterniond = 7,
  LogData_PTransformd = 8,
  LogData_ForceVecd = 9,
  LogData_MotionVecd = 10,
  LogData_MIN = LogData_NONE,
  LogData_MAX = LogData_MotionVecd
};

inline LogData (&EnumValuesLogData())[11] {
  static LogData values[] = {
    LogData_NONE,
    LogData_Bool,
    LogData_Double,
    LogData_DoubleVector,
    LogData_UnsignedInt,
    LogData_String,
    LogData_Vector3d,
    LogData_Quaterniond,
    LogData_PTransformd,
    LogData_ForceVecd,
    LogData_MotionVecd
  };
  return values;
}

inline const char **EnumNamesLogData() {
  static const char *names[] = {
    "NONE",
    "Bool",
    "Double",
    "DoubleVector",
    "UnsignedInt",
    "String",
    "Vector3d",
    "Quaterniond",
    "PTransformd",
    "ForceVecd",
    "MotionVecd",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogData(LogData e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLogData()[index];
}

template<typename T> struct LogDataTraits {
  static const LogData enum_value = LogData_NONE;
};

template<> struct LogDataTraits<Bool> {
  static const LogData enum_value = LogData_Bool;
};

template<> struct LogDataTraits<Double> {
  static const LogData enum_value = LogData_Double;
};

template<> struct LogDataTraits<DoubleVector> {
  static const LogData enum_value = LogData_DoubleVector;
};

template<> struct LogDataTraits<UnsignedInt> {
  static const LogData enum_value = LogData_UnsignedInt;
};

template<> struct LogDataTraits<String> {
  static const LogData enum_value = LogData_String;
};

template<> struct LogDataTraits<Vector3d> {
  static const LogData enum_value = LogData_Vector3d;
};

template<> struct LogDataTraits<Quaterniond> {
  static const LogData enum_value = LogData_Quaterniond;
};

template<> struct LogDataTraits<PTransformd> {
  static const LogData enum_value = LogData_PTransformd;
};

template<> struct LogDataTraits<ForceVecd> {
  static const LogData enum_value = LogData_ForceVecd;
};

template<> struct LogDataTraits<MotionVecd> {
  static const LogData enum_value = LogData_MotionVecd;
};

bool VerifyLogData(flatbuffers::Verifier &verifier, const void *obj, LogData type);
bool VerifyLogDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Bool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_B = 4
  };
  bool b() const {
    return GetField<uint8_t>(VT_B, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           verifier.EndTable();
  }
};

struct BoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_b(bool b) {
    fbb_.AddElement<uint8_t>(Bool::VT_B, static_cast<uint8_t>(b), 0);
  }
  BoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoolBuilder &operator=(const BoolBuilder &);
  flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bool> CreateBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool b = false) {
  BoolBuilder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

struct Double FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_D = 4
  };
  double d() const {
    return GetField<double>(VT_D, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_D) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_d(double d) {
    fbb_.AddElement<double>(Double::VT_D, d, 0.0);
  }
  DoubleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleBuilder &operator=(const DoubleBuilder &);
  flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline flatbuffers::Offset<Double> CreateDouble(
    flatbuffers::FlatBufferBuilder &_fbb,
    double d = 0.0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_d(d);
  return builder_.Finish();
}

struct DoubleVector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_V = 4
  };
  const flatbuffers::Vector<double> *v() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_V);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.Verify(v()) &&
           verifier.EndTable();
  }
};

struct DoubleVectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_v(flatbuffers::Offset<flatbuffers::Vector<double>> v) {
    fbb_.AddOffset(DoubleVector::VT_V, v);
  }
  DoubleVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleVectorBuilder &operator=(const DoubleVectorBuilder &);
  flatbuffers::Offset<DoubleVector> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DoubleVector>(end);
    return o;
  }
};

inline flatbuffers::Offset<DoubleVector> CreateDoubleVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> v = 0) {
  DoubleVectorBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

inline flatbuffers::Offset<DoubleVector> CreateDoubleVectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *v = nullptr) {
  return mc_rtc::log::CreateDoubleVector(
      _fbb,
      v ? _fbb.CreateVector<double>(*v) : 0);
}

struct UnsignedInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_I = 4
  };
  uint32_t i() const {
    return GetField<uint32_t>(VT_I, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_I) &&
           verifier.EndTable();
  }
};

struct UnsignedIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_i(uint32_t i) {
    fbb_.AddElement<uint32_t>(UnsignedInt::VT_I, i, 0);
  }
  UnsignedIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnsignedIntBuilder &operator=(const UnsignedIntBuilder &);
  flatbuffers::Offset<UnsignedInt> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<UnsignedInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsignedInt> CreateUnsignedInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t i = 0) {
  UnsignedIntBuilder builder_(_fbb);
  builder_.add_i(i);
  return builder_.Finish();
}

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_S = 4
  };
  const flatbuffers::String *s() const {
    return GetPointer<const flatbuffers::String *>(VT_S);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.Verify(s()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_s(flatbuffers::Offset<flatbuffers::String> s) {
    fbb_.AddOffset(String::VT_S, s);
  }
  StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringBuilder &operator=(const StringBuilder &);
  flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<String>(end);
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> s = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_s(s);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *s = nullptr) {
  return mc_rtc::log::CreateString(
      _fbb,
      s ? _fbb.CreateString(s) : 0);
}

struct Vector3d FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct Vector3dBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Vector3d::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector3d::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector3d::VT_Z, z, 0.0);
  }
  Vector3dBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Vector3dBuilder &operator=(const Vector3dBuilder &);
  flatbuffers::Offset<Vector3d> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Vector3d>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector3d> CreateVector3d(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  Vector3dBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Quaterniond FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_W = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  double w() const {
    return GetField<double>(VT_W, 0.0);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_W) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct QuaterniondBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_w(double w) {
    fbb_.AddElement<double>(Quaterniond::VT_W, w, 0.0);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Quaterniond::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Quaterniond::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Quaterniond::VT_Z, z, 0.0);
  }
  QuaterniondBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuaterniondBuilder &operator=(const QuaterniondBuilder &);
  flatbuffers::Offset<Quaterniond> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Quaterniond>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaterniond> CreateQuaterniond(
    flatbuffers::FlatBufferBuilder &_fbb,
    double w = 0.0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  QuaterniondBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_w(w);
  return builder_.Finish();
}

struct PTransformd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ORI = 4,
    VT_POS = 6
  };
  const Quaterniond *ori() const {
    return GetPointer<const Quaterniond *>(VT_ORI);
  }
  const Vector3d *pos() const {
    return GetPointer<const Vector3d *>(VT_POS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORI) &&
           verifier.VerifyTable(ori()) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           verifier.EndTable();
  }
};

struct PTransformdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ori(flatbuffers::Offset<Quaterniond> ori) {
    fbb_.AddOffset(PTransformd::VT_ORI, ori);
  }
  void add_pos(flatbuffers::Offset<Vector3d> pos) {
    fbb_.AddOffset(PTransformd::VT_POS, pos);
  }
  PTransformdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PTransformdBuilder &operator=(const PTransformdBuilder &);
  flatbuffers::Offset<PTransformd> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<PTransformd>(end);
    return o;
  }
};

inline flatbuffers::Offset<PTransformd> CreatePTransformd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Quaterniond> ori = 0,
    flatbuffers::Offset<Vector3d> pos = 0) {
  PTransformdBuilder builder_(_fbb);
  builder_.add_pos(pos);
  builder_.add_ori(ori);
  return builder_.Finish();
}

struct ForceVecd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COUPLE = 4,
    VT_FORCE = 6
  };
  const Vector3d *couple() const {
    return GetPointer<const Vector3d *>(VT_COUPLE);
  }
  const Vector3d *force() const {
    return GetPointer<const Vector3d *>(VT_FORCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COUPLE) &&
           verifier.VerifyTable(couple()) &&
           VerifyOffset(verifier, VT_FORCE) &&
           verifier.VerifyTable(force()) &&
           verifier.EndTable();
  }
};

struct ForceVecdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_couple(flatbuffers::Offset<Vector3d> couple) {
    fbb_.AddOffset(ForceVecd::VT_COUPLE, couple);
  }
  void add_force(flatbuffers::Offset<Vector3d> force) {
    fbb_.AddOffset(ForceVecd::VT_FORCE, force);
  }
  ForceVecdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ForceVecdBuilder &operator=(const ForceVecdBuilder &);
  flatbuffers::Offset<ForceVecd> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<ForceVecd>(end);
    return o;
  }
};

inline flatbuffers::Offset<ForceVecd> CreateForceVecd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Vector3d> couple = 0,
    flatbuffers::Offset<Vector3d> force = 0) {
  ForceVecdBuilder builder_(_fbb);
  builder_.add_force(force);
  builder_.add_couple(couple);
  return builder_.Finish();
}

struct MotionVecd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ANGULAR = 4,
    VT_LINEAR = 6
  };
  const Vector3d *angular() const {
    return GetPointer<const Vector3d *>(VT_ANGULAR);
  }
  const Vector3d *linear() const {
    return GetPointer<const Vector3d *>(VT_LINEAR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANGULAR) &&
           verifier.VerifyTable(angular()) &&
           VerifyOffset(verifier, VT_LINEAR) &&
           verifier.VerifyTable(linear()) &&
           verifier.EndTable();
  }
};

struct MotionVecdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_angular(flatbuffers::Offset<Vector3d> angular) {
    fbb_.AddOffset(MotionVecd::VT_ANGULAR, angular);
  }
  void add_linear(flatbuffers::Offset<Vector3d> linear) {
    fbb_.AddOffset(MotionVecd::VT_LINEAR, linear);
  }
  MotionVecdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MotionVecdBuilder &operator=(const MotionVecdBuilder &);
  flatbuffers::Offset<MotionVecd> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<MotionVecd>(end);
    return o;
  }
};

inline flatbuffers::Offset<MotionVecd> CreateMotionVecd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Vector3d> angular = 0,
    flatbuffers::Offset<Vector3d> linear = 0) {
  MotionVecdBuilder builder_(_fbb);
  builder_.add_linear(linear);
  builder_.add_angular(angular);
  return builder_.Finish();
}

struct Log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEYS = 4,
    VT_VALUES_TYPE = 6,
    VT_VALUES = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_KEYS);
  }
  const flatbuffers::Vector<uint8_t> *values_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.Verify(keys()) &&
           verifier.VerifyVectorOfStrings(keys()) &&
           VerifyOffset(verifier, VT_VALUES_TYPE) &&
           verifier.Verify(values_type()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.Verify(values()) &&
           VerifyLogDataVector(verifier, values(), values_type()) &&
           verifier.EndTable();
  }
};

struct LogBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> keys) {
    fbb_.AddOffset(Log::VT_KEYS, keys);
  }
  void add_values_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values_type) {
    fbb_.AddOffset(Log::VT_VALUES_TYPE, values_type);
  }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> values) {
    fbb_.AddOffset(Log::VT_VALUES, values);
  }
  LogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogBuilder &operator=(const LogBuilder &);
  flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Log>(end);
    return o;
  }
};

inline flatbuffers::Offset<Log> CreateLog(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> keys = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> values = 0) {
  LogBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_values_type(values_type);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline flatbuffers::Offset<Log> CreateLogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *keys = nullptr,
    const std::vector<uint8_t> *values_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *values = nullptr) {
  return mc_rtc::log::CreateLog(
      _fbb,
      keys ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*keys) : 0,
      values_type ? _fbb.CreateVector<uint8_t>(*values_type) : 0,
      values ? _fbb.CreateVector<flatbuffers::Offset<void>>(*values) : 0);
}

inline bool VerifyLogData(flatbuffers::Verifier &verifier, const void *obj, LogData type) {
  switch (type) {
    case LogData_NONE: {
      return true;
    }
    case LogData_Bool: {
      auto ptr = reinterpret_cast<const Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogData_Double: {
      auto ptr = reinterpret_cast<const Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogData_DoubleVector: {
      auto ptr = reinterpret_cast<const DoubleVector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogData_UnsignedInt: {
      auto ptr = reinterpret_cast<const UnsignedInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogData_String: {
      auto ptr = reinterpret_cast<const String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogData_Vector3d: {
      auto ptr = reinterpret_cast<const Vector3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogData_Quaterniond: {
      auto ptr = reinterpret_cast<const Quaterniond *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogData_PTransformd: {
      auto ptr = reinterpret_cast<const PTransformd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogData_ForceVecd: {
      auto ptr = reinterpret_cast<const ForceVecd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogData_MotionVecd: {
      auto ptr = reinterpret_cast<const MotionVecd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyLogDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLogData(
        verifier,  values->Get(i), types->GetEnum<LogData>(i))) {
      return false;
    }
  }
  return true;
}

inline const mc_rtc::log::Log *GetLog(const void *buf) {
  return flatbuffers::GetRoot<mc_rtc::log::Log>(buf);
}

inline bool VerifyLogBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mc_rtc::log::Log>(nullptr);
}

inline void FinishLogBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mc_rtc::log::Log> root) {
  fbb.Finish(root);
}

}  // namespace log
}  // namespace mc_rtc

#endif  // FLATBUFFERS_GENERATED_MCLOG_MC_RTC_LOG_H_
