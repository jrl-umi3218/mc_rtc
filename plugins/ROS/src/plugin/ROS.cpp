#include "ROS.h"

#include <mc_rtc_ros/ros.h>

#include <mc_control/GlobalPluginMacros.h>

#include <mc_tasks_ros/LookAtTFTask.h>

namespace mc_plugin
{

// This is useless but ensure we bring in LookAtTFTask into the library
void ROSPlugin::build(mc_control::MCGlobalController & controller)
{
  mc_tasks::LookAtTFTask task("body", Eigen::Vector3d::UnitZ(), "source", "target", controller.controller().robots(),
                              0);
}

void ROSPlugin::init(mc_control::MCGlobalController & controller, const mc_rtc::Configuration & config)
{
  if(config.has("publish"))
  {
    auto conf = config("publish");
    conf("control", publish_control);
    conf("env", publish_env);
    conf("real", publish_real);
    conf("timestep", publish_timestep);
  }
  mc_rtc::ROSBridge::set_publisher_timestep(publish_timestep);
  services_.reset(new ROSServices(mc_rtc::ROSBridge::get_node_handle(), controller));
  reset(controller);
}

void ROSPlugin::reset(mc_control::MCGlobalController & controller)
{
  if(publish_control)
  {
    mc_rtc::ROSBridge::init_robot_publisher("control", controller.timestep(), controller.controller().outputRobot());
    controller.robot().module().addParameter("control");
  }
  if(publish_env)
  {
    auto publish_env = [&controller](const std::string & prefix, mc_rbdyn::Robots & robots, bool use_real)
    {
      size_t env_i = 1;
      for(size_t i = 1; i < robots.size(); ++i)
      {
        auto & r = robots.robot(i);
        r.module().addParameter(prefix + "_" + std::to_string(env_i));
        if(r.robotIndex() == robots.robotIndex()) { continue; }
        mc_rtc::ROSBridge::init_robot_publisher(prefix + "_" + std::to_string(env_i), controller.timestep(), r,
                                                use_real);
        env_i++;
      }
    };
    publish_env("control/env", controller.controller().outputRobots(), false);
    if(publish_real) { publish_env("real/env", controller.controller().outputRealRobots(), true); }
  }
  if(publish_real)
  {
    const auto & real_robot = controller.controller().outputRealRobot();
    mc_rtc::ROSBridge::init_robot_publisher("real", controller.timestep(), real_robot, true);
  }
}

void ROSPlugin::after(mc_control::MCGlobalController & controller)
{
  if(publish_control)
  {
    mc_rtc::ROSBridge::update_robot_publisher("control", controller.timestep(), controller.controller().outputRobot());
  }
  // Publish environment state
  if(publish_env)
  {
    auto update_env = [this, &controller](const std::string & prefix, mc_rbdyn::Robots & robots)
    {
      size_t env_i = 1;
      for(size_t i = 1; i < robots.size(); ++i)
      {
        auto & r = robots.robot(i);
        if(std::count(r.module().parameters().begin(), r.module().parameters().end(), prefix + "_" + std::to_string(env_i)) == 0){
          r.module().addParameter(prefix + "_" + std::to_string(env_i));
        }

        if(r.robotIndex() == robots.robotIndex()) { continue; }
        mc_rtc::ROSBridge::update_robot_publisher(prefix + "_" + std::to_string(env_i), controller.timestep(), r);
        env_i++;
      }
      published_env = std::max<size_t>(publish_env, robots.size() - 1);
    };
    update_env("control/env", controller.controller().outputRobots());
    if(publish_real) { update_env("real/env", controller.controller().outputRealRobots()); }
  }
  // Publish real robot
  if(publish_real)
  {
    auto & real_robot = controller.controller().outputRealRobot();
    mc_rtc::ROSBridge::update_robot_publisher("real", controller.timestep(), real_robot);
  }

  if(controller.robots().size() != mc_rtc::ROSBridge::nb_robot_publisher() / (publish_real ? 2 : 1)){
    for(size_t i = mc_rtc::ROSBridge::nb_robot_publisher() / (publish_real ? 2 : 1); i > controller.robots().size(); i--){
      if(publish_real){
        mc_rtc::ROSBridge::stop_robot_publisher("real/env_" + std::to_string(i - 1));
      }

      mc_rtc::ROSBridge::stop_robot_publisher("control/env_" + std::to_string(i - 1));
    }
  }
}

ROSPlugin::~ROSPlugin()
{
  mc_rtc::ROSBridge::stop_robot_publisher("control");
  mc_rtc::ROSBridge::stop_robot_publisher("real");
  for(size_t i = 0; i < published_env; ++i)
  {
    mc_rtc::ROSBridge::stop_robot_publisher("control/env_" + std::to_string(i + 1));
    mc_rtc::ROSBridge::stop_robot_publisher("real/env_" + std::to_string(i + 1));
  }
}

} // namespace mc_plugin

EXPORT_MC_RTC_PLUGIN("ROS", mc_plugin::ROSPlugin)
